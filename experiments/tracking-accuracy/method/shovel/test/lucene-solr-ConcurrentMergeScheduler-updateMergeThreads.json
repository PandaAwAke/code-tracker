{
  "origin": "codeshovel",
  "repositoryName": "lucene-solr",
  "repositoryPath": "H:\\Projects\\apache\\lucene-solr/.git",
  "startCommitName": "38bf976cd4b9e324c21664bd7ae3d554df803705",
  "sourceFileName": "ConcurrentMergeScheduler.java",
  "functionName": "updateMergeThreads",
  "functionId": "updateMergeThreads",
  "sourceFilePath": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
  "functionStartLine": 300,
  "functionEndLine": 408,
  "numCommitsSeen": 86,
  "timeTaken": 4453,
  "changeHistory": [
    "9540bc37583dfd4e995b893154039fcf031dc3c3",
    "41fcc722ff07393586f7758d8a733c7e2e59bebc",
    "3b67b17493216f6b0c81a981073fd5f61eace6f4",
    "b895ebde4340ed8ae903c7ae51750da3d9837394",
    "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c",
    "9906198ff3d65f8c9b7e99462aab19feb5334790",
    "765eab4008f44bb655b3dbbe4cc625455711536b",
    "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
    "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
    "717c67ab7c2df6901f056ae2a1b5cd8317166b93",
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec",
    "7d35aafe71661e51ee01639ddf88503184610329"
  ],
  "changeHistoryShort": {
    "9540bc37583dfd4e995b893154039fcf031dc3c3": "Ybodychange",
    "41fcc722ff07393586f7758d8a733c7e2e59bebc": "Ybodychange",
    "3b67b17493216f6b0c81a981073fd5f61eace6f4": "Ybodychange",
    "b895ebde4340ed8ae903c7ae51750da3d9837394": "Ybodychange",
    "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c": "Yfilerename",
    "9906198ff3d65f8c9b7e99462aab19feb5334790": "Ybodychange",
    "765eab4008f44bb655b3dbbe4cc625455711536b": "Ybodychange",
    "65b27c2adb9000b64ccd9d3a3b1a5030550b06da": "Ybodychange",
    "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80": "Ybodychange",
    "717c67ab7c2df6901f056ae2a1b5cd8317166b93": "Ybodychange",
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec": "Yfilerename",
    "7d35aafe71661e51ee01639ddf88503184610329": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9540bc37583dfd4e995b893154039fcf031dc3c3": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-7700: Move throughput control and merge aborting out of IndexWriter\u0027s core.\n",
      "commitDate": "2017-03-10, 4:23 a.m.",
      "commitName": "9540bc37583dfd4e995b893154039fcf031dc3c3",
      "commitAuthor": "Dawid Weiss",
      "commitDateOld": "2016-02-22, 5:08 a.m.",
      "commitNameOld": "fa602bf635d4710be2ffe891e252f7d4c2baf302",
      "commitAuthorOld": "Mike McCandless",
      "daysBetweenCommits": 381.97,
      "commitsBetweenForRepo": 2379,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive \u0026 not in the\n    // process of stopping (ie have an active merge):\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      activeMerges.add(mergeThread);\n      threadIdx++;\n    }\n\n    // Sort the merge threads, largest first:\n    CollectionUtil.timSort(activeMerges);\n\n    final int activeMergeCount \u003d activeMerges.size();\n\n    int bigMergeCount \u003d 0;\n\n    for (threadIdx\u003dactiveMergeCount-1;threadIdx\u003e\u003d0;threadIdx--) {\n      MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n      if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB*1024*1024) {\n        bigMergeCount \u003d 1+threadIdx;\n        break;\n      }\n    }\n\n    long now \u003d System.nanoTime();\n\n    StringBuilder message;\n    if (verbose()) {\n      message \u003d new StringBuilder();\n      message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n      message \u003d null;\n    }\n\n    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n      MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n\n      OneMerge merge \u003d mergeThread.merge;\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n\n      double newMBPerSec;\n      if (doPause) {\n        newMBPerSec \u003d 0.0;\n      } else if (merge.maxNumSegments !\u003d -1) {\n        newMBPerSec \u003d forceMergeMBPerSec;\n      } else if (doAutoIOThrottle \u003d\u003d false) {\n        newMBPerSec \u003d Double.POSITIVE_INFINITY;\n      } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB*1024*1024) {\n        // Don\u0027t rate limit small merges:\n        newMBPerSec \u003d Double.POSITIVE_INFINITY;\n      } else {\n        newMBPerSec \u003d targetMBPerSec;\n      }\n\n      MergeRateLimiter rateLimiter \u003d mergeThread.rateLimiter;\n      double curMBPerSec \u003d rateLimiter.getMBPerSec();\n\n      if (verbose()) {\n        long mergeStartNS \u003d merge.mergeStartNS;\n        if (mergeStartNS \u003d\u003d -1) {\n          // IndexWriter didn\u0027t start the merge yet:\n          mergeStartNS \u003d now;\n        }\n        message.append(\u0027\\n\u0027);\n        message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\",\n                                     mergeThread.getName(),\n                                     bytesToMB(merge.estimatedMergeBytes),\n                                     bytesToMB(rateLimiter.getTotalBytesWritten()),\n                                     nsToSec(now - mergeStartNS),\n                                     nsToSec(rateLimiter.getTotalStoppedNS()),\n                                     nsToSec(rateLimiter.getTotalPausedNS()),\n                                     rateToString(rateLimiter.getMBPerSec())));\n\n        if (newMBPerSec !\u003d curMBPerSec) {\n          if (newMBPerSec \u003d\u003d 0.0) {\n            message.append(\"  now stop\");\n          } else if (curMBPerSec \u003d\u003d 0.0) {\n            if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n              message.append(\"  now resume\");\n            } else {\n              message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n            }\n          } else {\n            message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n          }\n        } else if (curMBPerSec \u003d\u003d 0.0) {\n          message.append(\"  leave stopped\");\n        } else {\n          message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n        }\n      }\n\n      rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n      message(message.toString());\n    }\n  }",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 300,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,108 +1,109 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive \u0026 not in the\n     // process of stopping (ie have an active merge):\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n \n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n       final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n       activeMerges.add(mergeThread);\n       threadIdx++;\n     }\n \n     // Sort the merge threads, largest first:\n     CollectionUtil.timSort(activeMerges);\n \n     final int activeMergeCount \u003d activeMerges.size();\n \n     int bigMergeCount \u003d 0;\n \n     for (threadIdx\u003dactiveMergeCount-1;threadIdx\u003e\u003d0;threadIdx--) {\n       MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n       if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB*1024*1024) {\n         bigMergeCount \u003d 1+threadIdx;\n         break;\n       }\n     }\n \n     long now \u003d System.nanoTime();\n \n     StringBuilder message;\n     if (verbose()) {\n       message \u003d new StringBuilder();\n       message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n     } else {\n       message \u003d null;\n     }\n \n     for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n       MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n \n       OneMerge merge \u003d mergeThread.merge;\n \n       // pause the thread if maxThreadCount is smaller than the number of merge threads.\n       final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n \n       double newMBPerSec;\n       if (doPause) {\n         newMBPerSec \u003d 0.0;\n       } else if (merge.maxNumSegments !\u003d -1) {\n         newMBPerSec \u003d forceMergeMBPerSec;\n       } else if (doAutoIOThrottle \u003d\u003d false) {\n         newMBPerSec \u003d Double.POSITIVE_INFINITY;\n       } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB*1024*1024) {\n         // Don\u0027t rate limit small merges:\n         newMBPerSec \u003d Double.POSITIVE_INFINITY;\n       } else {\n         newMBPerSec \u003d targetMBPerSec;\n       }\n \n-      double curMBPerSec \u003d merge.rateLimiter.getMBPerSec();\n-      \n+      MergeRateLimiter rateLimiter \u003d mergeThread.rateLimiter;\n+      double curMBPerSec \u003d rateLimiter.getMBPerSec();\n+\n       if (verbose()) {\n         long mergeStartNS \u003d merge.mergeStartNS;\n         if (mergeStartNS \u003d\u003d -1) {\n           // IndexWriter didn\u0027t start the merge yet:\n           mergeStartNS \u003d now;\n         }\n         message.append(\u0027\\n\u0027);\n         message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\",\n                                      mergeThread.getName(),\n                                      bytesToMB(merge.estimatedMergeBytes),\n-                                     bytesToMB(merge.rateLimiter.totalBytesWritten),\n+                                     bytesToMB(rateLimiter.getTotalBytesWritten()),\n                                      nsToSec(now - mergeStartNS),\n-                                     nsToSec(merge.rateLimiter.getTotalStoppedNS()),\n-                                     nsToSec(merge.rateLimiter.getTotalPausedNS()),\n-                                     rateToString(merge.rateLimiter.getMBPerSec())));\n+                                     nsToSec(rateLimiter.getTotalStoppedNS()),\n+                                     nsToSec(rateLimiter.getTotalPausedNS()),\n+                                     rateToString(rateLimiter.getMBPerSec())));\n \n         if (newMBPerSec !\u003d curMBPerSec) {\n           if (newMBPerSec \u003d\u003d 0.0) {\n             message.append(\"  now stop\");\n           } else if (curMBPerSec \u003d\u003d 0.0) {\n             if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n               message.append(\"  now resume\");\n             } else {\n               message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n             }\n           } else {\n             message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n           }\n         } else if (curMBPerSec \u003d\u003d 0.0) {\n           message.append(\"  leave stopped\");\n         } else {\n           message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n         }\n       }\n \n-      merge.rateLimiter.setMBPerSec(newMBPerSec);\n+      rateLimiter.setMBPerSec(newMBPerSec);\n     }\n     if (verbose()) {\n       message(message.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "41fcc722ff07393586f7758d8a733c7e2e59bebc": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-6119: CMS dynamically rate limits IO writes of each merge depending on incoming merge rate\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1649532 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015-01-05, 9:28 a.m.",
      "commitName": "41fcc722ff07393586f7758d8a733c7e2e59bebc",
      "commitAuthor": "Michael McCandless",
      "commitDateOld": "2014-12-22, 5:10 a.m.",
      "commitNameOld": "ddc5c0c6b206e985f78f4479663583d1b64e61ac",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 14.18,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive \u0026 not in the\n    // process of stopping (ie have an active merge):\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      activeMerges.add(mergeThread);\n      threadIdx++;\n    }\n\n    // Sort the merge threads, largest first:\n    CollectionUtil.timSort(activeMerges);\n\n    final int activeMergeCount \u003d activeMerges.size();\n\n    int bigMergeCount \u003d 0;\n\n    for (threadIdx\u003dactiveMergeCount-1;threadIdx\u003e\u003d0;threadIdx--) {\n      MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n      if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB*1024*1024) {\n        bigMergeCount \u003d 1+threadIdx;\n        break;\n      }\n    }\n\n    long now \u003d System.nanoTime();\n\n    StringBuilder message;\n    if (verbose()) {\n      message \u003d new StringBuilder();\n      message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n      message \u003d null;\n    }\n\n    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n      MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n\n      OneMerge merge \u003d mergeThread.merge;\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n\n      double newMBPerSec;\n      if (doPause) {\n        newMBPerSec \u003d 0.0;\n      } else if (merge.maxNumSegments !\u003d -1) {\n        newMBPerSec \u003d forceMergeMBPerSec;\n      } else if (doAutoIOThrottle \u003d\u003d false) {\n        newMBPerSec \u003d Double.POSITIVE_INFINITY;\n      } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB*1024*1024) {\n        // Don\u0027t rate limit small merges:\n        newMBPerSec \u003d Double.POSITIVE_INFINITY;\n      } else {\n        newMBPerSec \u003d targetMBPerSec;\n      }\n\n      double curMBPerSec \u003d merge.rateLimiter.getMBPerSec();\n      \n      if (verbose()) {\n        long mergeStartNS \u003d merge.mergeStartNS;\n        if (mergeStartNS \u003d\u003d -1) {\n          // IndexWriter didn\u0027t start the merge yet:\n          mergeStartNS \u003d now;\n        }\n        message.append(\u0027\\n\u0027);\n        message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\",\n                                     mergeThread.getName(),\n                                     bytesToMB(merge.estimatedMergeBytes),\n                                     bytesToMB(merge.rateLimiter.totalBytesWritten),\n                                     nsToSec(now - mergeStartNS),\n                                     nsToSec(merge.rateLimiter.getTotalStoppedNS()),\n                                     nsToSec(merge.rateLimiter.getTotalPausedNS()),\n                                     rateToString(merge.rateLimiter.getMBPerSec())));\n\n        if (newMBPerSec !\u003d curMBPerSec) {\n          if (newMBPerSec \u003d\u003d 0.0) {\n            message.append(\"  now stop\");\n          } else if (curMBPerSec \u003d\u003d 0.0) {\n            if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n              message.append(\"  now resume\");\n            } else {\n              message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n            }\n          } else {\n            message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n          }\n        } else if (curMBPerSec \u003d\u003d 0.0) {\n          message.append(\"  leave stopped\");\n        } else {\n          message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n        }\n      }\n\n      merge.rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n      message(message.toString());\n    }\n  }",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 226,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,57 +1,108 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive \u0026 not in the\n     // process of stopping (ie have an active merge):\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n \n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n       final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n-      if (mergeThread.getCurrentMerge() !\u003d null) {\n-        activeMerges.add(mergeThread);\n-      }\n+      activeMerges.add(mergeThread);\n       threadIdx++;\n     }\n \n-    // Sort the merge threads in descending order.\n-    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n-    \n-    int pri \u003d mergeThreadPriority;\n+    // Sort the merge threads, largest first:\n+    CollectionUtil.timSort(activeMerges);\n+\n     final int activeMergeCount \u003d activeMerges.size();\n-    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n-      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n-      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n-      if (merge \u003d\u003d null) { \n-        continue;\n+\n+    int bigMergeCount \u003d 0;\n+\n+    for (threadIdx\u003dactiveMergeCount-1;threadIdx\u003e\u003d0;threadIdx--) {\n+      MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+      if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB*1024*1024) {\n+        bigMergeCount \u003d 1+threadIdx;\n+        break;\n       }\n+    }\n+\n+    long now \u003d System.nanoTime();\n+\n+    StringBuilder message;\n+    if (verbose()) {\n+      message \u003d new StringBuilder();\n+      message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n+    } else {\n+      message \u003d null;\n+    }\n+\n+    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n+      MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+\n+      OneMerge merge \u003d mergeThread.merge;\n \n       // pause the thread if maxThreadCount is smaller than the number of merge threads.\n-      final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n+      final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n \n+      double newMBPerSec;\n+      if (doPause) {\n+        newMBPerSec \u003d 0.0;\n+      } else if (merge.maxNumSegments !\u003d -1) {\n+        newMBPerSec \u003d forceMergeMBPerSec;\n+      } else if (doAutoIOThrottle \u003d\u003d false) {\n+        newMBPerSec \u003d Double.POSITIVE_INFINITY;\n+      } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB*1024*1024) {\n+        // Don\u0027t rate limit small merges:\n+        newMBPerSec \u003d Double.POSITIVE_INFINITY;\n+      } else {\n+        newMBPerSec \u003d targetMBPerSec;\n+      }\n+\n+      double curMBPerSec \u003d merge.rateLimiter.getMBPerSec();\n+      \n       if (verbose()) {\n-        if (doPause !\u003d merge.getPause()) {\n-          if (doPause) {\n-            message(\"pause thread \" + mergeThread.getName());\n-          } else {\n-            message(\"unpause thread \" + mergeThread.getName());\n-          }\n+        long mergeStartNS \u003d merge.mergeStartNS;\n+        if (mergeStartNS \u003d\u003d -1) {\n+          // IndexWriter didn\u0027t start the merge yet:\n+          mergeStartNS \u003d now;\n         }\n-      }\n-      if (doPause !\u003d merge.getPause()) {\n-        merge.setPause(doPause);\n+        message.append(\u0027\\n\u0027);\n+        message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\",\n+                                     mergeThread.getName(),\n+                                     bytesToMB(merge.estimatedMergeBytes),\n+                                     bytesToMB(merge.rateLimiter.totalBytesWritten),\n+                                     nsToSec(now - mergeStartNS),\n+                                     nsToSec(merge.rateLimiter.getTotalStoppedNS()),\n+                                     nsToSec(merge.rateLimiter.getTotalPausedNS()),\n+                                     rateToString(merge.rateLimiter.getMBPerSec())));\n+\n+        if (newMBPerSec !\u003d curMBPerSec) {\n+          if (newMBPerSec \u003d\u003d 0.0) {\n+            message.append(\"  now stop\");\n+          } else if (curMBPerSec \u003d\u003d 0.0) {\n+            if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n+              message.append(\"  now resume\");\n+            } else {\n+              message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n+            }\n+          } else {\n+            message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n+          }\n+        } else if (curMBPerSec \u003d\u003d 0.0) {\n+          message.append(\"  leave stopped\");\n+        } else {\n+          message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n+        }\n       }\n \n-      if (!doPause) {\n-        if (verbose()) {\n-          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n-        }\n-        mergeThread.setThreadPriority(pri);\n-        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n-      }\n+      merge.rateLimiter.setMBPerSec(newMBPerSec);\n+    }\n+    if (verbose()) {\n+      message(message.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b67b17493216f6b0c81a981073fd5f61eace6f4": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-5512: remove redundant typing (diamond operator) in trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1576755 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-03-12, 10:39 a.m.",
      "commitName": "3b67b17493216f6b0c81a981073fd5f61eace6f4",
      "commitAuthor": "Robert Muir",
      "commitDateOld": "2014-03-11, 3:11 p.m.",
      "commitNameOld": "7efebfa50ac667fa1714c9fc43c3d6bc113fdd34",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive \u0026 not in the\n    // process of stopping (ie have an active merge):\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() !\u003d null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    \n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 170,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,57 +1,57 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive \u0026 not in the\n     // process of stopping (ie have an active merge):\n-    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n+    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n \n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n       final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n       if (mergeThread.getCurrentMerge() !\u003d null) {\n         activeMerges.add(mergeThread);\n       }\n       threadIdx++;\n     }\n \n     // Sort the merge threads in descending order.\n     CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n     \n     int pri \u003d mergeThreadPriority;\n     final int activeMergeCount \u003d activeMerges.size();\n     for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n       final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n       final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n       if (merge \u003d\u003d null) { \n         continue;\n       }\n \n       // pause the thread if maxThreadCount is smaller than the number of merge threads.\n       final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n \n       if (verbose()) {\n         if (doPause !\u003d merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause !\u003d merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b895ebde4340ed8ae903c7ae51750da3d9837394": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-4946: Refactor SorterTemplate (now Sorter).\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1478785 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-05-03, 9:37 a.m.",
      "commitName": "b895ebde4340ed8ae903c7ae51750da3d9837394",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": "2013-03-29, 5:56 p.m.",
      "commitNameOld": "1f964c57642e4a686b4812241eae67e0dc83ce06",
      "commitAuthorOld": "Adrien Grand",
      "daysBetweenCommits": 34.65,
      "commitsBetweenForRepo": 231,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive \u0026 not in the\n    // process of stopping (ie have an active merge):\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() !\u003d null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    \n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 166,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,57 +1,57 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive \u0026 not in the\n     // process of stopping (ie have an active merge):\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n \n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n       final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n       if (mergeThread.getCurrentMerge() !\u003d null) {\n         activeMerges.add(mergeThread);\n       }\n       threadIdx++;\n     }\n \n     // Sort the merge threads in descending order.\n-    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n     \n     int pri \u003d mergeThreadPriority;\n     final int activeMergeCount \u003d activeMerges.size();\n     for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n       final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n       final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n       if (merge \u003d\u003d null) { \n         continue;\n       }\n \n       // pause the thread if maxThreadCount is smaller than the number of merge threads.\n       final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n \n       if (verbose()) {\n         if (doPause !\u003d merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause !\u003d merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c": {
      "type": "Yfilerename",
      "commitMessage": "LUCENE-3753: Restructure the Lucene build system\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1241588 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012-02-07, 2:59 p.m.",
      "commitName": "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c",
      "commitAuthor": "Steven Rowe",
      "commitDateOld": "2012-02-07, 1:58 p.m.",
      "commitNameOld": "8b939cb7d20160f9f8a7baf2030613f0e1e877b4",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive \u0026 not in the\n    // process of stopping (ie have an active merge):\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() !\u003d null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    \n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 151,
      "functionName": "updateMergeThreads",
      "diff": "",
      "extendedDetails": {
        "oldPath": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
        "newPath": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java"
      }
    },
    "9906198ff3d65f8c9b7e99462aab19feb5334790": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2755: documentation updates, formatting and tiny mods to CMS (trunk)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1059905 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-01-17, 7:49 a.m.",
      "commitName": "9906198ff3d65f8c9b7e99462aab19feb5334790",
      "commitAuthor": "Shai Erera",
      "commitDateOld": "2010-12-20, 5:35 a.m.",
      "commitNameOld": "765eab4008f44bb655b3dbbe4cc625455711536b",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 28.09,
      "commitsBetweenForRepo": 179,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive \u0026 not in the\n    // process of stopping (ie have an active merge):\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() !\u003d null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    // Sort the merge threads in descending order.\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    \n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) { \n        continue;\n      }\n\n      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n      final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 151,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,60 +1,57 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive \u0026 not in the\n     // process of stopping (ie have an active merge):\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n \n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n       final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n       if (mergeThread.getCurrentMerge() !\u003d null) {\n         activeMerges.add(mergeThread);\n       }\n       threadIdx++;\n     }\n \n+    // Sort the merge threads in descending order.\n     CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n     \n     int pri \u003d mergeThreadPriority;\n     final int activeMergeCount \u003d activeMerges.size();\n     for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n       final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n       final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n       if (merge \u003d\u003d null) { \n         continue;\n       }\n \n-      final boolean doPause;\n-      if (threadIdx \u003c activeMergeCount-maxThreadCount) {\n-        doPause \u003d true;\n-      } else {\n-        doPause \u003d false;\n-      }\n+      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n+      final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n \n       if (verbose()) {\n         if (doPause !\u003d merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause !\u003d merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "765eab4008f44bb655b3dbbe4cc625455711536b": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2820: fix CMS to stop its threads without deadlocking!\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1051041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-12-20, 5:35 a.m.",
      "commitName": "765eab4008f44bb655b3dbbe4cc625455711536b",
      "commitAuthor": "Michael McCandless",
      "commitDateOld": "2010-12-19, 12:07 p.m.",
      "commitNameOld": "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive \u0026 not in the\n    // process of stopping (ie have an active merge):\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() !\u003d null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    \n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) { \n        continue;\n      }\n\n      final boolean doPause;\n      if (threadIdx \u003c activeMergeCount-maxThreadCount) {\n        doPause \u003d true;\n      } else {\n        doPause \u003d false;\n      }\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 147,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,41 +1,60 @@\n   protected synchronized void updateMergeThreads() {\n \n-    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n-    \n-    final int count \u003d mergeThreads.size();\n-    int pri \u003d mergeThreadPriority;\n-    for(int i\u003d0;i\u003ccount;i++) {\n-      final MergeThread mergeThread \u003d mergeThreads.get(i);\n-      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n-      if (merge \u003d\u003d null) {\n+    // Only look at threads that are alive \u0026 not in the\n+    // process of stopping (ie have an active merge):\n+    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n+\n+    int threadIdx \u003d 0;\n+    while (threadIdx \u003c mergeThreads.size()) {\n+      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n+      if (!mergeThread.isAlive()) {\n+        // Prune any dead threads\n+        mergeThreads.remove(threadIdx);\n         continue;\n       }\n+      if (mergeThread.getCurrentMerge() !\u003d null) {\n+        activeMerges.add(mergeThread);\n+      }\n+      threadIdx++;\n+    }\n+\n+    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    \n+    int pri \u003d mergeThreadPriority;\n+    final int activeMergeCount \u003d activeMerges.size();\n+    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n+      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n+      if (merge \u003d\u003d null) { \n+        continue;\n+      }\n+\n       final boolean doPause;\n-      if (i \u003c count-maxThreadCount) {\n+      if (threadIdx \u003c activeMergeCount-maxThreadCount) {\n         doPause \u003d true;\n       } else {\n         doPause \u003d false;\n       }\n \n       if (verbose()) {\n         if (doPause !\u003d merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause !\u003d merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "65b27c2adb9000b64ccd9d3a3b1a5030550b06da": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2820: revert until I find the cause of the deadlock\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1050899 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-12-19, 12:07 p.m.",
      "commitName": "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
      "commitAuthor": "Michael McCandless",
      "commitDateOld": "2010-12-19, 8:57 a.m.",
      "commitNameOld": "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n    \n    final int count \u003d mergeThreads.size();\n    int pri \u003d mergeThreadPriority;\n    for(int i\u003d0;i\u003ccount;i++) {\n      final MergeThread mergeThread \u003d mergeThreads.get(i);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) {\n        continue;\n      }\n      final boolean doPause;\n      if (i \u003c count-maxThreadCount) {\n        doPause \u003d true;\n      } else {\n        doPause \u003d false;\n      }\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 148,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,60 +1,41 @@\n   protected synchronized void updateMergeThreads() {\n \n-    // Only look at threads that are alive \u0026 not in the\n-    // process of stopping (ie have an active merge):\n-    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n-\n-    int threadIdx \u003d 0;\n-    while (threadIdx \u003c mergeThreads.size()) {\n-      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n-      if (!mergeThread.isAlive()) {\n-        // Prune any dead threads\n-        mergeThreads.remove(threadIdx);\n-        continue;\n-      }\n-      if (mergeThread.getCurrentMerge() !\u003d null) {\n-        activeMerges.add(mergeThread);\n-      }\n-      threadIdx++;\n-    }\n-\n-    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n     \n+    final int count \u003d mergeThreads.size();\n     int pri \u003d mergeThreadPriority;\n-    final int activeMergeCount \u003d activeMerges.size();\n-    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n-      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+    for(int i\u003d0;i\u003ccount;i++) {\n+      final MergeThread mergeThread \u003d mergeThreads.get(i);\n       final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n-      if (merge \u003d\u003d null) { \n+      if (merge \u003d\u003d null) {\n         continue;\n       }\n-\n       final boolean doPause;\n-      if (threadIdx \u003c activeMergeCount-maxThreadCount) {\n+      if (i \u003c count-maxThreadCount) {\n         doPause \u003d true;\n       } else {\n         doPause \u003d false;\n       }\n \n       if (verbose()) {\n         if (doPause !\u003d merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause !\u003d merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2820: fix CMS to stop all threads during close\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1050853 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-12-19, 8:57 a.m.",
      "commitName": "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
      "commitAuthor": "Michael McCandless",
      "commitDateOld": "2010-12-18, 2:14 p.m.",
      "commitNameOld": "623fd7bcd7470d5d5330d721ea89269ce93c02e5",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    // Only look at threads that are alive \u0026 not in the\n    // process of stopping (ie have an active merge):\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n      if (!mergeThread.isAlive()) {\n        // Prune any dead threads\n        mergeThreads.remove(threadIdx);\n        continue;\n      }\n      if (mergeThread.getCurrentMerge() !\u003d null) {\n        activeMerges.add(mergeThread);\n      }\n      threadIdx++;\n    }\n\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    \n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) { \n        continue;\n      }\n\n      final boolean doPause;\n      if (threadIdx \u003c activeMergeCount-maxThreadCount) {\n        doPause \u003d true;\n      } else {\n        doPause \u003d false;\n      }\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 147,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,41 +1,60 @@\n   protected synchronized void updateMergeThreads() {\n \n-    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n-    \n-    final int count \u003d mergeThreads.size();\n-    int pri \u003d mergeThreadPriority;\n-    for(int i\u003d0;i\u003ccount;i++) {\n-      final MergeThread mergeThread \u003d mergeThreads.get(i);\n-      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n-      if (merge \u003d\u003d null) {\n+    // Only look at threads that are alive \u0026 not in the\n+    // process of stopping (ie have an active merge):\n+    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n+\n+    int threadIdx \u003d 0;\n+    while (threadIdx \u003c mergeThreads.size()) {\n+      final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n+      if (!mergeThread.isAlive()) {\n+        // Prune any dead threads\n+        mergeThreads.remove(threadIdx);\n         continue;\n       }\n+      if (mergeThread.getCurrentMerge() !\u003d null) {\n+        activeMerges.add(mergeThread);\n+      }\n+      threadIdx++;\n+    }\n+\n+    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    \n+    int pri \u003d mergeThreadPriority;\n+    final int activeMergeCount \u003d activeMerges.size();\n+    for (threadIdx\u003d0;threadIdx\u003cactiveMergeCount;threadIdx++) {\n+      final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n+      if (merge \u003d\u003d null) { \n+        continue;\n+      }\n+\n       final boolean doPause;\n-      if (i \u003c count-maxThreadCount) {\n+      if (threadIdx \u003c activeMergeCount-maxThreadCount) {\n         doPause \u003d true;\n       } else {\n         doPause \u003d false;\n       }\n \n       if (verbose()) {\n         if (doPause !\u003d merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause !\u003d merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "717c67ab7c2df6901f056ae2a1b5cd8317166b93": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2719: Readded utility class org.apche.lucene.util.SorterTemplate with support for faster quickSort using pivot values and also merge sort and insertion sort. This removes code duplication and slow Collections/Arrays.sort usage.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1027998 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-10-27, 11:16 a.m.",
      "commitName": "717c67ab7c2df6901f056ae2a1b5cd8317166b93",
      "commitAuthor": "Uwe Schindler",
      "commitDateOld": "2010-06-11, 5:51 a.m.",
      "commitNameOld": "7fe6c0fb24051748ae3ccb1b5933244deb9570bf",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 138.23,
      "commitsBetweenForRepo": 765,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n    \n    final int count \u003d mergeThreads.size();\n    int pri \u003d mergeThreadPriority;\n    for(int i\u003d0;i\u003ccount;i++) {\n      final MergeThread mergeThread \u003d mergeThreads.get(i);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) {\n        continue;\n      }\n      final boolean doPause;\n      if (i \u003c count-maxThreadCount) {\n        doPause \u003d true;\n      } else {\n        doPause \u003d false;\n      }\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 155,
      "functionName": "updateMergeThreads",
      "diff": "@@ -1,41 +1,41 @@\n   protected synchronized void updateMergeThreads() {\n \n-    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n+    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n     \n     final int count \u003d mergeThreads.size();\n     int pri \u003d mergeThreadPriority;\n     for(int i\u003d0;i\u003ccount;i++) {\n       final MergeThread mergeThread \u003d mergeThreads.get(i);\n       final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n       if (merge \u003d\u003d null) {\n         continue;\n       }\n       final boolean doPause;\n       if (i \u003c count-maxThreadCount) {\n         doPause \u003d true;\n       } else {\n         doPause \u003d false;\n       }\n \n       if (verbose()) {\n         if (doPause !\u003d merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause !\u003d merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec": {
      "type": "Yfilerename",
      "commitMessage": "SVN-GIT conversion, path copy emulation.\n",
      "commitDate": "2016-01-22, 7:18 p.m.",
      "commitName": "778d96752fa94636a2136ea2b4d58a3fcbe283ec",
      "commitAuthor": "Dawid Weiss",
      "commitDateOld": "2010-03-17, 10:57 a.m.",
      "commitNameOld": "2e5c6cdadc820220f8cb86e1b6e215da941649f9",
      "commitAuthorOld": "Uwe Schindler",
      "daysBetweenCommits": 2137.39,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n    \n    final int count \u003d mergeThreads.size();\n    int pri \u003d mergeThreadPriority;\n    for(int i\u003d0;i\u003ccount;i++) {\n      final MergeThread mergeThread \u003d mergeThreads.get(i);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) {\n        continue;\n      }\n      final boolean doPause;\n      if (i \u003c count-maxThreadCount) {\n        doPause \u003d true;\n      } else {\n        doPause \u003d false;\n      }\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 155,
      "functionName": "updateMergeThreads",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
        "newPath": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java"
      }
    },
    "7d35aafe71661e51ee01639ddf88503184610329": {
      "type": "Yintroduced",
      "commitMessage": "LUCENE-2164: make CMS smarter about prioritizing its threads\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@892992 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-21, 4:38 p.m.",
      "commitName": "7d35aafe71661e51ee01639ddf88503184610329",
      "commitAuthor": "Michael McCandless",
      "diff": "@@ -0,0 +1,41 @@\n+  protected synchronized void updateMergeThreads() {\n+\n+    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n+    \n+    final int count \u003d mergeThreads.size();\n+    int pri \u003d mergeThreadPriority;\n+    for(int i\u003d0;i\u003ccount;i++) {\n+      final MergeThread mergeThread \u003d mergeThreads.get(i);\n+      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n+      if (merge \u003d\u003d null) {\n+        continue;\n+      }\n+      final boolean doPause;\n+      if (i \u003c count-maxThreadCount) {\n+        doPause \u003d true;\n+      } else {\n+        doPause \u003d false;\n+      }\n+\n+      if (verbose()) {\n+        if (doPause !\u003d merge.getPause()) {\n+          if (doPause) {\n+            message(\"pause thread \" + mergeThread.getName());\n+          } else {\n+            message(\"unpause thread \" + mergeThread.getName());\n+          }\n+        }\n+      }\n+      if (doPause !\u003d merge.getPause()) {\n+        merge.setPause(doPause);\n+      }\n+\n+      if (!doPause) {\n+        if (verbose()) {\n+          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n+        }\n+        mergeThread.setThreadPriority(pri);\n+        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void updateMergeThreads() {\n\n    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n    \n    final int count \u003d mergeThreads.size();\n    int pri \u003d mergeThreadPriority;\n    for(int i\u003d0;i\u003ccount;i++) {\n      final MergeThread mergeThread \u003d mergeThreads.get(i);\n      final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n      if (merge \u003d\u003d null) {\n        continue;\n      }\n      final boolean doPause;\n      if (i \u003c count-maxThreadCount) {\n        doPause \u003d true;\n      } else {\n        doPause \u003d false;\n      }\n\n      if (verbose()) {\n        if (doPause !\u003d merge.getPause()) {\n          if (doPause) {\n            message(\"pause thread \" + mergeThread.getName());\n          } else {\n            message(\"unpause thread \" + mergeThread.getName());\n          }\n        }\n      }\n      if (doPause !\u003d merge.getPause()) {\n        merge.setPause(doPause);\n      }\n\n      if (!doPause) {\n        if (verbose()) {\n          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n        }\n        mergeThread.setThreadPriority(pri);\n        pri \u003d Math.min(Thread.MAX_PRIORITY, 1+pri);\n      }\n    }\n  }",
      "path": "src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 155,
      "functionName": "updateMergeThreads"
    }
  }
}