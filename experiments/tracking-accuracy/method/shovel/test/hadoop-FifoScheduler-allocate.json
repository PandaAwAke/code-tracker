{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "H:\\Projects\\apache\\hadoop/.git",
  "startCommitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
  "sourceFileName": "FifoScheduler.java",
  "functionName": "allocate",
  "functionId": "allocate___applicationAttemptId-ApplicationAttemptId__ask-List__ResourceRequest____schedulingRequests-List__SchedulingRequest____release-List__ContainerId____blacklistAdditions-List__String____blacklistRemovals-List__String____updateRequests-ContainerUpdates",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
  "functionStartLine": 323,
  "functionEndLine": 387,
  "numCommitsSeen": 477,
  "timeTaken": 21970,
  "changeHistory": [
    "38af23796971193fa529c3d08ffde8fcd6e607b6",
    "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
    "1bbd023275db535ab80fcb60e022151e9679d468",
    "25f9872be63423ada6a18481eaad2888e731fdac",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661",
    "620325e81696fca140195b74929ed9eda2d5eb16",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434",
    "81df7b586a16f8226c7b01c139c1c70c060399c3",
    "658097d6da1b1aac8e01db459f0c3b456e99652f",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
    "f6a778c3725bcdaba1e1de43786af17dd44deb78",
    "5fd5c9900cfd299428acbc8dff767273e44647c0",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "0a6e275ee3360719290ad666629624450d4f0a6f",
    "8eb3be63f598daae01f0a0c09eab5086881f153d",
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
    "bc6777dd5bdcbaef09897b506bc6511ae456033d",
    "01aabf73639785a29d1651f2e268cec04a8b9b94",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "23e336a0ed314ac7f1b47649d1a688e8de6b6e94",
    "80cc8e94861e2b0fc423b77fa8ce0f174c3a91fd",
    "e549ac93694f768f2e26706a54a1b45dea6d2844",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
    "cdfabf5ae289836968b3d296668593b9500b6f26",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Ymultichange(Yparameterchange,Ybodychange)",
    "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b": "Ybodychange",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": "Yparameterchange",
    "1bbd023275db535ab80fcb60e022151e9679d468": "Ybodychange",
    "25f9872be63423ada6a18481eaad2888e731fdac": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Ybodychange",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": "Yparameterchange",
    "620325e81696fca140195b74929ed9eda2d5eb16": "Ybodychange",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": "Ybodychange",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": "Ybodychange",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": "Ymultichange(Yparameterchange,Ybodychange)",
    "81df7b586a16f8226c7b01c139c1c70c060399c3": "Ybodychange",
    "658097d6da1b1aac8e01db459f0c3b456e99652f": "Ybodychange",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": "Ybodychange",
    "f6a778c3725bcdaba1e1de43786af17dd44deb78": "Ybodychange",
    "5fd5c9900cfd299428acbc8dff767273e44647c0": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ybodychange",
    "0a6e275ee3360719290ad666629624450d4f0a6f": "Ybodychange",
    "8eb3be63f598daae01f0a0c09eab5086881f153d": "Ybodychange",
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f": "Ymultichange(Yparameterchange,Ybodychange)",
    "bc6777dd5bdcbaef09897b506bc6511ae456033d": "Ybodychange",
    "01aabf73639785a29d1651f2e268cec04a8b9b94": "Ybodychange",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "23e336a0ed314ac7f1b47649d1a688e8de6b6e94": "Ybodychange",
    "80cc8e94861e2b0fc423b77fa8ce0f174c3a91fd": "Ybodychange",
    "e549ac93694f768f2e26706a54a1b45dea6d2844": "Ybodychange",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": "Ybodychange",
    "cdfabf5ae289836968b3d296668593b9500b6f26": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "2018-01-31, 4:30 a.m.",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
          "commitDate": "2018-01-31, 4:30 a.m.",
          "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "2018-01-09, 7:59 p.m.",
          "commitNameOld": "55066cc53dc22b68f9ca55a0029741d6c846be0a",
          "commitAuthorOld": "Miklos Szegedi",
          "daysBetweenCommits": 21.35,
          "commitsBetweenForRepo": 132,
          "commitsBetweenForFile": 1,
          "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n    FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          applicationAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeResourceRequests(ask);\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
          "functionStartLine": 323,
          "functionName": "allocate",
          "diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n-      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n-      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n+      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n+      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       ContainerUpdates updateRequests) {\n     FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           applicationAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    normalizeRequests(ask);\n+    normalizeResourceRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, updateRequests-ContainerUpdates]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, schedulingRequests-List\u003cSchedulingRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, updateRequests-ContainerUpdates]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
          "commitDate": "2018-01-31, 4:30 a.m.",
          "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "2018-01-09, 7:59 p.m.",
          "commitNameOld": "55066cc53dc22b68f9ca55a0029741d6c846be0a",
          "commitAuthorOld": "Miklos Szegedi",
          "daysBetweenCommits": 21.35,
          "commitsBetweenForRepo": 132,
          "commitsBetweenForFile": 1,
          "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n    FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          applicationAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeResourceRequests(ask);\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
          "functionStartLine": 323,
          "functionName": "allocate",
          "diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n-      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n-      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n+      List\u003cResourceRequest\u003e ask, List\u003cSchedulingRequest\u003e schedulingRequests,\n+      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       ContainerUpdates updateRequests) {\n     FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           applicationAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt\u0027s AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    normalizeRequests(ask);\n+    normalizeResourceRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6959. RM may allocate wrong AM Container for new attempt. Contributed by Yuqi Wang\n",
      "commitDate": "2017-08-14, 1:51 p.m.",
      "commitName": "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b",
      "commitAuthor": "Jian He",
      "commitDateOld": "2017-02-28, 1:35 p.m.",
      "commitNameOld": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 166.97,
      "commitsBetweenForRepo": 959,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n    FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed or non existent application \" +\n          applicationAttemptId.getApplicationId());\n      return EMPTY_ALLOCATION;\n    }\n\n    // The allocate may be the leftover from previous attempt, and it will\n    // impact current attempt, such as confuse the request and allocation for\n    // current attempt\u0027s AM container.\n    // Note outside precondition check for the attempt id may be\n    // outdated here, so double check it here is necessary.\n    if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n      LOG.error(\"Calling allocate on previous or removed \" +\n          \"or non existent application attempt \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 326,
      "functionName": "allocate",
      "diff": "@@ -1,54 +1,65 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       ContainerUpdates updateRequests) {\n     FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n-      LOG.error(\"Calling allocate on removed \" +\n-          \"or non-existent application \" + applicationAttemptId);\n+      LOG.error(\"Calling allocate on removed or non existent application \" +\n+          applicationAttemptId.getApplicationId());\n+      return EMPTY_ALLOCATION;\n+    }\n+\n+    // The allocate may be the leftover from previous attempt, and it will\n+    // impact current attempt, such as confuse the request and allocation for\n+    // current attempt\u0027s AM container.\n+    // Note outside precondition check for the attempt id may be\n+    // outdated here, so double check it here is necessary.\n+    if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n+      LOG.error(\"Calling allocate on previous or removed \" +\n+          \"or non existent application attempt \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
      "commitDate": "2017-01-05, 1:31 p.m.",
      "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "2017-01-03, 5:53 p.m.",
      "commitNameOld": "f69a107aeccc68ca1085a7be8093d36b2f45eaa1",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 1.82,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      ContainerUpdates updateRequests) {\n    FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non-existent application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 326,
      "functionName": "allocate",
      "diff": "@@ -1,55 +1,54 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n-      List\u003cUpdateContainerRequest\u003e increaseRequests,\n-      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n+      ContainerUpdates updateRequests) {\n     FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non-existent application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, increaseRequests-List\u003cUpdateContainerRequest\u003e, decreaseRequests-List\u003cUpdateContainerRequest\u003e]",
        "newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, updateRequests-ContainerUpdates]"
      }
    },
    "1bbd023275db535ab80fcb60e022151e9679d468": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5962. Spelling errors in logging and exceptions for resource manager code (gsohn via rkanter)\n",
      "commitDate": "2016-12-27, 4:35 p.m.",
      "commitName": "1bbd023275db535ab80fcb60e022151e9679d468",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "2016-12-27, 3:40 p.m.",
      "commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cUpdateContainerRequest\u003e increaseRequests,\n      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n    FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non-existent application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 325,
      "functionName": "allocate",
      "diff": "@@ -1,55 +1,55 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cUpdateContainerRequest\u003e increaseRequests,\n       List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n     FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n-          \"or non existant application \" + applicationAttemptId);\n+          \"or non-existent application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25f9872be63423ada6a18481eaad2888e731fdac": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5774. MR Job stuck in ACCEPTED status without any progress in Fair Scheduler\nif set yarn.scheduler.minimum-allocation-mb to 0. (Contributed by Yufei Gu via Daniel Templeton)\n",
      "commitDate": "2016-11-29, 12:40 p.m.",
      "commitName": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "2016-11-07, 1:14 p.m.",
      "commitNameOld": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 21.98,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cUpdateContainerRequest\u003e increaseRequests,\n      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n    FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 325,
      "functionName": "allocate",
      "diff": "@@ -1,57 +1,55 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cUpdateContainerRequest\u003e increaseRequests,\n       List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n     FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n-        getClusterResource(), minimumAllocation,\n-        getMaximumResourceCapability());\n+    normalizeRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "2016-11-07, 1:14 p.m.",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "commitDateOld": "2016-10-21, 12:17 a.m.",
      "commitNameOld": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 17.58,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cUpdateContainerRequest\u003e increaseRequests,\n      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n    FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        getClusterResource(), minimumAllocation,\n        getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 325,
      "functionName": "allocate",
      "diff": "@@ -1,57 +1,57 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cUpdateContainerRequest\u003e increaseRequests,\n       List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n-    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n+    FifoAppAttempt application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         getClusterResource(), minimumAllocation,\n         getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-5221. Expose UpdateResourceRequest API to allow AM to request for change in container properties. (asuresh)\n",
      "commitDate": "2016-08-30, 6:52 p.m.",
      "commitName": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "2016-08-05, 1:43 p.m.",
      "commitNameOld": "3f100d76ff5df020dbb8ecd4f5b4f9736a0a8270",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 25.21,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cUpdateContainerRequest\u003e increaseRequests,\n      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        getClusterResource(), minimumAllocation,\n        getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 330,
      "functionName": "allocate",
      "diff": "@@ -1,57 +1,57 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n-      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n-      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n+      List\u003cUpdateContainerRequest\u003e increaseRequests,\n+      List\u003cUpdateContainerRequest\u003e decreaseRequests) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         getClusterResource(), minimumAllocation,\n         getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, increaseRequests-List\u003cContainerResourceChangeRequest\u003e, decreaseRequests-List\u003cContainerResourceChangeRequest\u003e]",
        "newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, increaseRequests-List\u003cUpdateContainerRequest\u003e, decreaseRequests-List\u003cUpdateContainerRequest\u003e]"
      }
    },
    "620325e81696fca140195b74929ed9eda2d5eb16": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4837. User facing aspects of \u0027AM blacklisting\u0027 feature need fixing. (vinodkv via wangda)\n",
      "commitDate": "2016-06-07, 6:06 p.m.",
      "commitName": "620325e81696fca140195b74929ed9eda2d5eb16",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "2016-05-29, 11:54 a.m.",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 9.26,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        getClusterResource(), minimumAllocation,\n        getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 329,
      "functionName": "allocate",
      "diff": "@@ -1,63 +1,57 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n       List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         getClusterResource(), minimumAllocation,\n         getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n-      if (application.isWaitingForAMContainer()) {\n-        // Allocate is for AM and update AM blacklist for this\n-        application.updateAMBlacklist(\n-            blacklistAdditions, blacklistRemovals);\n-      } else {\n-        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n-      }\n+      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4719. Add a helper library to maintain node state and allows common queries. (kasha)\n",
      "commitDate": "2016-03-14, 5:19 p.m.",
      "commitName": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "2016-02-28, 12:35 p.m.",
      "commitNameOld": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 15.15,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        getClusterResource(), minimumAllocation,\n        getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      if (application.isWaitingForAMContainer()) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 317,
      "functionName": "allocate",
      "diff": "@@ -1,62 +1,63 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n       List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n-        clusterResource, minimumAllocation, getMaximumResourceCapability());\n+        getClusterResource(), minimumAllocation,\n+        getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       if (application.isWaitingForAMContainer()) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3946. Update exact reason as to why a submitted app is in ACCEPTED state to app\u0027s diagnostic message. (Naganarasimha G R via wangda)\n",
      "commitDate": "2015-12-14, 1:52 p.m.",
      "commitName": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "2015-11-24, 3:17 a.m.",
      "commitNameOld": "52948bb20bd1446164df1d3920c46c96dad750ae",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 20.44,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      if (application.isWaitingForAMContainer()) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 314,
      "functionName": "allocate",
      "diff": "@@ -1,62 +1,62 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n       List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n       List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n       List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n-      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n+      if (application.isWaitingForAMContainer()) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
      "commitDate": "2015-09-23, 4:29 p.m.",
      "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
          "commitDate": "2015-09-23, 4:29 p.m.",
          "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
          "commitAuthor": "Jian He",
          "commitDateOld": "2015-09-13, 8:03 p.m.",
          "commitNameOld": "81df7b586a16f8226c7b01c139c1c70c060399c3",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 9.85,
          "commitsBetweenForRepo": 74,
          "commitsBetweenForFile": 1,
          "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
          "functionStartLine": 314,
          "functionName": "allocate",
          "diff": "@@ -1,62 +1,62 @@\n-  public Allocation allocate(\n-      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n-      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n+  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n+      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n+      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n+      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n+      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       if (application.isWaitingForAMContainer(application.getApplicationId())) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n-      ContainersAndNMTokensAllocation allocation \u003d\n-          application.pullNewlyAllocatedContainersAndNMTokens();\n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n-      return new Allocation(allocation.getContainerList(), headroom, null,\n-          null, null, allocation.getNMTokenList());\n+      return new Allocation(application.pullNewlyAllocatedContainers(),\n+          headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e, increaseRequests-List\u003cContainerResourceChangeRequest\u003e, decreaseRequests-List\u003cContainerResourceChangeRequest\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
          "commitDate": "2015-09-23, 4:29 p.m.",
          "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
          "commitAuthor": "Jian He",
          "commitDateOld": "2015-09-13, 8:03 p.m.",
          "commitNameOld": "81df7b586a16f8226c7b01c139c1c70c060399c3",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 9.85,
          "commitsBetweenForRepo": 74,
          "commitsBetweenForFile": 1,
          "actualSource": "  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(application.pullNewlyAllocatedContainers(),\n          headroom, null, null, null, application.pullUpdatedNMTokens());\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
          "functionStartLine": 314,
          "functionName": "allocate",
          "diff": "@@ -1,62 +1,62 @@\n-  public Allocation allocate(\n-      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n-      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n+  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n+      List\u003cResourceRequest\u003e ask, List\u003cContainerId\u003e release,\n+      List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals,\n+      List\u003cContainerResourceChangeRequest\u003e increaseRequests,\n+      List\u003cContainerResourceChangeRequest\u003e decreaseRequests) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n       if (application.isWaitingForAMContainer(application.getApplicationId())) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n-      ContainersAndNMTokensAllocation allocation \u003d\n-          application.pullNewlyAllocatedContainersAndNMTokens();\n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n-      return new Allocation(allocation.getContainerList(), headroom, null,\n-          null, null, allocation.getNMTokenList());\n+      return new Allocation(application.pullNewlyAllocatedContainers(),\n+          headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "81df7b586a16f8226c7b01c139c1c70c060399c3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2005. Blacklisting support for scheduling AMs. (Anubhav Dhoot via kasha)\n",
      "commitDate": "2015-09-13, 8:03 p.m.",
      "commitName": "81df7b586a16f8226c7b01c139c1c70c060399c3",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "2015-07-21, 12:57 p.m.",
      "commitNameOld": "c39ca541f498712133890961598bbff50d89d68b",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 54.3,
      "commitsBetweenForRepo": 301,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId +\n            \" #ask\u003d\" + ask.size());\n      }\n\n      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n        // Allocate is for AM and update AM blacklist for this\n        application.updateAMBlacklist(\n            blacklistAdditions, blacklistRemovals);\n      } else {\n        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      }\n\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(allocation.getContainerList(), headroom, null,\n          null, null, allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 313,
      "functionName": "allocate",
      "diff": "@@ -1,55 +1,62 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n-            \" applicationId\u003d\" + applicationAttemptId + \n+            \" applicationId\u003d\" + applicationAttemptId +\n             \" #ask\u003d\" + ask.size());\n       }\n \n-      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n+        // Allocate is for AM and update AM blacklist for this\n+        application.updateAMBlacklist(\n+            blacklistAdditions, blacklistRemovals);\n+      } else {\n+        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+      }\n+\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       Resource headroom \u003d application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(allocation.getContainerList(), headroom, null,\n           null, null, allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "658097d6da1b1aac8e01db459f0c3b456e99652f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3273. Improve scheduler UI to facilitate scheduling analysis and debugging. Contributed Rohith Sharmaks\n",
      "commitDate": "2015-03-18, 12:30 a.m.",
      "commitName": "658097d6da1b1aac8e01db459f0c3b456e99652f",
      "commitAuthor": "Jian He",
      "commitDateOld": "2014-12-30, 10:55 p.m.",
      "commitNameOld": "e7257acd8a7adb74d81cd1d009d4a99f023ed844",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 77.02,
      "commitsBetweenForRepo": 628,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      Resource headroom \u003d application.getHeadroom();\n      application.setApplicationHeadroomForMetrics(headroom);\n      return new Allocation(allocation.getContainerList(), headroom, null,\n          null, null, allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 297,
      "functionName": "allocate",
      "diff": "@@ -1,54 +1,55 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n-      return new Allocation(allocation.getContainerList(),\n-        application.getHeadroom(), null, null, null,\n-        allocation.getNMTokenList());\n+      Resource headroom \u003d application.getHeadroom();\n+      application.setApplicationHeadroomForMetrics(headroom);\n+      return new Allocation(allocation.getContainerList(), headroom, null,\n+          null, null, allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2604. Scheduler should consider max-allocation-* in conjunction with the largest node. (Robert Kanter via kasha)\n",
      "commitDate": "2014-11-21, 1:32 p.m.",
      "commitName": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "2014-10-15, 9:33 p.m.",
      "commitNameOld": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 36.71,
      "commitsBetweenForRepo": 344,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, getMaximumResourceCapability());\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), null, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 297,
      "functionName": "allocate",
      "diff": "@@ -1,54 +1,54 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n-        clusterResource, minimumAllocation, maximumAllocation);\n+        clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), null, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f6a778c3725bcdaba1e1de43786af17dd44deb78": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2249. Avoided AM release requests being lost on work preserving RM restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1618972 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-08-19, 4:33 p.m.",
      "commitName": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "2014-07-18, 8:12 p.m.",
      "commitNameOld": "8871d8ed9fb1e4b21943477dcbaa13ef22ea7b8e",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 31.85,
      "commitsBetweenForRepo": 243,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    releaseContainers(release, application);\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), null, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 280,
      "functionName": "allocate",
      "diff": "@@ -1,68 +1,54 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n-    for (ContainerId releasedContainer : release) {\n-      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n-      if (rmContainer \u003d\u003d null) {\n-         RMAuditLogger.logFailure(application.getUser(),\n-             AuditConstants.RELEASE_CONTAINER, \n-             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n-             \"Trying to release container not owned by app or with invalid id\",\n-             application.getApplicationId(), releasedContainer);\n-      }\n-      containerCompleted(rmContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              releasedContainer, \n-              SchedulerUtils.RELEASED_CONTAINER),\n-          RMContainerEventType.RELEASED);\n-    }\n+    releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation \u003d\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), null, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5fd5c9900cfd299428acbc8dff767273e44647c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-713. Fixed ResourceManager to not crash while building tokens when DNS issues happen transmittently. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1569979 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-02-19, 6:39 p.m.",
      "commitName": "5fd5c9900cfd299428acbc8dff767273e44647c0",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "2014-02-13, 5:02 p.m.",
      "commitNameOld": "d0a5e43de73119e57d12f2ec89a9d1a192cde204",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.07,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n      ContainersAndNMTokensAllocation allocation \u003d\n          application.pullNewlyAllocatedContainersAndNMTokens();\n      return new Allocation(allocation.getContainerList(),\n        application.getHeadroom(), null, null, null,\n        allocation.getNMTokenList());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 266,
      "functionName": "allocate",
      "diff": "@@ -1,67 +1,68 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n-\n-      return new Allocation(\n-          application.pullNewlyAllocatedContainers(), \n-          application.getHeadroom());\n+      ContainersAndNMTokensAllocation allocation \u003d\n+          application.pullNewlyAllocatedContainersAndNMTokens();\n+      return new Allocation(allocation.getContainerList(),\n+        application.getHeadroom(), null, null, null,\n+        allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-01-10, 10:04 a.m.",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "2014-01-02, 3:19 p.m.",
      "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.78,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 267,
      "functionName": "allocate",
      "diff": "@@ -1,67 +1,67 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n-    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n+    FiCaSchedulerApp application \u003d getApplicationAttempt(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a6e275ee3360719290ad666629624450d4f0a6f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1141. Updating resource requests should be decoupled with updating blacklist (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1528632 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-10-02, 5:31 p.m.",
      "commitName": "0a6e275ee3360719290ad666629624450d4f0a6f",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "2013-09-29, 4:21 a.m.",
      "commitNameOld": "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.55,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 259,
      "functionName": "allocate",
      "diff": "@@ -1,65 +1,67 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n-        application.updateResourceRequests(ask, blacklistAdditions, blacklistRemovals);\n+        application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n+      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+\n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8eb3be63f598daae01f0a0c09eab5086881f153d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-877. Support resource blacklisting for FifoScheduler. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1498021 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-06-29, 4:18 p.m.",
      "commitName": "8eb3be63f598daae01f0a0c09eab5086881f153d",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "2013-06-21, 2:28 p.m.",
      "commitNameOld": "37d7935a9d7b86635c9c1ffc03f88b49857f88a0",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 8.08,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask, blacklistAdditions, blacklistRemovals);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 246,
      "functionName": "allocate",
      "diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n-        application.updateResourceRequests(ask, null, null);\n+        application.updateResourceRequests(ask, blacklistAdditions, blacklistRemovals);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-750. Allow for black-listing resources in YARN API and Impl in CS (acmurthy via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490392 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-06-06, 2:46 p.m.",
      "commitName": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
      "commitAuthor": "Bikas Saha",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-750. Allow for black-listing resources in YARN API and Impl in CS (acmurthy via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490392 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2013-06-06, 2:46 p.m.",
          "commitName": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
          "commitAuthor": "Bikas Saha",
          "commitDateOld": "2013-06-03, 8:34 p.m.",
          "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 2.76,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask, null, null);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
          "functionStartLine": 223,
          "functionName": "allocate",
          "diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n-      List\u003cContainerId\u003e release) {\n+      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n-        application.updateResourceRequests(ask);\n+        application.updateResourceRequests(ask, null, null);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List\u003cResourceRequest\u003e, release-List\u003cContainerId\u003e, blacklistAdditions-List\u003cString\u003e, blacklistRemovals-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-750. Allow for black-listing resources in YARN API and Impl in CS (acmurthy via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490392 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2013-06-06, 2:46 p.m.",
          "commitName": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
          "commitAuthor": "Bikas Saha",
          "commitDateOld": "2013-06-03, 8:34 p.m.",
          "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 2.76,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask, null, null);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
          "functionStartLine": 223,
          "functionName": "allocate",
          "diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n-      List\u003cContainerId\u003e release) {\n+      List\u003cContainerId\u003e release, List\u003cString\u003e blacklistAdditions, List\u003cString\u003e blacklistRemovals) {\n     FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n-        application.updateResourceRequests(ask);\n+        application.updateResourceRequests(ask, null, null);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "bc6777dd5bdcbaef09897b506bc6511ae456033d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-193. Scheduler.normalizeRequest does not account for allocation requests that exceed maximumAllocation limits (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465067 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-04-05, 1:45 p.m.",
      "commitName": "bc6777dd5bdcbaef09897b506bc6511ae456033d",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "2013-03-29, 10:36 a.m.",
      "commitNameOld": "01aabf73639785a29d1651f2e268cec04a8b9b94",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 7.13,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation, maximumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 223,
      "functionName": "allocate",
      "diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n     FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n-        clusterResource, minimumAllocation);\n+        clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren\u0027t stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01aabf73639785a29d1651f2e268cec04a8b9b94": {
      "type": "Ybodychange",
      "commitMessage": "YARN-460. CS user left in list of active users for the queue even when application finished (tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1462486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-03-29, 10:36 a.m.",
      "commitName": "01aabf73639785a29d1651f2e268cec04a8b9b94",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "2013-03-28, 3:44 p.m.",
      "commitNameOld": "520033b1cd81c76b38fcdcfcfeed16158db4bbba",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n\n      // make sure we aren\u0027t stopping/removing the application\n      // when the allocate comes in\n      if (application.isStopped()) {\n        LOG.info(\"Calling allocate on a stopped \" +\n            \"application \" + applicationAttemptId);\n        return EMPTY_ALLOCATION;\n      }\n\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 223,
      "functionName": "allocate",
      "diff": "@@ -1,56 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n     FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n+\n+      // make sure we aren\u0027t stopping/removing the application\n+      // when the allocate comes in\n+      if (application.isStopped()) {\n+        LOG.info(\"Calling allocate on a stopped \" +\n+            \"application \" + applicationAttemptId);\n+        return EMPTY_ALLOCATION;\n+      }\n+\n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-09, 12:08 a.m.",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "2012-11-28, 8:56 p.m.",
      "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 41.13,
      "commitsBetweenForRepo": 152,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n        clusterResource, minimumAllocation);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 222,
      "functionName": "allocate",
      "diff": "@@ -1,55 +1,56 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n     FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n+    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n+        clusterResource, minimumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012-08-08, 1:22 a.m.",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "2012-08-07, 10:53 p.m.",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 223,
      "functionName": "allocate",
      "diff": "",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012-07-16, 9:43 p.m.",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "2012-07-13, 4:53 p.m.",
      "commitNameOld": "17de78a43e8d010f3df91dc5a1a40d74b60dfb8c",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 3.2,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 223,
      "functionName": "allocate",
      "diff": "@@ -1,55 +1,55 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n-    SchedulerApp application \u003d getApplication(applicationAttemptId);\n+    FiCaSchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "23e336a0ed314ac7f1b47649d1a688e8de6b6e94": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3765. FifoScheduler does not respect yarn.scheduler.fifo.minimum-allocation-mb setting (Hitesh Shah via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240634 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012-02-04, 5:44 p.m.",
      "commitName": "23e336a0ed314ac7f1b47649d1a688e8de6b6e94",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "2012-02-02, 7:33 p.m.",
      "commitNameOld": "72d34e6594371112bb4e9835817b382bd4161a6d",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 1.92,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    SchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 222,
      "functionName": "allocate",
      "diff": "@@ -1,55 +1,55 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n     SchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n+    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" application\u003d\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId\u003d\" + applicationAttemptId + \n             \" #ask\u003d\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80cc8e94861e2b0fc423b77fa8ce0f174c3a91fd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3345. Fixed a race condition in ResourceManager that was causing TestContainerManagerSecurity to fail sometimes. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1199144 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-11-08, 2:55 a.m.",
      "commitName": "80cc8e94861e2b0fc423b77fa8ce0f174c3a91fd",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "2011-10-20, 7:45 a.m.",
      "commitNameOld": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 18.84,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    SchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    synchronized (application) {\n      if (!ask.isEmpty()) {\n        LOG.debug(\"allocate: pre-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        // Update application requests\n        application.updateResourceRequests(ask);\n\n        LOG.debug(\"allocate: post-update\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" application\u003d\" + application);\n        application.showRequests();\n\n        LOG.debug(\"allocate:\" +\n            \" applicationId\u003d\" + applicationAttemptId + \n            \" #ask\u003d\" + ask.size());\n      }\n\n      return new Allocation(\n          application.pullNewlyAllocatedContainers(), \n          application.getHeadroom());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 209,
      "functionName": "allocate",
      "diff": "@@ -1,53 +1,55 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n     SchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n-    if (!ask.isEmpty()) {\n-      LOG.debug(\"allocate: pre-update\" +\n-          \" applicationId\u003d\" + applicationAttemptId + \n-          \" application\u003d\" + application);\n-      application.showRequests();\n+    synchronized (application) {\n+      if (!ask.isEmpty()) {\n+        LOG.debug(\"allocate: pre-update\" +\n+            \" applicationId\u003d\" + applicationAttemptId + \n+            \" application\u003d\" + application);\n+        application.showRequests();\n \n-      // Update application requests\n-      application.updateResourceRequests(ask);\n+        // Update application requests\n+        application.updateResourceRequests(ask);\n \n-      LOG.debug(\"allocate: post-update\" +\n-          \" applicationId\u003d\" + applicationAttemptId + \n-          \" application\u003d\" + application);\n-      application.showRequests();\n+        LOG.debug(\"allocate: post-update\" +\n+            \" applicationId\u003d\" + applicationAttemptId + \n+            \" application\u003d\" + application);\n+        application.showRequests();\n \n-      LOG.debug(\"allocate:\" +\n-          \" applicationId\u003d\" + applicationAttemptId + \n-          \" #ask\u003d\" + ask.size());\n+        LOG.debug(\"allocate:\" +\n+            \" applicationId\u003d\" + applicationAttemptId + \n+            \" #ask\u003d\" + ask.size());\n+      }\n+\n+      return new Allocation(\n+          application.pullNewlyAllocatedContainers(), \n+          application.getHeadroom());\n     }\n-\n-    return new Allocation(\n-        application.pullNewlyAllocatedContainers(), \n-        application.getHeadroom());\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e549ac93694f768f2e26706a54a1b45dea6d2844": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2788. Normalize resource requests in FifoScheduler appropriately. Contributed by Ahmed Radwan. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1186467 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-10-19, 4:37 p.m.",
      "commitName": "e549ac93694f768f2e26706a54a1b45dea6d2844",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "2011-10-05, 10:01 a.m.",
      "commitNameOld": "9a4e890f4aadc921fa468fd1292d215704429b61",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 14.27,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    SchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    if (!ask.isEmpty()) {\n      LOG.debug(\"allocate: pre-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      // Update application requests\n      application.updateResourceRequests(ask);\n\n      LOG.debug(\"allocate: post-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      LOG.debug(\"allocate:\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" #ask\u003d\" + ask.size());\n    }\n\n    return new Allocation(\n        application.pullNewlyAllocatedContainers(), \n        application.getHeadroom());\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 209,
      "functionName": "allocate",
      "diff": "@@ -1,53 +1,53 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n     SchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    normalizeRequests(ask);\n+    SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     if (!ask.isEmpty()) {\n       LOG.debug(\"allocate: pre-update\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" application\u003d\" + application);\n       application.showRequests();\n \n       // Update application requests\n       application.updateResourceRequests(ask);\n \n       LOG.debug(\"allocate: post-update\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" application\u003d\" + application);\n       application.showRequests();\n \n       LOG.debug(\"allocate:\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" #ask\u003d\" + ask.size());\n     }\n \n     return new Allocation(\n         application.pullNewlyAllocatedContainers(), \n         application.getHeadroom());\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2933. Change allocate call to return ContainerStatus for completed containers rather than Container.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169484 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-09-11, 1:26 p.m.",
      "commitName": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "2011-09-08, 10:04 p.m.",
      "commitNameOld": "035937bee8ef57bc24b08068e7375ac45413a349",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.64,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    SchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              releasedContainer, \n              SchedulerUtils.RELEASED_CONTAINER),\n          RMContainerEventType.RELEASED);\n    }\n\n    if (!ask.isEmpty()) {\n      LOG.debug(\"allocate: pre-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      // Update application requests\n      application.updateResourceRequests(ask);\n\n      LOG.debug(\"allocate: post-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      LOG.debug(\"allocate:\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" #ask\u003d\" + ask.size());\n    }\n\n    return new Allocation(\n        application.pullNewlyAllocatedContainers(), \n        application.getHeadroom());\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 214,
      "functionName": "allocate",
      "diff": "@@ -1,49 +1,53 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n     SchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n       if (rmContainer \u003d\u003d null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n-      containerCompleted(rmContainer, RMContainerEventType.RELEASED);\n+      containerCompleted(rmContainer,\n+          SchedulerUtils.createAbnormalContainerStatus(\n+              releasedContainer, \n+              SchedulerUtils.RELEASED_CONTAINER),\n+          RMContainerEventType.RELEASED);\n     }\n \n     if (!ask.isEmpty()) {\n       LOG.debug(\"allocate: pre-update\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" application\u003d\" + application);\n       application.showRequests();\n \n       // Update application requests\n       application.updateResourceRequests(ask);\n \n       LOG.debug(\"allocate: post-update\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" application\u003d\" + application);\n       application.showRequests();\n \n       LOG.debug(\"allocate:\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" #ask\u003d\" + ask.size());\n     }\n \n     return new Allocation(\n         application.pullNewlyAllocatedContainers(), \n         application.getHeadroom());\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cdfabf5ae289836968b3d296668593b9500b6f26": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2655. Add audit logs to ResourceManager and NodeManager. Contributed by Thomas Graves.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165949 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-09-06, 9:24 p.m.",
      "commitName": "cdfabf5ae289836968b3d296668593b9500b6f26",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "2011-08-24, 8:14 p.m.",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 13.05,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    SchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n      if (rmContainer \u003d\u003d null) {\n         RMAuditLogger.logFailure(application.getUser(),\n             AuditConstants.RELEASE_CONTAINER, \n             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n             \"Trying to release container not owned by app or with invalid id\",\n             application.getApplicationId(), releasedContainer);\n      }\n      containerCompleted(rmContainer, RMContainerEventType.RELEASED);\n    }\n\n    if (!ask.isEmpty()) {\n      LOG.debug(\"allocate: pre-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      // Update application requests\n      application.updateResourceRequests(ask);\n\n      LOG.debug(\"allocate: post-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      LOG.debug(\"allocate:\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" #ask\u003d\" + ask.size());\n    }\n\n    return new Allocation(\n        application.pullNewlyAllocatedContainers(), \n        application.getHeadroom());\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 215,
      "functionName": "allocate",
      "diff": "@@ -1,42 +1,49 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n       List\u003cContainerId\u003e release) {\n     SchedulerApp application \u003d getApplication(applicationAttemptId);\n     if (application \u003d\u003d null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n-      containerCompleted(getRMContainer(releasedContainer), \n-          RMContainerEventType.RELEASED);\n+      RMContainer rmContainer \u003d getRMContainer(releasedContainer);\n+      if (rmContainer \u003d\u003d null) {\n+         RMAuditLogger.logFailure(application.getUser(),\n+             AuditConstants.RELEASE_CONTAINER, \n+             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n+             \"Trying to release container not owned by app or with invalid id\",\n+             application.getApplicationId(), releasedContainer);\n+      }\n+      containerCompleted(rmContainer, RMContainerEventType.RELEASED);\n     }\n \n     if (!ask.isEmpty()) {\n       LOG.debug(\"allocate: pre-update\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" application\u003d\" + application);\n       application.showRequests();\n \n       // Update application requests\n       application.updateResourceRequests(ask);\n \n       LOG.debug(\"allocate: post-update\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" application\u003d\" + application);\n       application.showRequests();\n \n       LOG.debug(\"allocate:\" +\n           \" applicationId\u003d\" + applicationAttemptId + \n           \" #ask\u003d\" + ask.size());\n     }\n \n     return new Allocation(\n         application.pullNewlyAllocatedContainers(), \n         application.getHeadroom());\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-08-24, 8:14 p.m.",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "2011-08-24, 8:06 p.m.",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    SchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      containerCompleted(getRMContainer(releasedContainer), \n          RMContainerEventType.RELEASED);\n    }\n\n    if (!ask.isEmpty()) {\n      LOG.debug(\"allocate: pre-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      // Update application requests\n      application.updateResourceRequests(ask);\n\n      LOG.debug(\"allocate: post-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      LOG.debug(\"allocate:\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" #ask\u003d\" + ask.size());\n    }\n\n    return new Allocation(\n        application.pullNewlyAllocatedContainers(), \n        application.getHeadroom());\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 213,
      "functionName": "allocate",
      "diff": "",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-08-18, 7:07 a.m.",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,42 @@\n+  public Allocation allocate(\n+      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n+      List\u003cContainerId\u003e release) {\n+    SchedulerApp application \u003d getApplication(applicationAttemptId);\n+    if (application \u003d\u003d null) {\n+      LOG.error(\"Calling allocate on removed \" +\n+          \"or non existant application \" + applicationAttemptId);\n+      return EMPTY_ALLOCATION;\n+    }\n+\n+    // Sanity check\n+    normalizeRequests(ask);\n+\n+    // Release containers\n+    for (ContainerId releasedContainer : release) {\n+      containerCompleted(getRMContainer(releasedContainer), \n+          RMContainerEventType.RELEASED);\n+    }\n+\n+    if (!ask.isEmpty()) {\n+      LOG.debug(\"allocate: pre-update\" +\n+          \" applicationId\u003d\" + applicationAttemptId + \n+          \" application\u003d\" + application);\n+      application.showRequests();\n+\n+      // Update application requests\n+      application.updateResourceRequests(ask);\n+\n+      LOG.debug(\"allocate: post-update\" +\n+          \" applicationId\u003d\" + applicationAttemptId + \n+          \" application\u003d\" + application);\n+      application.showRequests();\n+\n+      LOG.debug(\"allocate:\" +\n+          \" applicationId\u003d\" + applicationAttemptId + \n+          \" #ask\u003d\" + ask.size());\n+    }\n+\n+    return new Allocation(\n+        application.pullNewlyAllocatedContainers(), \n+        application.getHeadroom());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Allocation allocate(\n      ApplicationAttemptId applicationAttemptId, List\u003cResourceRequest\u003e ask,\n      List\u003cContainerId\u003e release) {\n    SchedulerApp application \u003d getApplication(applicationAttemptId);\n    if (application \u003d\u003d null) {\n      LOG.error(\"Calling allocate on removed \" +\n          \"or non existant application \" + applicationAttemptId);\n      return EMPTY_ALLOCATION;\n    }\n\n    // Sanity check\n    normalizeRequests(ask);\n\n    // Release containers\n    for (ContainerId releasedContainer : release) {\n      containerCompleted(getRMContainer(releasedContainer), \n          RMContainerEventType.RELEASED);\n    }\n\n    if (!ask.isEmpty()) {\n      LOG.debug(\"allocate: pre-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      // Update application requests\n      application.updateResourceRequests(ask);\n\n      LOG.debug(\"allocate: post-update\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" application\u003d\" + application);\n      application.showRequests();\n\n      LOG.debug(\"allocate:\" +\n          \" applicationId\u003d\" + applicationAttemptId + \n          \" #ask\u003d\" + ask.size());\n    }\n\n    return new Allocation(\n        application.pullNewlyAllocatedContainers(), \n        application.getHeadroom());\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
      "functionStartLine": 213,
      "functionName": "allocate"
    }
  }
}