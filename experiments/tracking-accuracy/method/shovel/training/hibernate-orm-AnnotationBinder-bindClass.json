{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "H:\\Projects\\hibernate\\hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "AnnotationBinder.java",
  "functionName": "bindClass",
  "functionId": "bindClass___clazzToProcess-XClass__inheritanceStatePerClass-Map__XClass,InheritanceState____context-MetadataBuildingContext",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
  "functionStartLine": 524,
  "functionEndLine": 834,
  "numCommitsSeen": 224,
  "timeTaken": 13570,
  "changeHistory": [
    "ebca36a76851c9b0b7ea406e1b1428225891de2f",
    "8f889e95d76f47945c9ec072fd08cb045767578c",
    "b1a9c816a7e1159d6ae75898a8f455e425f94d4e",
    "59c3baae3271247bed516fe50952b65be1a27e5b",
    "aeb3aee62603f4e3613ed4037f2727c817a11016",
    "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021",
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
    "9caca0ce37d5a2763d476c6fa2471addcca710ca",
    "5329bba1ea724eabf5783c71e5127b8f84ad0fcc",
    "1d9b7a06a52b56b84844513d97c535eb00d0ed8a",
    "09547a9051dd0ed851d8d6c5bd90841a93db2604",
    "1569e6194b45038a210984d73d25079dd1482b3f",
    "c47352058541e14e0b80d38f94c65d939d5394f5",
    "129c0f13482b99e2705f0e234b6bc0572a95c271",
    "a351c520205d18f18bc1c47091b4a62629f19de1",
    "ad17f89c4c29f0327c843cf5265e156d65743ab1",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
    "bf7607e24495af5133165ae6ed6b85feecf59148",
    "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
    "421789ddcd906e806bf901fea9d9e713daebd51a",
    "422ecc653a7d78ee0464478750a076710b697849",
    "153ad753e19b1f71665e6cfcbd903fb1ced889db",
    "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08",
    "252299cfee96892b71b3bd3e200181089e350e27",
    "5ee9ba361c96c29b06542720cb8b01e1034d8544",
    "d00f7efb308fab613b4918f9b8831f07602c6bd0",
    "d24ed1a1d39c1458d020a27a504a46e76dfe2e26",
    "2dd470af1f453e54643d55b2c81ec5a7324952b1",
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
    "025b3cc14180d0459856bc45a6cac7acce3e1265",
    "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489",
    "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed",
    "c7c6981a558e35f01ff8d27938e98aa83896765c",
    "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
    "2176af11442c702aefa1900cdba4c32e6338b620",
    "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4",
    "88caf4d9586e988675254c268f4e145d272a9499",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e",
    "7337743c93574823424ed6c399cfcf6bd75614f8"
  ],
  "changeHistoryShort": {
    "ebca36a76851c9b0b7ea406e1b1428225891de2f": "Ybodychange",
    "8f889e95d76f47945c9ec072fd08cb045767578c": "Ybodychange",
    "b1a9c816a7e1159d6ae75898a8f455e425f94d4e": "Ybodychange",
    "59c3baae3271247bed516fe50952b65be1a27e5b": "Ybodychange",
    "aeb3aee62603f4e3613ed4037f2727c817a11016": "Ybodychange",
    "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021": "Ybodychange",
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d": "Ybodychange",
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": "Ymultichange(Yparameterchange,Ybodychange)",
    "5329bba1ea724eabf5783c71e5127b8f84ad0fcc": "Ybodychange",
    "1d9b7a06a52b56b84844513d97c535eb00d0ed8a": "Ybodychange",
    "09547a9051dd0ed851d8d6c5bd90841a93db2604": "Ybodychange",
    "1569e6194b45038a210984d73d25079dd1482b3f": "Ybodychange",
    "c47352058541e14e0b80d38f94c65d939d5394f5": "Ybodychange",
    "129c0f13482b99e2705f0e234b6bc0572a95c271": "Ybodychange",
    "a351c520205d18f18bc1c47091b4a62629f19de1": "Ybodychange",
    "ad17f89c4c29f0327c843cf5265e156d65743ab1": "Ybodychange",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": "Ybodychange",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": "Yfilerename",
    "bf7607e24495af5133165ae6ed6b85feecf59148": "Ybodychange",
    "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185": "Ybodychange",
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f": "Yparameterchange",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": "Yfilerename",
    "421789ddcd906e806bf901fea9d9e713daebd51a": "Ybodychange",
    "422ecc653a7d78ee0464478750a076710b697849": "Ybodychange",
    "153ad753e19b1f71665e6cfcbd903fb1ced889db": "Ybodychange",
    "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08": "Ybodychange",
    "252299cfee96892b71b3bd3e200181089e350e27": "Ybodychange",
    "5ee9ba361c96c29b06542720cb8b01e1034d8544": "Ybodychange",
    "d00f7efb308fab613b4918f9b8831f07602c6bd0": "Ybodychange",
    "d24ed1a1d39c1458d020a27a504a46e76dfe2e26": "Ybodychange",
    "2dd470af1f453e54643d55b2c81ec5a7324952b1": "Ybodychange",
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09": "Ybodychange",
    "025b3cc14180d0459856bc45a6cac7acce3e1265": "Ybodychange",
    "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489": "Ybodychange",
    "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed": "Ybodychange",
    "c7c6981a558e35f01ff8d27938e98aa83896765c": "Ybodychange",
    "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034": "Ybodychange",
    "2176af11442c702aefa1900cdba4c32e6338b620": "Ybodychange",
    "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4": "Ybodychange",
    "88caf4d9586e988675254c268f4e145d272a9499": "Ybodychange",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": "Yfilerename",
    "7337743c93574823424ed6c399cfcf6bd75614f8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ebca36a76851c9b0b7ea406e1b1428225891de2f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12654 - Throw MappingException if both @Inheritance and @AttributeOverride are used\n",
      "commitDate": "2018-06-20, 10:03 a.m.",
      "commitName": "ebca36a76851c9b0b7ea406e1b1428225891de2f",
      "commitAuthor": "Vlad Mihalcea",
      "commitDateOld": "2018-04-16, 10:47 a.m.",
      "commitNameOld": "6cefa865b0635a71eb85e20f6255491439ecb6da",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 64.97,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tif(superEntity !\u003d null \u0026\u0026 (\n\t\t\t\tclazzToProcess.getAnnotation( AttributeOverride.class ) !\u003d null ||\n\t\t\t\tclazzToProcess.getAnnotation( AttributeOverrides.class ) !\u003d null ) ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"An entity annotated with @Inheritance cannot use @AttributeOverride or @AttributeOverrides: \" +\n\t\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t);\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003c\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context, jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n\n\t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators( clazzToProcess, context );\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 524,
      "functionName": "bindClass",
      "diff": "@@ -1,302 +1,311 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n+\t\tif(superEntity !\u003d null \u0026\u0026 (\n+\t\t\t\tclazzToProcess.getAnnotation( AttributeOverride.class ) !\u003d null ||\n+\t\t\t\tclazzToProcess.getAnnotation( AttributeOverrides.class ) !\u003d null ) ) {\n+\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\"An entity annotated with @Inheritance cannot use @AttributeOverride or @AttributeOverrides: \" +\n+\t\t\t\t\t\t\tclazzToProcess.getName()\n+\t\t\t);\n+\t\t}\n+\n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003c\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key \u003d new DependantValue( context, jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n \n \t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators( clazzToProcess, context );\n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8f889e95d76f47945c9ec072fd08cb045767578c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018-03-28, 6:43 p.m.",
      "commitName": "8f889e95d76f47945c9ec072fd08cb045767578c",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2018-03-14, 8:17 a.m.",
      "commitNameOld": "8b11d5ecf9a71ae70e3f7c837ed3de1b55ec096d",
      "commitAuthorOld": "Roland Illig",
      "daysBetweenCommits": 14.43,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003c\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context, jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n\n\t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators( clazzToProcess, context );\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 520,
      "functionName": "bindClass",
      "diff": "@@ -1,302 +1,302 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n-\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n+\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003c\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n-\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n+\t\t\t\tSimpleValue key \u003d new DependantValue( context, jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n \n \t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators( clazzToProcess, context );\n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b1a9c816a7e1159d6ae75898a8f455e425f94d4e": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12157 - TableGenerator defined on one class is not visible on another\n\n(cherry picked from commit 8ae3dc4078597c69588ca8237591f1eab64c6bd7)\n",
      "commitDate": "2017-12-13, 10:38 a.m.",
      "commitName": "b1a9c816a7e1159d6ae75898a8f455e425f94d4e",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2017-12-13, 7:19 a.m.",
      "commitNameOld": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n\n\t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators( clazzToProcess, context );\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 522,
      "functionName": "bindClass",
      "diff": "@@ -1,303 +1,302 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n \n \t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n-\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n-\n+\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators( clazzToProcess, context );\n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n-\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n+\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59c3baae3271247bed516fe50952b65be1a27e5b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12146  - Support enabling caching at any level within a mapped hierarchy\n",
      "commitDate": "2017-12-13, 7:19 a.m.",
      "commitName": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2017-12-13, 7:19 a.m.",
      "commitNameOld": "6818275376639c2a0d64674c4bd0320d64e86d89",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n\n\t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 523,
      "functionName": "bindClass",
      "diff": "@@ -1,304 +1,303 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n-\t\tentityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n-\t\tentityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n+\t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n \n \t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aeb3aee62603f4e3613ed4037f2727c817a11016": {
      "type": "Ybodychange",
      "commitMessage": "HHH-11180 - JPA @ForeignKey still not consistently applied from annotation binding\n\n- Fix ForeignKey support for PrimaryKeyJoinColumn / PrimaryKeyJoinColumns\n- Fix ForeignKey support for JoinColumn / JoinColumns\n- Fix ForeignKey support for JoinTable when applying value NO_CONSTRAINT.\n- Fix ForeignKey support for MapKeyJoinColumn / MapKeyJoinColumns\n- Fix ForeignKey support for AssociationOverride / AssociationOverrides\n",
      "commitDate": "2017-02-15, 7:08 a.m.",
      "commitName": "aeb3aee62603f4e3613ed4037f2727c817a11016",
      "commitAuthor": "Christian Beikov",
      "commitDateOld": "2016-12-06, 7:50 a.m.",
      "commitNameOld": "b1c7615904e7dd3c03bbe77af8bda2fbce6a3624",
      "commitAuthorOld": "Vlad Mihalcea",
      "daysBetweenCommits": 70.97,
      "commitsBetweenForRepo": 183,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t\tentityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n\t\tentityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n\n\t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 484,
      "functionName": "bindClass",
      "diff": "@@ -1,292 +1,304 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tentityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t\tentityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n-\t\t\t\t\tif ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey() !\u003d null\n-\t\t\t\t\t\t\t\u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n+\t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n+\n+\t\t\t\t\tif ( pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n+\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n+\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n+\t\t\t\t\t}\n+\t\t\t\t\telse if ( pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n+\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n+\t\t\t\t\t}\n+\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT ) {\n+\t\t\t\t\t\t// don\u0027t apply a constraint based on ConstraintMode\n+\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n+\t\t\t\t\t}\n+\t\t\t\t\telse if ( pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10352 - Fix HBM2DDL does not use described name for foreign key in join inheritance\n",
      "commitDate": "2016-06-13, 7:58 p.m.",
      "commitName": "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2016-06-07, 4:36 a.m.",
      "commitNameOld": "78de650efec58367a4196eb41c1d5f99b291f036",
      "commitAuthorOld": "Matthias Kurz",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t\tentityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n\t\tentityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\t\tif ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey() !\u003d null\n\t\t\t\t\t\t\t\u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 484,
      "functionName": "bindClass",
      "diff": "@@ -1,285 +1,292 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tentityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t\tentityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n+\t\t\t\t\tif ( pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey() !\u003d null\n+\t\t\t\t\t\t\t\u0026\u0026 !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n+\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9837 - Remove reliance during annotation binding on org.hibernate.internal.util.ClassLoaderHelper\nHHH-9841 - Redesign org.hibernate.property.PropertyAccessorFactory\n",
      "commitDate": "2015-06-04, 3:12 p.m.",
      "commitName": "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015-05-19, 12:25 a.m.",
      "commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 16.62,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        if ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 482,
      "functionName": "bindClass",
      "diff": "@@ -1,285 +1,285 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n-\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n+\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n         if ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
      "commitDate": "2015-03-10, 5:53 p.m.",
      "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "commitAuthor": "Steve Ebersole",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
          "commitDate": "2015-03-10, 5:53 p.m.",
          "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2014-09-30, 10:40 a.m.",
          "commitNameOld": "83f29d1e1a3d0655d4f402636bc191ff05ad74ea",
          "commitAuthorOld": "Maxim Frolov",
          "daysBetweenCommits": 161.3,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        if ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
          "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 587,
          "functionName": "bindClass",
          "diff": "@@ -1,252 +1,285 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n-\t\t\tMappings mappings) throws MappingException {\n+\t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n-\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n+\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n-\t\t\tbindQueries( clazzToProcess, mappings );\n-\t\t\tbindTypeDefs( clazzToProcess, mappings );\n-\t\t\tbindFilterDefs( clazzToProcess, mappings );\n+\t\t\tbindQueries( clazzToProcess, context );\n+\t\t\tbindTypeDefs( clazzToProcess, context );\n+\t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n-\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n-\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n+\t\t\t\tentityAnn,\n+\t\t\t\thibEntityAnn,\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n-\t\tbindQueries( clazzToProcess, mappings );\n-\t\tbindFilterDefs( clazzToProcess, mappings );\n-\t\tbindTypeDefs( clazzToProcess, mappings );\n-\t\tbindFetchProfiles( clazzToProcess, mappings );\n-\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n+\t\tbindQueries( clazzToProcess, context );\n+\t\tbindFilterDefs( clazzToProcess, context );\n+\t\tbindTypeDefs( clazzToProcess, context );\n+\t\tbindFetchProfiles( clazzToProcess, context );\n+\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n-\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceState,\n+\t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n-\t\t\t\t\tmappings,\n+\t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n-\t\t\t\t\tmappings,\n+\t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n-\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n+\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n-\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n+\t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n-\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n-\t\t\t\t\tnull :\n-\t\t\t\t\tcheckAnn.constraints();\n+\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n+\t\t\t\t\t? null\n+\t\t\t\t\t: checkAnn.constraints();\n+\n+\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n+\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n+\t\t\t\t\t: null;\n+\n \t\t\tentityBinder.bindTable(\n-\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n-\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n-\t\t\t\t\t\t\tsuperEntity.getTable() :\n-\t\t\t\t\t\t\tnull\n+\t\t\t\t\tschema,\n+\t\t\t\t\tcatalog,\n+\t\t\t\t\ttable,\n+\t\t\t\t\tuniqueConstraints,\n+\t\t\t\t\tconstraints,\n+\t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n-\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n-\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\telse {\n+\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n+\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\t\t}\n+\n+\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n+\t\t\t\t// we at least need to properly set up the EntityTableXref\n+\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n+\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n+\t\t\t\t);\n+\t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n-\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n+\t\t\t\tentityBinder,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n-\t\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n+\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n-\t\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n-\t\t\t\tmappings.addSecondPass( sp );\n-\t\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n+\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n+\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n         if ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n-\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n+\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n-\t\t\t\tmappings\n+\t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n-\t\t\t\tmappings,\n+\t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n-\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n+\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n-\t\tmappings.addClass( persistentClass );\n+\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n-\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n+\t\tcontext.getMetadataCollector().addSecondPass(\n+\t\t\t\tnew SecondaryTableSecondPass(\n+\t\t\t\t\t\tentityBinder,\n+\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\tclazzToProcess\n+\t\t\t\t)\n+\t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map\u003cXClass,InheritanceState\u003e, mappings-Mappings]",
            "newValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map\u003cXClass,InheritanceState\u003e, context-MetadataBuildingContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
          "commitDate": "2015-03-10, 5:53 p.m.",
          "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2014-09-30, 10:40 a.m.",
          "commitNameOld": "83f29d1e1a3d0655d4f402636bc191ff05ad74ea",
          "commitAuthorOld": "Maxim Frolov",
          "daysBetweenCommits": 161.3,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMetadataBuildingContext context) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, context );\n\t\t\tbindTypeDefs( clazzToProcess, context );\n\t\t\tbindFilterDefs( clazzToProcess, context );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess,\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn,\n\t\t\t\thibEntityAnn,\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tcontext\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, context );\n\t\tbindFilterDefs( clazzToProcess, context );\n\t\tbindTypeDefs( clazzToProcess, context );\n\t\tbindFetchProfiles( clazzToProcess, context );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceState,\n\t\t\t\tsuperEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tcontext,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\tbindFilters( clazzToProcess, entityBinder, context );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n\t\t\t\t\t? null\n\t\t\t\t\t: checkAnn.constraints();\n\n\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t\t: null;\n\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema,\n\t\t\t\t\tcatalog,\n\t\t\t\t\ttable,\n\t\t\t\t\tuniqueConstraints,\n\t\t\t\t\tconstraints,\n\t\t\t\t\tdenormalizedTableXref\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t\t}\n\n\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n\t\t\t\t// we at least need to properly set up the EntityTableXref\n\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tcontext,\n\t\t\t\tinheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        if ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tcontext\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tcontext,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tcontext.getMetadataCollector().addSecondPass(\n\t\t\t\tnew SecondaryTableSecondPass(\n\t\t\t\t\t\tentityBinder,\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tclazzToProcess\n\t\t\t\t)\n\t\t);\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
          "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 587,
          "functionName": "bindClass",
          "diff": "@@ -1,252 +1,285 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n-\t\t\tMappings mappings) throws MappingException {\n+\t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n-\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n+\t\tAnnotatedClassType classType \u003d context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n-\t\t\tbindQueries( clazzToProcess, mappings );\n-\t\t\tbindTypeDefs( clazzToProcess, mappings );\n-\t\t\tbindFilterDefs( clazzToProcess, mappings );\n+\t\t\tbindQueries( clazzToProcess, context );\n+\t\t\tbindTypeDefs( clazzToProcess, context );\n+\t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n-\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n-\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n+\t\t\t\tentityAnn,\n+\t\t\t\thibEntityAnn,\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n-\t\tbindQueries( clazzToProcess, mappings );\n-\t\tbindFilterDefs( clazzToProcess, mappings );\n-\t\tbindTypeDefs( clazzToProcess, mappings );\n-\t\tbindFetchProfiles( clazzToProcess, mappings );\n-\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n+\t\tbindQueries( clazzToProcess, context );\n+\t\tbindFilterDefs( clazzToProcess, context );\n+\t\tbindTypeDefs( clazzToProcess, context );\n+\t\tbindFetchProfiles( clazzToProcess, context );\n+\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n-\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceState,\n+\t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n-\t\t\t\t\tmappings,\n+\t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n-\t\t\t\t\tmappings,\n+\t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn \u003d null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n-\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n+\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n-\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n+\t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n-\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n-\t\t\t\t\tnull :\n-\t\t\t\t\tcheckAnn.constraints();\n+\t\t\tString constraints \u003d checkAnn \u003d\u003d null\n+\t\t\t\t\t? null\n+\t\t\t\t\t: checkAnn.constraints();\n+\n+\t\t\tEntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable()\n+\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n+\t\t\t\t\t: null;\n+\n \t\t\tentityBinder.bindTable(\n-\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n-\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n-\t\t\t\t\t\t\tsuperEntity.getTable() :\n-\t\t\t\t\t\t\tnull\n+\t\t\t\t\tschema,\n+\t\t\t\t\tcatalog,\n+\t\t\t\t\ttable,\n+\t\t\t\t\tuniqueConstraints,\n+\t\t\t\t\tconstraints,\n+\t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n-\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n-\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\telse {\n+\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n+\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\t\t}\n+\n+\t\t\tif ( inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE ) {\n+\t\t\t\t// we at least need to properly set up the EntityTableXref\n+\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n+\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n+\t\t\t\t);\n+\t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n-\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n+\t\t\t\tentityBinder,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate \u003d true;\n \t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n-\t\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n+\t\t\t\tSimpleValue key \u003d new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n-\t\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n-\t\t\t\tmappings.addSecondPass( sp );\n-\t\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n+\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n+\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn !\u003d null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n         if ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n-\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n+\t\tHashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n-\t\t\t\tmappings\n+\t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n-\t\t\t\tmappings,\n+\t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n-\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n+\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n-\t\tmappings.addClass( persistentClass );\n+\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n-\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n+\t\tcontext.getMetadataCollector().addSecondPass(\n+\t\t\t\tnew SecondaryTableSecondPass(\n+\t\t\t\t\t\tentityBinder,\n+\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\tclazzToProcess\n+\t\t\t\t)\n+\t\t);\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "5329bba1ea724eabf5783c71e5127b8f84ad0fcc": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6911 - Write DiscriminatorValue to DiscriminatorColumn when combined with InheritanceType#JOINED\n",
      "commitDate": "2013-12-13, 1:57 a.m.",
      "commitName": "5329bba1ea724eabf5783c71e5127b8f84ad0fcc",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013-12-10, 8:33 p.m.",
      "commitNameOld": "637c8b4b08fab8c07406371a19c2674f67eb705d",
      "commitAuthorOld": "Brett Meyer",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\n\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tmappings,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess,\n\t\t\t\t\tmappings,\n\t\t\t\t\tinheritanceState,\n\t\t\t\t\tentityBinder\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tdiscriminatorColumn \u003d null;\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\n\t\t// todo : sucks that this is separate from RootClass distinction\n\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tonDeleteAppropriate \u003d true;\n\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\t\tjsc.setKey( key );\n\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t\t}\n\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t\t}\n\t\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\t\tmappings.addSecondPass( sp );\n\t\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\t\t\t}\n\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n\t\t\t\t\t// we have a discriminator column\n\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\t\tmappings\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( isInheritanceRoot ) {\n\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\t//bind it again since the type might have changed\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        if ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 574,
      "functionName": "bindClass",
      "diff": "@@ -1,212 +1,252 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n-\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n+\n+\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n-\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n-\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n+\t\t\tdiscriminatorColumn \u003d processSingleTableDiscriminatorProperties(\n+\t\t\t\t\tclazzToProcess,\n+\t\t\t\t\tmappings,\n+\t\t\t\t\tinheritanceState,\n+\t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n+\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n+\t\t\tdiscriminatorColumn \u003d processJoinedDiscriminatorProperties(\n+\t\t\t\t\tclazzToProcess,\n+\t\t\t\t\tmappings,\n+\t\t\t\t\tinheritanceState,\n+\t\t\t\t\tentityBinder\n+\t\t\t);\n+\t\t}\n+\t\telse {\n+\t\t\tdiscriminatorColumn \u003d null;\n+\t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n-\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n-\t\t\tonDeleteAppropriate \u003d true;\n-\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n-\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n-\t\t\tjsc.setKey( key );\n-\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n-\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n-\t\t\t\tkey.setForeignKeyName( fk.name() );\n-\t\t\t}\n-\t\t\tif ( onDeleteAnn !\u003d null ) {\n-\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tkey.setCascadeDeleteEnabled( false );\n-\t\t\t}\n-\t\t\t//we are never in a second pass at that stage, so queue it\n-\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n-\t\t\tmappings.addSecondPass( sp );\n-\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n+\t\t// todo : sucks that this is separate from RootClass distinction\n+\t\tfinal boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n+\t\tfinal boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n+\n+\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n+\t\t\tif ( inheritanceState.hasParents() ) {\n+\t\t\t\tonDeleteAppropriate \u003d true;\n+\t\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n+\t\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n+\t\t\t\tjsc.setKey( key );\n+\t\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n+\t\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n+\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n+\t\t\t\t}\n+\t\t\t\tif ( onDeleteAnn !\u003d null ) {\n+\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n+\t\t\t\t}\n+\t\t\t\t//we are never in a second pass at that stage, so queue it\n+\t\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n+\t\t\t\tmappings.addSecondPass( sp );\n+\t\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n+\t\t\t}\n+\n+\t\t\tif ( isInheritanceRoot ) {\n+\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n+\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n+\t\t\t\tif ( discriminatorColumn !\u003d null ) {\n+\t\t\t\t\t// we have a discriminator column\n+\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n+\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n+\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n+\t\t\t\t\t\t\t\tdiscriminatorColumn,\n+\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n+\t\t\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\t//bind it again since the type might have changed\n+\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n-\t\t\tif ( ! inheritanceState.hasParents() ) {\n-\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n-\t\t\t\t\t//need a discriminator column\n-\t\t\t\t\tbindDiscriminatorToPersistentClass(\n-\t\t\t\t\t\t\t( RootClass ) persistentClass,\n+\t\t\tif ( isInheritanceRoot ) {\n+\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n+\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n+\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n-\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n+\t\t\t\t\t//bind it again since the type might have changed\n+\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n-\t\t\t//nothing to do\n+\n+        if ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n+\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n-        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d9b7a06a52b56b84844513d97c535eb00d0ed8a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7969 initial @Table#indexes support\n",
      "commitDate": "2013-02-05, 11:09 a.m.",
      "commitName": "1d9b7a06a52b56b84844513d97c535eb00d0ed8a",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2012-12-25, 6:25 a.m.",
      "commitNameOld": "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 42.2,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tjavax.persistence.Table tabAnn \u003d null;\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( ! inheritanceState.hasParents() ) {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\t//nothing to do\n\t\t}\n        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 505,
      "functionName": "bindClass",
      "diff": "@@ -1,211 +1,212 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n+\t\tjavax.persistence.Table tabAnn \u003d null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n-\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n+\t\t\ttabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n-\n+\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09547a9051dd0ed851d8d6c5bd90841a93db2604": {
      "type": "Ybodychange",
      "commitMessage": "HHH-2394 Remove conditions that blocked filters on sub-classes (for annotations)\n",
      "commitDate": "2012-07-12, 10:58 a.m.",
      "commitName": "09547a9051dd0ed851d8d6c5bd90841a93db2604",
      "commitAuthor": "Rob Worsnop",
      "commitDateOld": "2012-06-01, 12:59 p.m.",
      "commitNameOld": "e26b8be6a5a935ae00e537c01c59a6fcb24fc67d",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 40.92,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( ! inheritanceState.hasParents() ) {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\t//nothing to do\n\t\t}\n        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 503,
      "functionName": "bindClass",
      "diff": "@@ -1,214 +1,211 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n-\t\t//Filters are not allowed on subclasses\n-\t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n-\t\t}\n+\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1569e6194b45038a210984d73d25079dd1482b3f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6974 Complete second level caching of natural id resolution\n",
      "commitDate": "2012-02-07, 9:34 a.m.",
      "commitName": "1569e6194b45038a210984d73d25079dd1482b3f",
      "commitAuthor": "Eric Dalquist",
      "commitDateOld": "2012-02-07, 9:34 a.m.",
      "commitNameOld": "c47352058541e14e0b80d38f94c65d939d5394f5",
      "commitAuthorOld": "Eric Dalquist",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( ! inheritanceState.hasParents() ) {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\t//nothing to do\n\t\t}\n        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 502,
      "functionName": "bindClass",
      "diff": "@@ -1,214 +1,214 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n-\t    entityBinder.setNaturalIdCache( clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n+\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c47352058541e14e0b80d38f94c65d939d5394f5": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6974 Class level naturalId cache and stats\n\nAdd class level @NaturalIdCache annotation to denote if second level natualId caching should be done\nFlush out stats model for naturalId cache related stats\nAdd ehcache support classes for naturalId region\n",
      "commitDate": "2012-02-07, 9:34 a.m.",
      "commitName": "c47352058541e14e0b80d38f94c65d939d5394f5",
      "commitAuthor": "Eric Dalquist",
      "commitDateOld": "2011-11-23, 5:51 a.m.",
      "commitNameOld": "6c7379c38f8b6b43c13791b29cd09b1f4a26bd8e",
      "commitAuthorOld": "Sanne Grinovero",
      "daysBetweenCommits": 76.15,
      "commitsBetweenForRepo": 206,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\t    entityBinder.setNaturalIdCache( clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( ! inheritanceState.hasParents() ) {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\t//nothing to do\n\t\t}\n        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 502,
      "functionName": "bindClass",
      "diff": "@@ -1,213 +1,214 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n+\t    entityBinder.setNaturalIdCache( clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "129c0f13482b99e2705f0e234b6bc0572a95c271": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6732 more logging trace statements are missing guards against unneeded string creation\n",
      "commitDate": "2011-10-26, 6:24 p.m.",
      "commitName": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "commitAuthor": "Sanne Grinovero",
      "commitDateOld": "2011-10-24, 4:26 a.m.",
      "commitNameOld": "bdba5898c90ef7667e7c5df35e72d2e993e32556",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\t\t}\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n\t\t}\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( ! inheritanceState.hasParents() ) {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\t//nothing to do\n\t\t}\n        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 501,
      "functionName": "bindClass",
      "diff": "@@ -1,208 +1,213 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n-        LOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n+\t\tif ( LOG.isDebugEnabled() ) {\n+\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n+\t\t}\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n-        } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n+\t\t}\n+\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n+\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\t}\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a351c520205d18f18bc1c47091b4a62629f19de1": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6724 Move persister binding for class hierarchies to PersisterClassResolver out of {Hbm|Annotation}Binder",
      "commitDate": "2011-10-11, 8:13 p.m.",
      "commitName": "a351c520205d18f18bc1c47091b4a62629f19de1",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2011-06-28, 4:29 a.m.",
      "commitNameOld": "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 105.66,
      "commitsBetweenForRepo": 324,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n        LOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n        } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( ! inheritanceState.hasParents() ) {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\t//nothing to do\n\t\t}\n        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 492,
      "functionName": "bindClass",
      "diff": "@@ -1,220 +1,208 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n         LOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n         } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n-\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n-\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n-\t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n-\t\t\tif ( inheritanceState.hasParents() ) {\n-\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n-\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n+\t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n-\t\t\tif ( inheritanceState.hasParents() ) {\n-\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n-\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad17f89c4c29f0327c843cf5265e156d65743ab1": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6097 - Review log levels, especially related to i18n messages\n",
      "commitDate": "2011-04-12, 10:07 a.m.",
      "commitName": "ad17f89c4c29f0327c843cf5265e156d65743ab1",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011-04-11, 10:59 p.m.",
      "commitNameOld": "62da5aa5bc2600252399060a0c48d32505b879ac",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n        LOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n        } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 494,
      "functionName": "bindClass",
      "diff": "@@ -1,220 +1,220 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n-        LOG.bindingEntityFromClass( clazzToProcess.getName() );\n+        LOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n         } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n \n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n         if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": {
      "type": "Ybodychange",
      "commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n\u0027d where it was clear how to do so.\n",
      "commitDate": "2011-01-18, 4:35 p.m.",
      "commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthor": "JPAV",
      "commitDateOld": "2010-10-11, 3:41 p.m.",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 99.08,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n        LOG.bindingEntityFromClass(clazzToProcess.getName());\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n        } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 502,
      "functionName": "bindClass",
      "diff": "@@ -1,231 +1,220 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n-\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n+\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n+        LOG.bindingEntityFromClass(clazzToProcess.getName());\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n-\t\t}\n-\t\telse {\n-\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n-\t\t\t\tlog.warn(\n-\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n-\t\t\t\t\t\t\t\t.getName()\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n+        } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n+\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n-\t\t\tlog.warn(\n-\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n-\t\t\t);\n-\t\t}\n+        if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
      "commitDate": "2010-10-11, 3:41 p.m.",
      "commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-10-11, 2:51 p.m.",
      "commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 506,
      "functionName": "bindClass",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
      }
    },
    "bf7607e24495af5133165ae6ed6b85feecf59148": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5190 - Introduced new annotation @DiscriminatorOptions and deprecated @ForceDiscriminator\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20749 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-09-29, 6:45 a.m.",
      "commitName": "bf7607e24495af5133165ae6ed6b85feecf59148",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010-09-28, 12:28 p.m.",
      "commitNameOld": "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
      "commitAuthorOld": "Hardy Ferentschik",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n\t\t\t);\n\t\t}\n\n\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 506,
      "functionName": "bindClass",
      "diff": "@@ -1,261 +1,231 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n+\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n+\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n+\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n+\t\t\t\torg.hibernate.annotations.Entity.class\n+\t\t);\n+\t\tEntityBinder entityBinder \u003d new EntityBinder(\n+\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n+\t\t);\n+\t\tentityBinder.setInheritanceState( inheritanceState );\n+\n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n-\t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n-\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n-\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n+\t\t\tdiscriminatorColumn \u003d processDiscriminatorProperties(\n+\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n-\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n-\t\t\t\t\tdiscAnn.discriminatorType() :\n-\t\t\t\t\tDiscriminatorType.STRING;\n-\n-\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n-\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n-\t\t\t);\n-\t\t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n-\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n-\t\t\t\tlog.warn(\n-\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n-\t\t\t\t\t\tclazzToProcess.getName()\n-\t\t\t\t);\n-\t\t\t}\n-\n-\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n-\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n-\t\t\t\t\tnull;\n \t\t}\n \n-\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n-\n-\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n-\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n-\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n-\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n-\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n-\t\t\t\torg.hibernate.annotations.Entity.class\n-\t\t);\n-\n-\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n-\n-\t\tEntityBinder entityBinder \u003d new EntityBinder(\n-\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n-\t\t);\n-\t\tentityBinder.setDiscriminatorValue( discrimValue );\n-\t\tentityBinder.setBatchSize( sizeAnn );\n-\t\tentityBinder.setProxy( proxyAnn );\n-\t\tentityBinder.setWhere( whereAnn );\n-\t\tentityBinder.setCache( cacheAnn );\n-\t\tentityBinder.setInheritanceState( inheritanceState );\n+\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n+\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n+\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n+\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5205 - Added @Source and emum SourceType, fixed implementation and added a test\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20740 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-09-28, 12:28 p.m.",
      "commitName": "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010-08-26, 5:00 p.m.",
      "commitNameOld": "232a77e5ddfa3eaf59034a7e55fd52debeb0242a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 32.81,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 504,
      "functionName": "bindClass",
      "diff": "@@ -1,261 +1,261 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n-\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n+\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f": {
      "type": "Yparameterchange",
      "commitMessage": "HHH-5474 - Clean up usages of now deprecated ExtendedMappings\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20136 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-08-12, 3:13 p.m.",
      "commitName": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-07-08, 7:56 p.m.",
      "commitNameOld": "df184979ed2f19887bbea46603148dd59d3bfd1f",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 34.8,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess,\n\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n\t\t\tMappings mappings) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 502,
      "functionName": "bindClass",
      "diff": "@@ -1,260 +1,261 @@\n \tpublic static void bindClass(\n-\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n-\t) throws MappingException {\n+\t\t\tXClass clazzToProcess,\n+\t\t\tMap\u003cXClass, InheritanceState\u003e inheritanceStatePerClass,\n+\t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map\u003cXClass,InheritanceState\u003e, mappings-ExtendedMappings]",
        "newValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map\u003cXClass,InheritanceState\u003e, mappings-Mappings]"
      }
    },
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5367 - Move annotations module sources into core module\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19921 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-07-08, 7:41 p.m.",
      "commitName": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-07-08, 1:32 p.m.",
      "commitNameOld": "cc3b41a09c983913594b16d6c909be0bfd41bd7a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 503,
      "functionName": "bindClass",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
        "newPath": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
      }
    },
    "421789ddcd906e806bf901fea9d9e713daebd51a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5138 - Redesign types + introduce TypeRegistry \u0026 TypeResolver\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19335 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-05-01, 2:20 p.m.",
      "commitName": "421789ddcd906e806bf901fea9d9e713daebd51a",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-04-27, 4:38 a.m.",
      "commitNameOld": "b912a95d5422d6ce91c8b89aecb6b3923626e9c7",
      "commitAuthorOld": "Sharath Reddy",
      "daysBetweenCommits": 4.4,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\t\tmappings\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 504,
      "functionName": "bindClass",
      "diff": "@@ -1,259 +1,260 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n \t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n-\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n+\t\t\tSimpleValue key \u003d new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n-\t\t\t\t\t\t\tpropertyHolder\n+\t\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "422ecc653a7d78ee0464478750a076710b697849": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5125 Raise proper exception when @Entity and @MappedSuperclass are present on the same class\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19241 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-04-16, 6:11 a.m.",
      "commitName": "422ecc653a7d78ee0464478750a076710b697849",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-03-04, 4:55 p.m.",
      "commitNameOld": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
      "commitAuthorOld": "Hardy Ferentschik",
      "daysBetweenCommits": 42.51,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n\t\t\t\t\t+ clazzToProcess.getName() );\n\t\t}\n\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 504,
      "functionName": "bindClass",
      "diff": "@@ -1,252 +1,259 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n+\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n+\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n+\t\t\t\t\u0026\u0026  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n+\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n+\t\t\t\t\t+ clazzToProcess.getName() );\n+\t\t}\n+\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "153ad753e19b1f71665e6cfcbd903fb1ced889db": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4812\nAdded @FetchProfile and @FetchProfiles annotations and wired them up. Added also some error handling in the AnnotationBinder.\nRefactor the handling of precedence in the AnnotationConfiguration, because I thought I would be reusing it for the fetch profile as well, but in the end decided to jsut implement in a way that xml configured fetch profiles always win over annotation confgured ones.\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18924 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-03-04, 4:55 p.m.",
      "commitName": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010-02-18, 4:59 a.m.",
      "commitNameOld": "b5529c05a56106ddf3d582355a4b07ac3d6510d0",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 14.5,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\t}\n\n\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(\n\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n\t\t);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tbindFetchProfiles( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n\t\t);\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t( RootClass ) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif ( !isIdClass ) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 504,
      "functionName": "bindClass",
      "diff": "@@ -1,245 +1,252 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n-\t\t\tbindTypeDefs(clazzToProcess, mappings);\n-\t\t\tbindFilterDefs(clazzToProcess, mappings);\n+\t\t\tbindTypeDefs( clazzToProcess, mappings );\n+\t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n-\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n+\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n-\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+\t\tPersistentClass superEntity \u003d getSuperEntity(\n+\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n+\t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n+\t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n-\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n+\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(\n+\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n+\t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n+\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n-\t\t\t\t\tsuperEntity.getTable() :\n-\t\t\t\t\tnull\n+\t\t\t\t\t\t\tsuperEntity.getTable() :\n+\t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n-\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n-\t\t\t\t\t\t.getName() );\n+\t\t\t\tlog.warn(\n+\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n+\t\t\t\t\t\t\t\t.getName()\n+\t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n-\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n+\t\t\tfinal JoinedSubclass jsc \u003d ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n-\t\t\t\t\t\t\t(RootClass) persistentClass,\n+\t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n \t\tboolean isIdClass \u003d mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n-\t\tif (!isIdClass) {\n+\t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n+\t\t\tfinal RootClass rootClass \u003d ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n-\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n+\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4848 finish support for derived identity Yeah! More specifically @IdClass on dependent where the @IdClass points to the associated entity id type\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18708 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-02-05, 6:33 p.m.",
      "commitName": "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-02-05, 1:28 p.m.",
      "commitNameOld": "5c16c01064f4e2970860c5da47d0f0425aefac02",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n\t\tboolean isIdClass \u003d mapAsIdClass(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tinheritanceState,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\telementsToProcess,\n\t\t\t\tidPropertiesIfIdClass,\n\t\t\t\tmappings\n\t\t);\n\n\t\tif (!isIdClass) {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\n\t\tprocessIdPropertiesIfNotAlready(\n\t\t\t\tinheritanceStatePerClass,\n\t\t\t\tmappings,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder,\n\t\t\t\tpropertyHolder,\n\t\t\t\tclassGenerators,\n\t\t\t\telementsToProcess,\n\t\t\t\tsubclassAndSingleTableStrategy,\n\t\t\t\tidPropertiesIfIdClass\n\t\t);\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 487,
      "functionName": "bindClass",
      "diff": "@@ -1,335 +1,245 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n-\t\t//process idclass if any\n-\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n-\t\tXClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n-\t\tif ( classWithIdClass !\u003d null ) {\n-\t\t\tIdClass idClass \u003d classWithIdClass.getAnnotation( IdClass.class );\n-\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n-\t\t\tboolean isComponent \u003d true;\n-\t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n-\t\t\tString generatorType \u003d \"assigned\";\n-\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n-\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n-\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n-\t\t\t);\n-\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n-                  entityBinder.getPropertyAccessType(), \"id\", classWithIdClass\n-            );\n-\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n-\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n-\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n-\t\t\tpropertyHolder.setInIdClass( true );\n-\t\t\tbindId(\n-\t\t\t\t\tgeneratorType,\n-\t\t\t\t\tgenerator,\n-\t\t\t\t\tinferredData,\n-\t\t\t\t\tbaseInferredData,\n-\t\t\t\t\tnull,\n-\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\tlocalGenerators,\n-\t\t\t\t\tisComponent,\n-\t\t\t\t\tpropertyAccessor, entityBinder,\n-\t\t\t\t\ttrue,\n-\t\t\t\t\tfalse,\n-\t\t\t\t\tmappings,\n-\t\t\t\t\tinheritanceStatePerClass\n-\t\t\t);\n-\t\t\tpropertyHolder.setInIdClass( null );\n-\t\t\tinferredData \u003d new PropertyPreloadedData(\n-\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n-\t\t\t);\n-\t\t\tComponent mapper \u003d fillComponent(\n-\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\tinferredData,\n-\t\t\t\t\tbaseInferredData,\n-\t\t\t\t\tpropertyAccessor,\n-\t\t\t\t\tfalse,\n-\t\t\t\t\tentityBinder,\n-\t\t\t\t\ttrue,\n-\t\t\t\t\ttrue,\n-\t\t\t\t\tfalse,\n-\t\t\t\t\tmappings,\n-\t\t\t\t\tinheritanceStatePerClass\n-\t\t\t);\n-\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n-\t\t\tpersistentClass.setIdentifierMapper( mapper );\n+\t\tSet\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n+\t\tboolean isIdClass \u003d mapAsIdClass(\n+\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\tinheritanceState,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tentityBinder,\n+\t\t\t\tpropertyHolder,\n+\t\t\t\telementsToProcess,\n+\t\t\t\tidPropertiesIfIdClass,\n+\t\t\t\tmappings\n+\t\t);\n \n-\t\t\t//If id definition is on a mapped superclass, update the mapping\n-\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n-\t\t\t\t\tinferredData.getDeclaringClass(),\n-\t\t\t\t\tinheritanceStatePerClass,\n-\t\t\t\t\tmappings\n-\t\t\t);\n-\t\t\tif (superclass !\u003d null) {\n-\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\t//we are for sure on the entity\n-\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n-\t\t\t}\n-\n-\t\t\tProperty property \u003d new Property();\n-\t\t\tproperty.setName( \"_identifierMapper\" );\n-\t\t\tproperty.setNodeName( \"id\" );\n-\t\t\tproperty.setUpdateable( false );\n-\t\t\tproperty.setInsertable( false );\n-\t\t\tproperty.setValue( mapper );\n-\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n-\t\t\tpersistentClass.addProperty( property );\n-\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n-\n-\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n-\t\t\twhile ( properties.hasNext() ) {\n-\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n-\t\t\t}\n-\t\t}\n-\t\telse {\n+\t\tif (!isIdClass) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n-\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n-\t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n-\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n-\t\t\tif ( !idProperties.contains( propertyName ) ) {\n-\t\t\t\tprocessElementAnnotations(\n-\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n-\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n-\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n-\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n-\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n-\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tmissingIdProperties.remove( propertyName );\n-\t\t\t}\n-\t\t}\n \n-\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n-\t\t\tStringBuilder missings \u003d new StringBuilder();\n-\t\t\tfor (String property : missingIdProperties) {\n-\t\t\t\tmissings.append( property ).append( \", \" );\n-\t\t\t}\n-\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\"Unable to find properties (\"\n-\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n-\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n-\t\t\t);\n-\t\t}\n+\t\tprocessIdPropertiesIfNotAlready(\n+\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\tmappings,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tentityBinder,\n+\t\t\t\tpropertyHolder,\n+\t\t\t\tclassGenerators,\n+\t\t\t\telementsToProcess,\n+\t\t\t\tsubclassAndSingleTableStrategy,\n+\t\t\t\tidPropertiesIfIdClass\n+\t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "252299cfee96892b71b3bd3e200181089e350e27": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4848 partial implementation of @IdClass support in derivedidentity (example 1 case a of the spec)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18692 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-02-04, 12:54 p.m.",
      "commitName": "252299cfee96892b71b3bd3e200181089e350e27",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-01-27, 1:58 p.m.",
      "commitNameOld": "016a02ff506b715e8217b8577594ac62b3f318ce",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 7.96,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tXClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n\t\tif ( classWithIdClass !\u003d null ) {\n\t\t\tIdClass idClass \u003d classWithIdClass.getAnnotation( IdClass.class );\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessType(), \"id\", classWithIdClass\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tpropertyHolder.setInIdClass( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tmappings,\n\t\t\t\t\tinheritanceStatePerClass\n\t\t\t);\n\t\t\tpropertyHolder.setInIdClass( null );\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAccessor,\n\t\t\t\t\tfalse,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tmappings,\n\t\t\t\t\tinheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 486,
      "functionName": "bindClass",
      "diff": "@@ -1,331 +1,335 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tXClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n \t\tif ( classWithIdClass !\u003d null ) {\n \t\t\tIdClass idClass \u003d classWithIdClass.getAnnotation( IdClass.class );\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessType(), \"id\", classWithIdClass\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n+\t\t\tpropertyHolder.setInIdClass( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse,\n \t\t\t\t\tmappings,\n \t\t\t\t\tinheritanceStatePerClass\n \t\t\t);\n+\t\t\tpropertyHolder.setInIdClass( null );\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAccessor,\n \t\t\t\t\tfalse,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\ttrue,\n-\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n+\t\t\t\t\tfalse,\n+\t\t\t\t\tmappings,\n+\t\t\t\t\tinheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass !\u003d null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5ee9ba361c96c29b06542720cb8b01e1034d8544": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4529 Add support for parent\u0027s id being an IdClass or an EmbeddedId (last case not tested yet). (example e2.b)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18625 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-26, 7:57 a.m.",
      "commitName": "5ee9ba361c96c29b06542720cb8b01e1034d8544",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-01-25, 12:19 p.m.",
      "commitNameOld": "d00f7efb308fab613b4918f9b8831f07602c6bd0",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tXClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n\t\tif ( classWithIdClass !\u003d null ) {\n\t\t\tIdClass idClass \u003d classWithIdClass.getAnnotation( IdClass.class );\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessType(), \"id\", classWithIdClass\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tmappings,\n\t\t\t\t\tinheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAccessor,\n\t\t\t\t\tfalse,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 433,
      "functionName": "bindClass",
      "diff": "@@ -1,345 +1,331 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n-\t\tfinal ElementsToProcess elementsToProcess \u003d getElementsToProcess(\n-\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n-\t\t);\n-\t\t\n+\t\tfinal InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n+\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n+\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n-\t\tIdClass idClass \u003d null;\n-\t\tXClass current \u003d null;\n-\t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\t//look for idClass\n-\t\t\tInheritanceState state \u003d inheritanceState;\n-\t\t\tdo {\n-\t\t\t\tcurrent \u003d state.getClazz();\n-\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n-\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n-\t\t\t}\n-\t\t\twhile ( state !\u003d null );\n-\t\t}\n-\t\tif ( idClass !\u003d null ) {\n+\t\tXClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n+\t\tif ( classWithIdClass !\u003d null ) {\n+\t\t\tIdClass idClass \u003d classWithIdClass.getAnnotation( IdClass.class );\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n-                  entityBinder.getPropertyAccessType(), \"id\", current\n+                  entityBinder.getPropertyAccessType(), \"id\", classWithIdClass\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse,\n \t\t\t\t\tmappings,\n \t\t\t\t\tinheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAccessor,\n \t\t\t\t\tfalse,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass !\u003d null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d00f7efb308fab613b4918f9b8831f07602c6bd0": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4529 support for derived entity id as a XToOne pointing to the master entity\nHHH-4840 support for Core style embedded id (after all these years :) )\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18619 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-25, 12:19 p.m.",
      "commitName": "d00f7efb308fab613b4918f9b8831f07602c6bd0",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-01-24, 12:07 p.m.",
      "commitNameOld": "5d8d70036a139f954e7b572a649ab52d4b930692",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tfinal ElementsToProcess elementsToProcess \u003d getElementsToProcess(\n\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n\t\t);\n\t\t\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t//look for idClass\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.getClazz();\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessType(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse,\n\t\t\t\t\tmappings,\n\t\t\t\t\tinheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAccessor,\n\t\t\t\t\tfalse,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 434,
      "functionName": "bindClass",
      "diff": "@@ -1,338 +1,345 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n-\t\tList\u003cPropertyData\u003e elements \u003d\n-\t\t\t\tgetElementsToProcess(\n-\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n-\t\t\t\t);\n+\t\tfinal ElementsToProcess elementsToProcess \u003d getElementsToProcess(\n+\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n+\t\t);\n+\t\t\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessType(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n-\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n+\t\t\t\t\tfalse,\n+\t\t\t\t\tmappings,\n+\t\t\t\t\tinheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n-\t\t\t\t\tpropertyAccessor, false,\n+\t\t\t\t\tpropertyAccessor,\n+\t\t\t\t\tfalse,\n \t\t\t\t\tentityBinder,\n-\t\t\t\t\ttrue, true,\n+\t\t\t\t\ttrue,\n+\t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass !\u003d null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n+\t\telse {\n+\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() \u003e 1 );\n+\t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n-\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n+\t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d24ed1a1d39c1458d020a27a504a46e76dfe2e26": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4659 - Add support for standard declarative cache (@Cacheable)\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18605 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-22, 2:22 a.m.",
      "commitName": "d24ed1a1d39c1458d020a27a504a46e76dfe2e26",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-01-21, 12:51 p.m.",
      "commitNameOld": "8577a68e69d30d9e671024bf3330616000a3ec54",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\n\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n\t\t\t\t);\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t//look for idClass\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.getClazz();\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessType(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 434,
      "functionName": "bindClass",
      "diff": "@@ -1,338 +1,338 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n-\t\torg.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(\n-\t\t\t\torg.hibernate.annotations.Cache.class\n-\t\t);\n+\n+\t\tCache cacheAnn \u003d determineCacheSettings( clazzToProcess, mappings );\n+\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n \t\t\t\t);\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessType(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass !\u003d null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dd470af1f453e54643d55b2c81ec5a7324952b1": {
      "type": "Ybodychange",
      "commitMessage": " HHH-4527 - added handling of proper default access propagation for class hierarchies and embedded classes (components)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18417 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-05, 4:51 p.m.",
      "commitName": "2dd470af1f453e54643d55b2c81ec5a7324952b1",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010-01-04, 1:50 p.m.",
      "commitNameOld": "43dd13073d76e3ad1388f280aeff6f078f8db79f",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t// try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n\t\t\t\t);\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t//look for idClass\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.getClazz();\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessType(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 428,
      "functionName": "bindClass",
      "diff": "@@ -1,343 +1,338 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n-\t\t//try to find class level generators\n+\t\t// try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n \t\t\t\t);\n-\t\tif ( elements \u003d\u003d null ) {\n-\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n-\t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n-\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n-\t\t\t\t);\n+\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n-\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n+\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n-                  entityBinder.getPropertyAccessor(), \"id\", current\n+                  entityBinder.getPropertyAccessType(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass !\u003d null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09": {
      "type": "Ybodychange",
      "commitMessage": " HHH-4527 - first cut for supporting JPA2 @Access annotation. Not quite complete and needs some more tests.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18260 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-12-17, 4:14 p.m.",
      "commitName": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2009-12-11, 2:14 p.m.",
      "commitNameOld": "025b3cc14180d0459856bc45a6cac7acce3e1265",
      "commitAuthorOld": "Hardy Ferentschik",
      "daysBetweenCommits": 6.08,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t//look for idClass\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.getClazz();\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessor(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 431,
      "functionName": "bindClass",
      "diff": "@@ -1,346 +1,343 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tString discrimValue \u003d null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n-\t\t\n+\n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n-\t\t\n+\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n-\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n+\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n-\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n-\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n+\t\t\tAccessType propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n-\t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n-\t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass !\u003d null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "025b3cc14180d0459856bc45a6cac7acce3e1265": {
      "type": "Ybodychange",
      "commitMessage": " HHH-4527\nNo functional changes yet. Just some cleanup and refactoring (extract method, encapsulate field)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18211 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-12-11, 2:14 p.m.",
      "commitName": "025b3cc14180d0459856bc45a6cac7acce3e1265",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2009-12-10, 4:32 a.m.",
      "commitNameOld": "ba3639a25a2e3a59b2252aab1d20b0addb178864",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 1.4,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\n\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n\n\t\tbindQueries( clazzToProcess, mappings );\n\t\tbindFilterDefs( clazzToProcess, mappings );\n\t\tbindTypeDefs( clazzToProcess, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tString discrimValue \u003d null;\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n\n\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\t\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\t\t\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n\t\t\tif ( inheritanceState.hasParents() ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\t//look for idClass\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.getClazz();\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessor(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents() ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 428,
      "functionName": "bindClass",
      "diff": "@@ -1,431 +1,346 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n-\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n-\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n-\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n-\t\t\t\t) {\n-\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n-\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n-\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n-\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n-\t\t\t}\n+\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n-\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n-\t\t\t//TODO make this test accurate by removing the none elements artifically added\n-\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n-\t\t\t\t\t\t\t.getName()\n-\t\t\t);\n-\t\t}\n-\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n+\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n-\t\tfinal ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n-\t\tInheritanceState superEntityState \u003d\n-\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n-\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n-\t\t\t\t);\n-\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n-\t\t\t\tmappings.getClass(\n-\t\t\t\t\t\tsuperEntityState.clazz.getName()\n-\t\t\t\t) :\n-\t\t\t\tnull;\n-\t\tif ( superEntity \u003d\u003d null ) {\n-\t\t\t//check if superclass is not a potential persistent class\n-\t\t\tif ( inheritanceState.hasParents ) {\n-\t\t\t\tthrow new AssertionFailure(\n-\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n-\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n-\t\tbindQueries( annotatedClass, mappings );\n-\t\tbindFilterDefs( annotatedClass, mappings );\n-\t\tbindTypeDefs( annotatedClass, mappings );\n-\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n+\n+\t\tPersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+\n+\t\tbindQueries( clazzToProcess, mappings );\n+\t\tbindFilterDefs( clazzToProcess, mappings );\n+\t\tbindTypeDefs( clazzToProcess, mappings );\n+\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n-\t\tString discrimValue \u003d null;\n \t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n-\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n-\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n-\n-\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n-\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n+\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n+\t\t\tjavax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n-\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n-\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n-\t\tif ( hasJoinedColumns ) {\n-\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n-\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n-\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n-\t\t\tif ( explicitInheritanceJoinedColumns ) {\n-\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n-\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n-\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n-\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n-\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n-\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n-\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n-\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n-\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n-\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n-\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n-\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n-\t\t}\n-\t\telse {\n-\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n-\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n-\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n-\t\t\t}\n-\t\t}\n \n-\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n-\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n+\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n+\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n+\t\tString discrimValue \u003d null;\n+\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n+\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n-\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n+\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n-\t\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n-\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n+\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n-\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n-\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n+\n+\t\t\tdiscrimValue \u003d clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n+\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n-\t\t//we now know what kind of persistent entity it is\n-\t\tPersistentClass persistentClass;\n-\t\t//create persistent class\n-\t\tif ( !inheritanceState.hasParents ) {\n-\t\t\tpersistentClass \u003d new RootClass();\n-\t\t}\n-\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n-\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n-\t\t}\n-\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n-\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n-\t\t}\n-\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n-\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n-\t\t}\n-\t\telse {\n-\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n-\t\t}\n-\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n-\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n-\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n-\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n-\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n+\t\tPersistentClass persistentClass \u003d makePersistentClass( inheritanceState, superEntity );\n+\n+\t\tProxy proxyAnn \u003d clazzToProcess.getAnnotation( Proxy.class );\n+\t\tBatchSize sizeAnn \u003d clazzToProcess.getAnnotation( BatchSize.class );\n+\t\tWhere whereAnn \u003d clazzToProcess.getAnnotation( Where.class );\n+\t\tEntity entityAnn \u003d clazzToProcess.getAnnotation( Entity.class );\n+\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n-\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n+\t\torg.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\t\n \t\t//Filters are not allowed on subclasses\n-\t\tif ( !inheritanceState.hasParents ) {\n+\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n-\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n+\t\t\tCheck checkAnn \u003d clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n-\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n+\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n-//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n-//\t\t\t\tclazzToProcess,\n-//\t\t\t\tpersistentClass.getClassName()\n-//\t\t);\n+\n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n-\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n+\t\tjavax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n-\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n+\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n-\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n+\t\tOnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n-\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n+\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) \u0026\u0026 inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n-\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n+\t\t\tForeignKey fk \u003d clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n-\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n-\t\t\tif ( inheritanceState.hasParents ) {\n+\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n+\t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n+\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n-\t\t\tif ( inheritanceState.hasParents ) {\n+\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n+\t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n-\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n+\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n-\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n-\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n+\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE\n+\t\t\t\t\u0026\u0026 inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n-\t\tif ( !inheritanceState.hasParents ) {\n+\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n-\t\t\tcurrent \u003d inheritanceState.clazz;\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n-\t\t\t\tcurrent \u003d state.clazz;\n+\t\t\t\tcurrent \u003d state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n-\t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n+\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n-\t\t\tXClass compositeClass \u003d reflectionManager.toXClass( idClass.value() );\n+\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass !\u003d null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n-\t\tif ( !inheritanceState.hasParents ) {\n+\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n-\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n+\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n-\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n-\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n+\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n+\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4553 - Hibernate doesn\u0027t support official JPA2 escape char for table name\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18148 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-12-06, 5:20 p.m.",
      "commitName": "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2009-11-30, 11:50 a.m.",
      "commitNameOld": "6458ff4771ab9ed37bddb783148aff82e40cd600",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 6.23,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tfinal ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\t\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\t\t\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tcurrent \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d reflectionManager.toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessor(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 427,
      "functionName": "bindClass",
      "diff": "@@ -1,431 +1,431 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tfinal ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n \t\tInheritanceState superEntityState \u003d\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity \u003d\u003d null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tString discrimValue \u003d null;\n-\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n+\t\tList\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n-\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n+\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n \t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass \u003d new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\t\n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tcurrent \u003d inheritanceState.clazz;\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d reflectionManager.toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass !\u003d null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4533 Populate the JPA 2 metamodel with the new mapping.MappedSuperclass metadata\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17879 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-10-29, 2:57 p.m.",
      "commitName": "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009-10-28, 8:36 p.m.",
      "commitNameOld": "1352b5e25f330f2838e27fb8b5ba1c05d4b8c8ab",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tfinal ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\t\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\t\t\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tcurrent \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d reflectionManager.toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessor(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\n\t\t\t//If id definition is on a mapped superclass, update the mapping\n\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n\t\t\t\t\tinferredData.getDeclaringClass(),\n\t\t\t\t\tinheritanceStatePerClass,\n\t\t\t\t\tmappings\n\t\t\t);\n\t\t\tif (superclass !\u003d null) {\n\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//we are for sure on the entity\n\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n\t\t\t}\n\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "diff": "@@ -1,416 +1,431 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tfinal ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n \t\tInheritanceState superEntityState \u003d\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity \u003d\u003d null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tString discrimValue \u003d null;\n \t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n \t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass \u003d new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\t\n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tcurrent \u003d inheritanceState.clazz;\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d reflectionManager.toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n+\n+\t\t\t//If id definition is on a mapped superclass, update the mapping\n+\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(\n+\t\t\t\t\tinferredData.getDeclaringClass(),\n+\t\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\t\tmappings\n+\t\t\t);\n+\t\t\tif (superclass !\u003d null) {\n+\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t//we are for sure on the entity\n+\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n+\t\t\t}\n+\n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7c6981a558e35f01ff8d27938e98aa83896765c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4533 add representation for @MappedSuperclass in the Hibernate Core metamodel and properly populate this model extension in Hibernate Annotations\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17871 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-10-28, 2:14 p.m.",
      "commitName": "c7c6981a558e35f01ff8d27938e98aa83896765c",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009-10-28, 6:57 a.m.",
      "commitNameOld": "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
      "commitAuthorOld": "Sharath Reddy",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tfinal ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\t\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\t\t\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tcurrent \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d reflectionManager.toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessor(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "diff": "@@ -1,415 +1,416 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n+\t\tfinal ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n \t\tInheritanceState superEntityState \u003d\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n-\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n+\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity \u003d\u003d null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tString discrimValue \u003d null;\n \t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n \t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass \u003d new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\t\n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n-\t\t\t\tentityBinder, mappings\n+\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n-\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n+\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tcurrent \u003d inheritanceState.clazz;\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n-\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n+\t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n-\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n+\t\t\tXClass compositeClass \u003d reflectionManager.toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n-\t\t\t\t\tfalse, mappings\n+\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n-\t\t\t\t\tfalse, mappings\n+\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n-\t\t\t\t\t\tfalse, false, false, mappings\n+\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4332 Filters for MappedSuperClass\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17859 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-10-28, 6:57 a.m.",
      "commitName": "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
      "commitAuthor": "Sharath Reddy",
      "commitDateOld": "2009-10-27, 11:05 a.m.",
      "commitNameOld": "2176af11442c702aefa1900cdba4c32e6338b620",
      "commitAuthorOld": "Hardy Ferentschik",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t\tbindFilterDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\t\n\t\t//Filters are not allowed on subclasses\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n\t\t}\n\t\t\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tcurrent \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessor(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "diff": "@@ -1,418 +1,415 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n+\t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tInheritanceState superEntityState \u003d\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity \u003d\u003d null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tString discrimValue \u003d null;\n \t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n \t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass \u003d new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n-\t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n-\t\tif ( filterAnn !\u003d null ) {\n-\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n+\t\t\n+\t\t//Filters are not allowed on subclasses\n+\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n-\t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n-\t\tif ( filtersAnn !\u003d null ) {\n-\t\t\tfor (Filter filter : filtersAnn.value()) {\n-\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n-\t\t\t}\n-\t\t}\n+\t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tcurrent \u003d inheritanceState.clazz;\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2176af11442c702aefa1900cdba4c32e6338b620": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4528 - Applied patch (with minor cleanup)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17849 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-10-27, 11:05 a.m.",
      "commitName": "2176af11442c702aefa1900cdba4c32e6338b620",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2009-10-21, 1:16 p.m.",
      "commitNameOld": "d26c00225847f5b4e869146188e3e80914367d7a",
      "commitAuthorOld": "Sharath Reddy",
      "daysBetweenCommits": 5.91,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n\t\tif ( filterAnn !\u003d null ) {\n\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n\t\t}\n\t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n\t\tif ( filtersAnn !\u003d null ) {\n\t\t\tfor (Filter filter : filtersAnn.value()) {\n\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n\t\t\t}\n\t\t}\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tXClass current \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tcurrent \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n                  entityBinder.getPropertyAccessor(), \"id\", current\n            );\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tbaseInferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "diff": "@@ -1,412 +1,418 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tInheritanceState superEntityState \u003d\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity \u003d\u003d null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tString discrimValue \u003d null;\n \t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n \t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass \u003d new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n \t\tif ( filterAnn !\u003d null ) {\n \t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n \t\t}\n \t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n \t\tif ( filtersAnn !\u003d null ) {\n \t\t\tfor (Filter filter : filtersAnn.value()) {\n \t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n \t\t\t}\n \t\t}\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n+\t\tXClass current \u003d null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n-\t\t\tXClass current \u003d inheritanceState.clazz;\n+\t\t\tcurrent \u003d inheritanceState.clazz;\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n+\t\t\tPropertyData baseInferredData \u003d new PropertyPreloadedData(\n+                  entityBinder.getPropertyAccessor(), \"id\", current\n+            );\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n+\t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n+\t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4232 TypeDef support when used on @Embeddable or @MappedSuperClass classes\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17531 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-09-22, 1:43 p.m.",
      "commitName": "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009-09-22, 1:19 p.m.",
      "commitNameOld": "88caf4d9586e988675254c268f4e145d272a9499",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n\t\t\tbindQueries( clazzToProcess, mappings );\n\t\t\tbindTypeDefs(clazzToProcess, mappings);\n\t\t}\n\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n\t\tif ( filterAnn !\u003d null ) {\n\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n\t\t}\n\t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n\t\tif ( filtersAnn !\u003d null ) {\n\t\t\tfor (Filter filter : filtersAnn.value()) {\n\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n\t\t\t}\n\t\t}\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tXClass current \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "diff": "@@ -1,411 +1,412 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n-\t\t\n+\n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n-\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType )) {\n-\t\t\tbindQueries(clazzToProcess, mappings );\n+\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n+\t\t\tbindQueries( clazzToProcess, mappings );\n+\t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t}\n-\t\t\n+\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tInheritanceState superEntityState \u003d\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity \u003d\u003d null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tString discrimValue \u003d null;\n \t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n \t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass \u003d new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n \t\tif ( filterAnn !\u003d null ) {\n \t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n \t\t}\n \t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n \t\tif ( filtersAnn !\u003d null ) {\n \t\t\tfor (Filter filter : filtersAnn.value()) {\n \t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n \t\t\t}\n \t\t}\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tXClass current \u003d inheritanceState.clazz;\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88caf4d9586e988675254c268f4e145d272a9499": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4364 support @NamedQuery on a @MappedSuperclass (Sharath Reddy)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17530 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-09-22, 1:19 p.m.",
      "commitName": "88caf4d9586e988675254c268f4e145d272a9499",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009-07-22, 4:40 p.m.",
      "commitNameOld": "eeb136fa719fe007158d90ba011473ea7d1fa38b",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 61.86,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\t\t\n\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType )) {\n\t\t\tbindQueries(clazzToProcess, mappings );\n\t\t}\n\t\t\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n\t\tif ( filterAnn !\u003d null ) {\n\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n\t\t}\n\t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n\t\tif ( filtersAnn !\u003d null ) {\n\t\t\tfor (Filter filter : filtersAnn.value()) {\n\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n\t\t\t}\n\t\t}\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tXClass current \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "diff": "@@ -1,405 +1,411 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n+\t\t\n+\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n+\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType )) {\n+\t\t\tbindQueries(clazzToProcess, mappings );\n+\t\t}\n+\t\t\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tInheritanceState superEntityState \u003d\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity \u003d\u003d null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema \u003d \"\";\n \t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog \u003d \"\";\n \t\tString discrimValue \u003d null;\n \t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n \t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable \u003d tabAnn.name();\n \t\t\tschema \u003d tabAnn.schema();\n \t\t\tcatalog \u003d tabAnn.catalog();\n \t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n \t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass \u003d new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder \u003d new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n \t\tif ( filterAnn !\u003d null ) {\n \t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n \t\t}\n \t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n \t\tif ( filtersAnn !\u003d null ) {\n \t\t\tfor (Filter filter : filtersAnn.value()) {\n \t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n \t\t\t}\n \t\t}\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate \u003d false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate \u003d true;\n \t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn !\u003d null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList\u003cPropertyData\u003e elements \u003d\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements \u003d\u003d null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n \t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n \t\tIdClass idClass \u003d null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tXClass current \u003d inheritanceState.clazz;\n \t\t\tInheritanceState state \u003d inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent \u003d state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state !\u003d null );\n \t\t}\n \t\tif ( idClass !\u003d null ) {\n \t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent \u003d true;\n \t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType \u003d \"assigned\";\n \t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n \t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tinferredData \u003d new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper \u003d fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property \u003d new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties \u003d mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() !\u003d 0 ) {\n \t\t\tStringBuilder missings \u003d new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index \u0026 all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": {
      "type": "Yfilerename",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15418 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-28, 2:53 p.m.",
      "commitName": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2008-10-28, 2:52 p.m.",
      "commitNameOld": "c457f2b3258fc48ef4010a9e58cd2fc3baaca6cc",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n\t\tif ( filterAnn !\u003d null ) {\n\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n\t\t}\n\t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n\t\tif ( filtersAnn !\u003d null ) {\n\t\t\tfor (Filter filter : filtersAnn.value()) {\n\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n\t\t\t}\n\t\t}\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tXClass current \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 394,
      "functionName": "bindClass",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/java/org/hibernate/cfg/AnnotationBinder.java",
        "newPath": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
      }
    },
    "7337743c93574823424ed6c399cfcf6bd75614f8": {
      "type": "Yintroduced",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15415 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-28, 2:41 p.m.",
      "commitName": "7337743c93574823424ed6c399cfcf6bd75614f8",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,405 @@\n+\tpublic static void bindClass(\n+\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n+\t) throws MappingException {\n+\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n+\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n+\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n+\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n+\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n+\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n+\t\t\t\t) {\n+\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n+\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n+\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n+\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n+\t\t\t//TODO make this test accurate by removing the none elements artifically added\n+\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n+\t\t\t\t\t\t\t.getName()\n+\t\t\t);\n+\t\t}\n+\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n+\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n+\t\tInheritanceState superEntityState \u003d\n+\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n+\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n+\t\t\t\t);\n+\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n+\t\t\t\tmappings.getClass(\n+\t\t\t\t\t\tsuperEntityState.clazz.getName()\n+\t\t\t\t) :\n+\t\t\t\tnull;\n+\t\tif ( superEntity \u003d\u003d null ) {\n+\t\t\t//check if superclass is not a potential persistent class\n+\t\t\tif ( inheritanceState.hasParents ) {\n+\t\t\t\tthrow new AssertionFailure(\n+\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n+\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t}\n+\t\tbindQueries( annotatedClass, mappings );\n+\t\tbindFilterDefs( annotatedClass, mappings );\n+\t\tbindTypeDefs( annotatedClass, mappings );\n+\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n+\n+\t\tString schema \u003d \"\";\n+\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n+\t\tString catalog \u003d \"\";\n+\t\tString discrimValue \u003d null;\n+\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n+\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n+\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n+\n+\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n+\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n+\t\t\ttable \u003d tabAnn.name();\n+\t\t\tschema \u003d tabAnn.schema();\n+\t\t\tcatalog \u003d tabAnn.catalog();\n+\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n+\t\t}\n+\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n+\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n+\t\tif ( hasJoinedColumns ) {\n+\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n+\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n+\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n+\t\t\tif ( explicitInheritanceJoinedColumns ) {\n+\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n+\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n+\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n+\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n+\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n+\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n+\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n+\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n+\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n+\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n+\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n+\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n+\t\t}\n+\t\telse {\n+\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n+\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n+\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n+\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n+\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n+\t\t\t);\n+\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n+\t\t\t\t\tdiscAnn.discriminatorType() :\n+\t\t\t\t\tDiscriminatorType.STRING;\n+\n+\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n+\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n+\t\t\t);\n+\t\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n+\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n+\t\t\t\tlog.warn(\n+\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n+\t\t\t\t\t\tclazzToProcess.getName()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n+\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n+\t\t\t\t\tnull;\n+\t\t}\n+\n+\t\t//we now know what kind of persistent entity it is\n+\t\tPersistentClass persistentClass;\n+\t\t//create persistent class\n+\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\tpersistentClass \u003d new RootClass();\n+\t\t}\n+\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n+\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n+\t\t}\n+\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n+\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n+\t\t}\n+\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n+\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n+\t\t}\n+\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n+\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n+\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n+\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n+\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n+\t\t\t\torg.hibernate.annotations.Entity.class\n+\t\t);\n+\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n+\t\t\t\torg.hibernate.annotations.Cache.class\n+\t\t);\n+\t\tEntityBinder entityBinder \u003d new EntityBinder(\n+\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n+\t\t);\n+\t\tentityBinder.setDiscriminatorValue( discrimValue );\n+\t\tentityBinder.setBatchSize( sizeAnn );\n+\t\tentityBinder.setProxy( proxyAnn );\n+\t\tentityBinder.setWhere( whereAnn );\n+\t\tentityBinder.setCache( cacheAnn );\n+\t\tentityBinder.setInheritanceState( inheritanceState );\n+\t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n+\t\tif ( filterAnn !\u003d null ) {\n+\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n+\t\t}\n+\t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n+\t\tif ( filtersAnn !\u003d null ) {\n+\t\t\tfor (Filter filter : filtersAnn.value()) {\n+\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n+\t\t\t}\n+\t\t}\n+\t\tentityBinder.bindEntity();\n+\n+\t\tif ( inheritanceState.hasTable() ) {\n+\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n+\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n+\t\t\t\t\tnull :\n+\t\t\t\t\tcheckAnn.constraints();\n+\t\t\tentityBinder.bindTable(\n+\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n+\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n+\t\t\t\t\tsuperEntity.getTable() :\n+\t\t\t\t\tnull\n+\t\t\t);\n+\t\t}\n+\t\telse {\n+\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n+\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n+\t\t\t\t\t\t.getName() );\n+\t\t\t}\n+\t\t}\n+//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n+//\t\t\t\tclazzToProcess,\n+//\t\t\t\tpersistentClass.getClassName()\n+//\t\t);\n+\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tentityBinder, mappings\n+\t\t);\n+\n+\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n+\t\t\t\tjavax.persistence.SecondaryTable.class\n+\t\t);\n+\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n+\t\t\t\tjavax.persistence.SecondaryTables.class\n+\t\t);\n+\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n+\n+\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n+\t\tboolean onDeleteAppropriate \u003d false;\n+\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n+\t\t\tonDeleteAppropriate \u003d true;\n+\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n+\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n+\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n+\t\t\t}\n+\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n+\t\t\tjsc.setKey( key );\n+\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n+\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n+\t\t\t\tkey.setForeignKeyName( fk.name() );\n+\t\t\t}\n+\t\t\tif ( onDeleteAnn !\u003d null ) {\n+\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tkey.setCascadeDeleteEnabled( false );\n+\t\t\t}\n+\t\t\t//we are never in a second pass at that stage, so queue it\n+\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n+\t\t\tmappings.addSecondPass( sp );\n+\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n+\n+\t\t}\n+\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n+\t\t\tif ( inheritanceState.hasParents ) {\n+\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n+\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n+\t\t\t\t\t//need a discriminator column\n+\t\t\t\t\tbindDiscriminatorToPersistentClass(\n+\t\t\t\t\t\t\t(RootClass) persistentClass,\n+\t\t\t\t\t\t\tdiscriminatorColumn,\n+\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n+\t\t\t\t\t\t\tpropertyHolder\n+\t\t\t\t\t);\n+\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n+\t\t\tif ( inheritanceState.hasParents ) {\n+\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n+\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n+\t\t\tlog.warn(\n+\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n+\t\t\t);\n+\t\t}\n+\n+\t\t//try to find class level generators\n+\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n+\n+\t\t// check properties\n+\t\tList\u003cPropertyData\u003e elements \u003d\n+\t\t\t\tgetElementsToProcess(\n+\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n+\t\t\t\t);\n+\t\tif ( elements \u003d\u003d null ) {\n+\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n+\t\t}\n+\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n+\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n+\t\t//process idclass if any\n+\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n+\t\tIdClass idClass \u003d null;\n+\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\t//look for idClass\n+\t\t\tXClass current \u003d inheritanceState.clazz;\n+\t\t\tInheritanceState state \u003d inheritanceState;\n+\t\t\tdo {\n+\t\t\t\tcurrent \u003d state.clazz;\n+\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n+\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n+\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\twhile ( state !\u003d null );\n+\t\t}\n+\t\tif ( idClass !\u003d null ) {\n+\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n+\t\t\tboolean isComponent \u003d true;\n+\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n+\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n+\t\t\tString generatorType \u003d \"assigned\";\n+\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n+\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n+\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n+\t\t\t);\n+\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n+\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n+\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n+\t\t\tbindId(\n+\t\t\t\t\tgeneratorType,\n+\t\t\t\t\tgenerator,\n+\t\t\t\t\tinferredData,\n+\t\t\t\t\tnull,\n+\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\tlocalGenerators,\n+\t\t\t\t\tisComponent,\n+\t\t\t\t\tpropertyAnnotated,\n+\t\t\t\t\tpropertyAccessor, entityBinder,\n+\t\t\t\t\ttrue,\n+\t\t\t\t\tfalse, mappings\n+\t\t\t);\n+\t\t\tinferredData \u003d new PropertyPreloadedData(\n+\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n+\t\t\t);\n+\t\t\tComponent mapper \u003d fillComponent(\n+\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\tinferredData,\n+\t\t\t\t\tpropertyAnnotated,\n+\t\t\t\t\tpropertyAccessor, false,\n+\t\t\t\t\tentityBinder,\n+\t\t\t\t\ttrue, true,\n+\t\t\t\t\tfalse, mappings\n+\t\t\t);\n+\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n+\t\t\tpersistentClass.setIdentifierMapper( mapper );\n+\t\t\tProperty property \u003d new Property();\n+\t\t\tproperty.setName( \"_identifierMapper\" );\n+\t\t\tproperty.setNodeName( \"id\" );\n+\t\t\tproperty.setUpdateable( false );\n+\t\t\tproperty.setInsertable( false );\n+\t\t\tproperty.setValue( mapper );\n+\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n+\t\t\tpersistentClass.addProperty( property );\n+\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n+\n+\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n+\t\t\twhile ( properties.hasNext() ) {\n+\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n+\t\t\t}\n+\t\t}\n+\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n+\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n+\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n+\t\t\tif ( !idProperties.contains( propertyName ) ) {\n+\t\t\t\tprocessElementAnnotations(\n+\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n+\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n+\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n+\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n+\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n+\t\t\t\t\t\tfalse, false, false, mappings\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tmissingIdProperties.remove( propertyName );\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n+\t\t\tStringBuilder missings \u003d new StringBuilder();\n+\t\t\tfor (String property : missingIdProperties) {\n+\t\t\t\tmissings.append( property ).append( \", \" );\n+\t\t\t}\n+\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\"Unable to find properties (\"\n+\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n+\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n+\t\t\t);\n+\t\t}\n+\n+\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n+\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n+\t\t}\n+\t\telse {\n+\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n+\t\t}\n+\n+\t\tmappings.addClass( persistentClass );\n+\n+\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n+\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n+\n+\t\t//add process complementary Table definition (index \u0026 all)\n+\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n+\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n+\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic static void bindClass(\n\t\t\tXClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings\n\t) throws MappingException {\n\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n\t\tInheritanceState inheritanceState \u003d inheritanceStatePerClass.get( clazzToProcess );\n\t\tAnnotatedClassType classType \u003d mappings.getClassType( clazzToProcess );\n\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n\t\t\t\t) {\n\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n\t\t\t\t\t\u0026\u0026 clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n\t\t\t//TODO make this test accurate by removing the none elements artifically added\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n\t\t\t\t\t\t\t.getName()\n\t\t\t);\n\t\t}\n\t\tXAnnotatedElement annotatedClass \u003d clazzToProcess;\n\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n\t\tInheritanceState superEntityState \u003d\n\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\tPersistentClass superEntity \u003d superEntityState !\u003d null ?\n\t\t\t\tmappings.getClass(\n\t\t\t\t\t\tsuperEntityState.clazz.getName()\n\t\t\t\t) :\n\t\t\t\tnull;\n\t\tif ( superEntity \u003d\u003d null ) {\n\t\t\t//check if superclass is not a potential persistent class\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tthrow new AssertionFailure(\n\t\t\t\t\t\t\"Subclass has to be binded after it\u0027s mother class: \"\n\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tbindQueries( annotatedClass, mappings );\n\t\tbindFilterDefs( annotatedClass, mappings );\n\t\tbindTypeDefs( annotatedClass, mappings );\n\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n\n\t\tString schema \u003d \"\";\n\t\tString table \u003d \"\"; //might be no @Table annotation on the annotated class\n\t\tString catalog \u003d \"\";\n\t\tString discrimValue \u003d null;\n\t\tList\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n\t\tEjb3DiscriminatorColumn discriminatorColumn \u003d null;\n\t\tEjb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n\n\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n\t\t\tjavax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation( javax.persistence.Table.class );\n\t\t\ttable \u003d tabAnn.name();\n\t\t\tschema \u003d tabAnn.schema();\n\t\t\tcatalog \u003d tabAnn.catalog();\n\t\t\tuniqueConstraints \u003d TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n\t\t}\n\t\tfinal boolean hasJoinedColumns \u003d inheritanceState.hasParents\n\t\t\t\t\u0026\u0026 InheritanceType.JOINED.equals( inheritanceState.type );\n\t\tif ( hasJoinedColumns ) {\n\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n\t\t\tPrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n\t\t\tboolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n\t\t\tif ( explicitInheritanceJoinedColumns ) {\n\t\t\t\tint nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n\t\t\t\tfor (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n\t\t\t\t\tjcAnn \u003d jcsAnn.value()[colIndex];\n\t\t\t\t\tinheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n\t\t\t\tinheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n\t\t\t\tinheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(\n\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n\t\t\t\t\t\t(Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tjavax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n\t\t\t);\n\t\t\tDiscriminatorType discriminatorType \u003d discAnn !\u003d null ?\n\t\t\t\t\tdiscAnn.discriminatorType() :\n\t\t\t\t\tDiscriminatorType.STRING;\n\n\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n\t\t\t);\n\t\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t\tdiscriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n\t\t\t\t\t\tclazzToProcess.getName()\n\t\t\t\t);\n\t\t\t}\n\t\t\tdiscrimValue \u003d annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n\t\t\t\t\tnull;\n\t\t}\n\n\t\t//we now know what kind of persistent entity it is\n\t\tPersistentClass persistentClass;\n\t\t//create persistent class\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tpersistentClass \u003d new RootClass();\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new SingleTableSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new JoinedSubclass( superEntity );\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tpersistentClass \u003d new UnionSubclass( superEntity );\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n\t\t}\n\t\tProxy proxyAnn \u003d annotatedClass.getAnnotation( Proxy.class );\n\t\tBatchSize sizeAnn \u003d annotatedClass.getAnnotation( BatchSize.class );\n\t\tWhere whereAnn \u003d annotatedClass.getAnnotation( Where.class );\n\t\tEntity entityAnn \u003d annotatedClass.getAnnotation( Entity.class );\n\t\torg.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Entity.class\n\t\t);\n\t\torg.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\torg.hibernate.annotations.Cache.class\n\t\t);\n\t\tEntityBinder entityBinder \u003d new EntityBinder(\n\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n\t\t);\n\t\tentityBinder.setDiscriminatorValue( discrimValue );\n\t\tentityBinder.setBatchSize( sizeAnn );\n\t\tentityBinder.setProxy( proxyAnn );\n\t\tentityBinder.setWhere( whereAnn );\n\t\tentityBinder.setCache( cacheAnn );\n\t\tentityBinder.setInheritanceState( inheritanceState );\n\t\tFilter filterAnn \u003d annotatedClass.getAnnotation( Filter.class );\n\t\tif ( filterAnn !\u003d null ) {\n\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n\t\t}\n\t\tFilters filtersAnn \u003d annotatedClass.getAnnotation( Filters.class );\n\t\tif ( filtersAnn !\u003d null ) {\n\t\t\tfor (Filter filter : filtersAnn.value()) {\n\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n\t\t\t}\n\t\t}\n\t\tentityBinder.bindEntity();\n\n\t\tif ( inheritanceState.hasTable() ) {\n\t\t\tCheck checkAnn \u003d annotatedClass.getAnnotation( Check.class );\n\t\t\tString constraints \u003d checkAnn \u003d\u003d null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tcheckAnn.constraints();\n\t\t\tentityBinder.bindTable(\n\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n\t\t\t\t\tsuperEntity.getTable() :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n\t\t\t\t\t\t.getName() );\n\t\t\t}\n\t\t}\n//\t\tMap\u003cString, Column[]\u003e columnOverride \u003d PropertyHolderBuilder.buildHierarchyColumnOverride(\n//\t\t\t\tclazzToProcess,\n//\t\t\t\tpersistentClass.getClassName()\n//\t\t);\n\t\tPropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(\n\t\t\t\tclazzToProcess,\n\t\t\t\tpersistentClass,\n\t\t\t\tentityBinder, mappings\n\t\t);\n\n\t\tjavax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTable.class\n\t\t);\n\t\tjavax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(\n\t\t\t\tjavax.persistence.SecondaryTables.class\n\t\t);\n\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n\n\t\tOnDelete onDeleteAnn \u003d annotatedClass.getAnnotation( OnDelete.class );\n\t\tboolean onDeleteAppropriate \u003d false;\n\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) \u0026\u0026 inheritanceState.hasParents ) {\n\t\t\tonDeleteAppropriate \u003d true;\n\t\t\tfinal JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n\t\t\t}\n\t\t\tSimpleValue key \u003d new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n\t\t\tjsc.setKey( key );\n\t\t\tForeignKey fk \u003d annotatedClass.getAnnotation( ForeignKey.class );\n\t\t\tif ( fk !\u003d null \u0026\u0026 !BinderHelper.isDefault( fk.name() ) ) {\n\t\t\t\tkey.setForeignKeyName( fk.name() );\n\t\t\t}\n\t\t\tif ( onDeleteAnn !\u003d null ) {\n\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkey.setCascadeDeleteEnabled( false );\n\t\t\t}\n\t\t\t//we are never in a second pass at that stage, so queue it\n\t\t\tSecondPass sp \u003d new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n\t\t\tmappings.addSecondPass( sp );\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n\n\t\t}\n\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n\t\t\t\t\t//need a discriminator column\n\t\t\t\t\tbindDiscriminatorToPersistentClass(\n\t\t\t\t\t\t\t(RootClass) persistentClass,\n\t\t\t\t\t\t\tdiscriminatorColumn,\n\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n\t\t\t\t\t\t\tpropertyHolder\n\t\t\t\t\t);\n\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n\t\t\tif ( inheritanceState.hasParents ) {\n\t\t\t\tif ( persistentClass.getEntityPersisterClass() \u003d\u003d null ) {\n\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate ) {\n\t\t\tlog.warn(\n\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\t//try to find class level generators\n\t\tHashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators( annotatedClass, mappings );\n\n\t\t// check properties\n\t\tList\u003cPropertyData\u003e elements \u003d\n\t\t\t\tgetElementsToProcess(\n\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n\t\t\t\t);\n\t\tif ( elements \u003d\u003d null ) {\n\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n\t\t}\n\t\tfinal boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE\n\t\t\t\t\u0026\u0026 inheritanceState.hasParents;\n\t\t//process idclass if any\n\t\tSet\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n\t\tIdClass idClass \u003d null;\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\t//look for idClass\n\t\t\tXClass current \u003d inheritanceState.clazz;\n\t\t\tInheritanceState state \u003d inheritanceState;\n\t\t\tdo {\n\t\t\t\tcurrent \u003d state.clazz;\n\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n\t\t\t\t\tidClass \u003d current.getAnnotation( IdClass.class );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstate \u003d InheritanceState.getSuperclassInheritanceState(\n\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n\t\t\t\t);\n\t\t\t}\n\t\t\twhile ( state !\u003d null );\n\t\t}\n\t\tif ( idClass !\u003d null ) {\n\t\t\tXClass compositeClass \u003d mappings.getReflectionManager().toXClass( idClass.value() );\n\t\t\tboolean isComponent \u003d true;\n\t\t\tboolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated( compositeClass );\n\t\t\tString propertyAccessor \u003d entityBinder.getPropertyAccessor( compositeClass );\n\t\t\tString generatorType \u003d \"assigned\";\n\t\t\tString generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n\t\t\tPropertyData inferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n\t\t\t);\n\t\t\tHashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n\t\t\tboolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\t\t\tbindId(\n\t\t\t\t\tgeneratorType,\n\t\t\t\t\tgenerator,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tnull,\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tlocalGenerators,\n\t\t\t\t\tisComponent,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, entityBinder,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tinferredData \u003d new PropertyPreloadedData(\n\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n\t\t\t);\n\t\t\tComponent mapper \u003d fillComponent(\n\t\t\t\t\tpropertyHolder,\n\t\t\t\t\tinferredData,\n\t\t\t\t\tpropertyAnnotated,\n\t\t\t\t\tpropertyAccessor, false,\n\t\t\t\t\tentityBinder,\n\t\t\t\t\ttrue, true,\n\t\t\t\t\tfalse, mappings\n\t\t\t);\n\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n\t\t\tpersistentClass.setIdentifierMapper( mapper );\n\t\t\tProperty property \u003d new Property();\n\t\t\tproperty.setName( \"_identifierMapper\" );\n\t\t\tproperty.setNodeName( \"id\" );\n\t\t\tproperty.setUpdateable( false );\n\t\t\tproperty.setInsertable( false );\n\t\t\tproperty.setValue( mapper );\n\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n\t\t\tpersistentClass.addProperty( property );\n\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n\n\t\t\tIterator properties \u003d mapper.getPropertyIterator();\n\t\t\twhile ( properties.hasNext() ) {\n\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n\t\t\t}\n\t\t}\n\t\tSet\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e( idProperties );\n\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n\t\t\tString propertyName \u003d propertyAnnotatedElement.getPropertyName();\n\t\t\tif ( !idProperties.contains( propertyName ) ) {\n\t\t\t\tprocessElementAnnotations(\n\t\t\t\t\t\tpropertyHolder,\n\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n\t\t\t\t\t\tfalse, false, false, mappings\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmissingIdProperties.remove( propertyName );\n\t\t\t}\n\t\t}\n\n\t\tif ( missingIdProperties.size() !\u003d 0 ) {\n\t\t\tStringBuilder missings \u003d new StringBuilder();\n\t\t\tfor (String property : missingIdProperties) {\n\t\t\t\tmissings.append( property ).append( \", \" );\n\t\t\t}\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Unable to find properties (\"\n\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n\t\t\t);\n\t\t}\n\n\t\tif ( !inheritanceState.hasParents ) {\n\t\t\tfinal RootClass rootClass \u003d (RootClass) persistentClass;\n\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n\t\t}\n\t\telse {\n\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n\t\t}\n\n\t\tmappings.addClass( persistentClass );\n\n\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n\n\t\t//add process complementary Table definition (index \u0026 all)\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n\n\t}",
      "path": "annotations/src/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 394,
      "functionName": "bindClass"
    }
  }
}