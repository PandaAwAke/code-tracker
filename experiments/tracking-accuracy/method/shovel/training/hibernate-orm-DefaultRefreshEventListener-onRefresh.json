{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "H:\\Projects\\hibernate\\hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "DefaultRefreshEventListener.java",
  "functionName": "onRefresh",
  "functionId": "onRefresh___event-RefreshEvent__refreshedAlready-Map",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
  "functionStartLine": 56,
  "functionEndLine": 229,
  "numCommitsSeen": 47,
  "timeTaken": 6565,
  "changeHistory": [
    "12b79a59383d1b647c9957815ef53861f0752dad",
    "a286232da374cbccefddbf406830dbb598b6c824",
    "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
    "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
    "59c3baae3271247bed516fe50952b65be1a27e5b",
    "cc5a13a3f007fad6067945e0bb011d902ba9b6f4",
    "8c9152040c469a096cd78b18234a66c973d5e07e",
    "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b",
    "cffe71aeba38977f526b5ce7e870609ea419471c",
    "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
    "fb15ee548ca1c8fb80f77497271931404f54c19e",
    "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
    "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
    "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
    "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
    "129c0f13482b99e2705f0e234b6bc0572a95c271",
    "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9",
    "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
    "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
    "47abaf12fa6be50e95b2a3b8b3d424611c873d66",
    "fe8c7183d172946a03818be2cec1c9c2fc819316",
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
    "14bdaec5e75bded557e8410d818a7b77308dd80b",
    "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
    "c18a9306b9f8995331240b66c01fea304e01d06f",
    "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
    "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
    "35ca4c35635f26b9a86b260ad974ba7da429950b",
    "a797998927e2cbba9ec34ca7dc31b42a192fa2f1",
    "d8d6d82e30960e0c255950eaf875ad48831b12b0"
  ],
  "changeHistoryShort": {
    "12b79a59383d1b647c9957815ef53861f0752dad": "Ybodychange",
    "a286232da374cbccefddbf406830dbb598b6c824": "Ybodychange",
    "f432ecea687ce606144c8fca1f4fc7f1937e1c2a": "Ybodychange",
    "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b": "Ybodychange",
    "59c3baae3271247bed516fe50952b65be1a27e5b": "Ybodychange",
    "cc5a13a3f007fad6067945e0bb011d902ba9b6f4": "Ybodychange",
    "8c9152040c469a096cd78b18234a66c973d5e07e": "Ybodychange",
    "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b": "Ybodychange",
    "cffe71aeba38977f526b5ce7e870609ea419471c": "Ybodychange",
    "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f": "Ybodychange",
    "fb15ee548ca1c8fb80f77497271931404f54c19e": "Ybodychange",
    "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc": "Ybodychange",
    "4428464d096c6a1fff3023cb707a2384ab6c0ffb": "Ybodychange",
    "fc02da1c12f6a7487b56e76cf817dc72da8314e6": "Ybodychange",
    "6b5a428b3fed930227ae6a17e3b876c07745d5a3": "Ybodychange",
    "129c0f13482b99e2705f0e234b6bc0572a95c271": "Ybodychange",
    "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9": "Ybodychange",
    "eb5bc1609d28dc740a249e622850a3b3b15b5ace": "Ybodychange",
    "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173": "Yfilerename",
    "47abaf12fa6be50e95b2a3b8b3d424611c873d66": "Ybodychange",
    "fe8c7183d172946a03818be2cec1c9c2fc819316": "Ybodychange",
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": "Ybodychange",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": "Ybodychange",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": "Yfilerename",
    "14bdaec5e75bded557e8410d818a7b77308dd80b": "Ybodychange",
    "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b": "Ybodychange",
    "c18a9306b9f8995331240b66c01fea304e01d06f": "Ybodychange",
    "b40cfb58dbe4606609c3fa2b1e5e210466c593df": "Ybodychange",
    "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49": "Ybodychange",
    "35ca4c35635f26b9a86b260ad974ba7da429950b": "Ybodychange",
    "a797998927e2cbba9ec34ca7dc31b42a192fa2f1": "Yfilerename",
    "d8d6d82e30960e0c255950eaf875ad48831b12b0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "12b79a59383d1b647c9957815ef53861f0752dad": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12257 - Refreshing an entity clears the lock mode returned from EntityManager.getLockMode\n",
      "commitDate": "2018-04-26, 2:46 p.m.",
      "commitName": "12b79a59383d1b647c9957815ef53861f0752dad",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2018-04-26, 2:46 p.m.",
      "commitNameOld": "a286232da374cbccefddbf406830dbb598b6c824",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\tboolean isTransient;\n\t\tif ( event.getEntityName() !\u003d null ) {\n\t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n\t\t}\n\t\telse {\n\t\t\tisTransient \u003d !source.contains( event.getObject() );\n\t\t}\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.canWriteToCache() ) {\n\t\t\tObject previousVersion \u003d null;\n\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n\t\t\t\t// we need to grab the version value from the entity, otherwise\n\t\t\t\t// we have issues with generated-version entities that may have\n\t\t\t\t// multiple actions queued during the same flush\n\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n\t\t\t}\n\t\t\tfinal EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n\t\t\tcache.remove( source, ck );\n\t\t\tsource.getActionQueue().registerProcess( (success, session) -\u003e cache.unlockItem( session, ck, lock ) );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\n\n\t\t// Handle the requested lock-mode (if one) in relation to the entry\u0027s (if one) current lock-mode\n\n\t\tLockOptions lockOptionsToUse \u003d event.getLockOptions();\n\n\t\tfinal LockMode requestedLockMode \u003d lockOptionsToUse.getLockMode();\n\t\tLockMode postRefreshLockMode \u003d null;\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal LockMode currentLockMode \u003d e.getLockMode();\n\t\t\tif ( currentLockMode.greaterThan( requestedLockMode ) ) {\n\t\t\t\t// the requested lock-mode is less restrictive than the current one\n\t\t\t\t//\t\t- pass along the current lock-mode (after accounting for WRITE)\n\t\t\t\tlockOptionsToUse \u003d LockOptions.copy( event.getLockOptions(), new LockOptions() );\n\t\t\t\tif ( currentLockMode \u003d\u003d LockMode.WRITE ) {\n\t\t\t\t\t// our transaction should already hold the exclusive lock on\n\t\t\t\t\t// the underlying row - so READ should be sufficient.\n\t\t\t\t\t//\n\t\t\t\t\t// in fact, this really holds true for any current lock-mode that indicates we\n\t\t\t\t\t// hold an exclusive lock on the underlying row - but we *need* to handle\n\t\t\t\t\t// WRITE specially because the Loader/Locker mechanism does not allow for WRITE\n\t\t\t\t\t// locks\n\t\t\t\t\tlockOptionsToUse.setLockMode( LockMode.READ );\n\n\t\t\t\t\t// and prepare to reset the entry lock-mode to WRITE after the refresh completes\n\t\t\t\t\tpostRefreshLockMode \u003d LockMode.WRITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlockOptionsToUse.setLockMode( currentLockMode );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Object result \u003d persister.load( id, object, lockOptionsToUse, source );\n\n\t\tif ( result !\u003d null ) {\n\t\t\t// apply `postRefreshLockMode`, if needed\n\t\t\tif ( postRefreshLockMode !\u003d null ) {\n\t\t\t\t// if we get here, there was a previous entry and we need to re-set its lock-mode\n\t\t\t\t//\t\t- however, the refresh operation actually creates a new entry, so get it\n\t\t\t\tsource.getPersistenceContext().getEntry( result ).setLockMode( postRefreshLockMode );\n\t\t\t}\n\n\t\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t\t// If it was transient, then set it to the default for the source.\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "diff": "@@ -1,140 +1,174 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() !\u003d null ) {\n \t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient \u003d !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion \u003d null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n \t\t\tcache.remove( source, ck );\n \t\t\tsource.getActionQueue().registerProcess( (success, session) -\u003e cache.unlockItem( session, ck, lock ) );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \n-\t\t// Use the entity\u0027s current LockMode if it is greater than event.getLockMode()\n-\t\tfinal LockMode currentLockMode \u003d e \u003d\u003d null ? null : e.getLockMode();\n+\n+\t\t// Handle the requested lock-mode (if one) in relation to the entry\u0027s (if one) current lock-mode\n+\n \t\tLockOptions lockOptionsToUse \u003d event.getLockOptions();\n-\t\tif ( currentLockMode !\u003d null \u0026\u0026 currentLockMode.greaterThan( event.getLockMode() ) ) {\n-\t\t\tlockOptionsToUse \u003d LockOptions.copy( event.getLockOptions(), new LockOptions() );\n-\t\t\tlockOptionsToUse.setLockMode( currentLockMode );\n+\n+\t\tfinal LockMode requestedLockMode \u003d lockOptionsToUse.getLockMode();\n+\t\tLockMode postRefreshLockMode \u003d null;\n+\n+\t\tif ( e !\u003d null ) {\n+\t\t\tfinal LockMode currentLockMode \u003d e.getLockMode();\n+\t\t\tif ( currentLockMode.greaterThan( requestedLockMode ) ) {\n+\t\t\t\t// the requested lock-mode is less restrictive than the current one\n+\t\t\t\t//\t\t- pass along the current lock-mode (after accounting for WRITE)\n+\t\t\t\tlockOptionsToUse \u003d LockOptions.copy( event.getLockOptions(), new LockOptions() );\n+\t\t\t\tif ( currentLockMode \u003d\u003d LockMode.WRITE ) {\n+\t\t\t\t\t// our transaction should already hold the exclusive lock on\n+\t\t\t\t\t// the underlying row - so READ should be sufficient.\n+\t\t\t\t\t//\n+\t\t\t\t\t// in fact, this really holds true for any current lock-mode that indicates we\n+\t\t\t\t\t// hold an exclusive lock on the underlying row - but we *need* to handle\n+\t\t\t\t\t// WRITE specially because the Loader/Locker mechanism does not allow for WRITE\n+\t\t\t\t\t// locks\n+\t\t\t\t\tlockOptionsToUse.setLockMode( LockMode.READ );\n+\n+\t\t\t\t\t// and prepare to reset the entry lock-mode to WRITE after the refresh completes\n+\t\t\t\t\tpostRefreshLockMode \u003d LockMode.WRITE;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tlockOptionsToUse.setLockMode( currentLockMode );\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tObject result \u003d persister.load( id, object, lockOptionsToUse, source );\n-\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n-\t\t// If it was transient, then set it to the default for the source.\n+\n+\t\tfinal Object result \u003d persister.load( id, object, lockOptionsToUse, source );\n+\n \t\tif ( result !\u003d null ) {\n+\t\t\t// apply `postRefreshLockMode`, if needed\n+\t\t\tif ( postRefreshLockMode !\u003d null ) {\n+\t\t\t\t// if we get here, there was a previous entry and we need to re-set its lock-mode\n+\t\t\t\t//\t\t- however, the refresh operation actually creates a new entry, so get it\n+\t\t\t\tsource.getPersistenceContext().getEntry( result ).setLockMode( postRefreshLockMode );\n+\t\t\t}\n+\n+\t\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n+\t\t\t// If it was transient, then set it to the default for the source.\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a286232da374cbccefddbf406830dbb598b6c824": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12257 : Refreshing an entity clears the lock mode\n",
      "commitDate": "2018-04-26, 2:46 p.m.",
      "commitName": "a286232da374cbccefddbf406830dbb598b6c824",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2018-03-22, 2:25 p.m.",
      "commitNameOld": "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 35.01,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\tboolean isTransient;\n\t\tif ( event.getEntityName() !\u003d null ) {\n\t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n\t\t}\n\t\telse {\n\t\t\tisTransient \u003d !source.contains( event.getObject() );\n\t\t}\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.canWriteToCache() ) {\n\t\t\tObject previousVersion \u003d null;\n\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n\t\t\t\t// we need to grab the version value from the entity, otherwise\n\t\t\t\t// we have issues with generated-version entities that may have\n\t\t\t\t// multiple actions queued during the same flush\n\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n\t\t\t}\n\t\t\tfinal EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n\t\t\tcache.remove( source, ck );\n\t\t\tsource.getActionQueue().registerProcess( (success, session) -\u003e cache.unlockItem( session, ck, lock ) );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\n\t\t// Use the entity\u0027s current LockMode if it is greater than event.getLockMode()\n\t\tfinal LockMode currentLockMode \u003d e \u003d\u003d null ? null : e.getLockMode();\n\t\tLockOptions lockOptionsToUse \u003d event.getLockOptions();\n\t\tif ( currentLockMode !\u003d null \u0026\u0026 currentLockMode.greaterThan( event.getLockMode() ) ) {\n\t\t\tlockOptionsToUse \u003d LockOptions.copy( event.getLockOptions(), new LockOptions() );\n\t\t\tlockOptionsToUse.setLockMode( currentLockMode );\n\t\t}\n\t\tObject result \u003d persister.load( id, object, lockOptionsToUse, source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 60,
      "functionName": "onRefresh",
      "diff": "@@ -1,132 +1,140 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() !\u003d null ) {\n \t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient \u003d !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion \u003d null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n \t\t\tcache.remove( source, ck );\n \t\t\tsource.getActionQueue().registerProcess( (success, session) -\u003e cache.unlockItem( session, ck, lock ) );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n-\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n+\n+\t\t// Use the entity\u0027s current LockMode if it is greater than event.getLockMode()\n+\t\tfinal LockMode currentLockMode \u003d e \u003d\u003d null ? null : e.getLockMode();\n+\t\tLockOptions lockOptionsToUse \u003d event.getLockOptions();\n+\t\tif ( currentLockMode !\u003d null \u0026\u0026 currentLockMode.greaterThan( event.getLockMode() ) ) {\n+\t\t\tlockOptionsToUse \u003d LockOptions.copy( event.getLockOptions(), new LockOptions() );\n+\t\t\tlockOptionsToUse.setLockMode( currentLockMode );\n+\t\t}\n+\t\tObject result \u003d persister.load( id, object, lockOptionsToUse, source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f432ecea687ce606144c8fca1f4fc7f1937e1c2a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-11356 - Adjust the 2nd-Cache SPIs to better reflect supported uses\nHHH-12323 - Update Statistics API and SPI based on changes to 2nd level caching changes\n",
      "commitDate": "2018-03-22, 2:25 p.m.",
      "commitName": "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2018-02-21, 3:32 a.m.",
      "commitNameOld": "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
      "commitAuthorOld": "Jonathan Bregler",
      "daysBetweenCommits": 29.41,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\tboolean isTransient;\n\t\tif ( event.getEntityName() !\u003d null ) {\n\t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n\t\t}\n\t\telse {\n\t\t\tisTransient \u003d !source.contains( event.getObject() );\n\t\t}\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.canWriteToCache() ) {\n\t\t\tObject previousVersion \u003d null;\n\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n\t\t\t\t// we need to grab the version value from the entity, otherwise\n\t\t\t\t// we have issues with generated-version entities that may have\n\t\t\t\t// multiple actions queued during the same flush\n\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n\t\t\t}\n\t\t\tfinal EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n\t\t\tcache.remove( source, ck );\n\t\t\tsource.getActionQueue().registerProcess( (success, session) -\u003e cache.unlockItem( session, ck, lock ) );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "diff": "@@ -1,137 +1,132 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() !\u003d null ) {\n \t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient \u003d !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion \u003d null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n \t\t\t}\n-\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n+\t\t\tfinal EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n-\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n-\t\t\t\t\tcache.unlockItem( session, ck, lock );\n-\t\t\t\t}\n-\t\t\t} );\n \t\t\tcache.remove( source, ck );\n+\t\t\tsource.getActionQueue().registerProcess( (success, session) -\u003e cache.unlockItem( session, ck, lock ) );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12260: refactor org.hibernate.event.internal.EvictVisitor#evictCollection\n",
      "commitDate": "2018-02-21, 3:32 a.m.",
      "commitName": "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
      "commitAuthor": "Jonathan Bregler",
      "commitDateOld": "2017-12-13, 7:19 a.m.",
      "commitNameOld": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 69.84,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\tboolean isTransient;\n\t\tif ( event.getEntityName() !\u003d null ) {\n\t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n\t\t}\n\t\telse {\n\t\t\tisTransient \u003d !source.contains( event.getObject() );\n\t\t}\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.canWriteToCache() ) {\n\t\t\tObject previousVersion \u003d null;\n\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n\t\t\t\t// we need to grab the version value from the entity, otherwise\n\t\t\t\t// we have issues with generated-version entities that may have\n\t\t\t\t// multiple actions queued during the same flush\n\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n\t\t\t}\n\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n\t\t\t\t@Override\n\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n\t\t\t\t\tcache.unlockItem( session, ck, lock );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tcache.remove( source, ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "diff": "@@ -1,137 +1,137 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() !\u003d null ) {\n \t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient \u003d !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n-\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n+\t\t\t\tnew EvictVisitor( source, object ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion \u003d null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n \t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n \t\t\t\t@Override\n \t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n \t\t\t\t\tcache.unlockItem( session, ck, lock );\n \t\t\t\t}\n \t\t\t} );\n \t\t\tcache.remove( source, ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59c3baae3271247bed516fe50952b65be1a27e5b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12146  - Support enabling caching at any level within a mapped hierarchy\n",
      "commitDate": "2017-12-13, 7:19 a.m.",
      "commitName": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2017-05-03, 4:54 a.m.",
      "commitNameOld": "3a813dcbb4b5cf5b13571c63ff0c66b94a83b53c",
      "commitAuthorOld": "Richard Bradley",
      "daysBetweenCommits": 224.14,
      "commitsBetweenForRepo": 421,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\tboolean isTransient;\n\t\tif ( event.getEntityName() !\u003d null ) {\n\t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n\t\t}\n\t\telse {\n\t\t\tisTransient \u003d !source.contains( event.getObject() );\n\t\t}\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.canWriteToCache() ) {\n\t\t\tObject previousVersion \u003d null;\n\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n\t\t\t\t// we need to grab the version value from the entity, otherwise\n\t\t\t\t// we have issues with generated-version entities that may have\n\t\t\t\t// multiple actions queued during the same flush\n\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n\t\t\t}\n\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n\t\t\t\t@Override\n\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n\t\t\t\t\tcache.unlockItem( session, ck, lock );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tcache.remove( source, ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "diff": "@@ -1,137 +1,137 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\tboolean isTransient;\n \t\tif ( event.getEntityName() !\u003d null ) {\n \t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n \t\t}\n \t\telse {\n \t\t\tisTransient \u003d !source.contains( event.getObject() );\n \t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n-\t\tif ( persister.hasCache() ) {\n+\t\tif ( persister.canWriteToCache() ) {\n \t\t\tObject previousVersion \u003d null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n \t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n \t\t\t\t@Override\n \t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n \t\t\t\t\tcache.unlockItem( session, ck, lock );\n \t\t\t\t}\n \t\t\t} );\n \t\t\tcache.remove( source, ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc5a13a3f007fad6067945e0bb011d902ba9b6f4": {
      "type": "Ybodychange",
      "commitMessage": "HHH-11217 - SessionImpl.refresh() throws IllegalArgumentException, \u0027not an Entity\u0027 when using custom entity name\n",
      "commitDate": "2016-11-23, 9:52 a.m.",
      "commitName": "cc5a13a3f007fad6067945e0bb011d902ba9b6f4",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2016-05-06, 2:27 p.m.",
      "commitNameOld": "8c9152040c469a096cd78b18234a66c973d5e07e",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 200.85,
      "commitsBetweenForRepo": 579,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\tboolean isTransient;\n\t\tif ( event.getEntityName() !\u003d null ) {\n\t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n\t\t}\n\t\telse {\n\t\t\tisTransient \u003d !source.contains( event.getObject() );\n\t\t}\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tObject previousVersion \u003d null;\n\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n\t\t\t\t// we need to grab the version value from the entity, otherwise\n\t\t\t\t// we have issues with generated-version entities that may have\n\t\t\t\t// multiple actions queued during the same flush\n\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n\t\t\t}\n\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n\t\t\t\t@Override\n\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n\t\t\t\t\tcache.unlockItem( session, ck, lock );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tcache.remove( source, ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had beforeQuery refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "diff": "@@ -1,132 +1,137 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n-\n-\t\tboolean isTransient \u003d !source.contains( event.getObject() );\n+\t\tboolean isTransient;\n+\t\tif ( event.getEntityName() !\u003d null ) {\n+\t\t\tisTransient \u003d !source.contains( event.getEntityName(), event.getObject() );\n+\t\t}\n+\t\telse {\n+\t\t\tisTransient \u003d !source.contains( event.getObject() );\n+\t\t}\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tObject previousVersion \u003d null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n \t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n \t\t\t\t@Override\n \t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n \t\t\t\t\tcache.unlockItem( session, ck, lock );\n \t\t\t\t}\n \t\t\t} );\n \t\t\tcache.remove( source, ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had beforeQuery refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c9152040c469a096cd78b18234a66c973d5e07e": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10664 - Prep 5.2 feature branch\n",
      "commitDate": "2016-05-06, 2:27 p.m.",
      "commitName": "8c9152040c469a096cd78b18234a66c973d5e07e",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2016-05-06, 2:12 p.m.",
      "commitNameOld": "87e3f0fd28d7229b0a35032292ff32f542c22010",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d !source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tObject previousVersion \u003d null;\n\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n\t\t\t\t// we need to grab the version value from the entity, otherwise\n\t\t\t\t// we have issues with generated-version entities that may have\n\t\t\t\t// multiple actions queued during the same flush\n\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n\t\t\t}\n\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n\t\t\t\t@Override\n\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n\t\t\t\t\tcache.unlockItem( session, ck, lock );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tcache.remove( source, ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had beforeQuery refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "diff": "@@ -1,132 +1,132 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tObject previousVersion \u003d null;\n \t\t\tif ( persister.isVersionPropertyGenerated() ) {\n \t\t\t\t// we need to grab the version value from the entity, otherwise\n \t\t\t\t// we have issues with generated-version entities that may have\n \t\t\t\t// multiple actions queued during the same flush\n \t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n \t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n \t\t\tfinal Object ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n \t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n \t\t\t\t@Override\n-\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n+\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n \t\t\t\t\tcache.unlockItem( session, ck, lock );\n \t\t\t\t}\n \t\t\t} );\n \t\t\tcache.remove( source, ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had beforeQuery refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10649 - When 2LC enabled, flush session and then refresh entity cause dirty read in another session / transaction\n",
      "commitDate": "2016-04-06, 5:40 a.m.",
      "commitName": "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b",
      "commitAuthor": "Zhenlei Huang",
      "commitDateOld": "2015-07-01, 6:14 p.m.",
      "commitNameOld": "cffe71aeba38977f526b5ce7e870609ea419471c",
      "commitAuthorOld": "Radim Vansa",
      "daysBetweenCommits": 279.48,
      "commitsBetweenForRepo": 728,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d !source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tObject previousVersion \u003d null;\n\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n\t\t\t\t// we need to grab the version value from the entity, otherwise\n\t\t\t\t// we have issues with generated-version entities that may have\n\t\t\t\t// multiple actions queued during the same flush\n\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n\t\t\t}\n\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n\t\t\t\t@Override\n\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n\t\t\t\t\tcache.unlockItem( session, ck, lock );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tcache.remove( source, ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "diff": "@@ -1,118 +1,132 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n+\t\t\tObject previousVersion \u003d null;\n+\t\t\tif ( persister.isVersionPropertyGenerated() ) {\n+\t\t\t\t// we need to grab the version value from the entity, otherwise\n+\t\t\t\t// we have issues with generated-version entities that may have\n+\t\t\t\t// multiple actions queued during the same flush\n+\t\t\t\tpreviousVersion \u003d persister.getVersion( object );\n+\t\t\t}\n \t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n-\t\t\tObject ck \u003d cache.generateCacheKey(\n+\t\t\tfinal Object ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n-\t\t\tcache.evict( ck );\n+\t\t\tfinal SoftLock lock \u003d cache.lockItem( source, ck, previousVersion );\n+\t\t\tsource.getActionQueue().registerProcess( new AfterTransactionCompletionProcess() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n+\t\t\t\t\tcache.unlockItem( session, ck, lock );\n+\t\t\t\t}\n+\t\t\t} );\n+\t\t\tcache.remove( source, ck );\n \t\t}\n \n-\t\tevictCachedCollections( persister, id, source.getFactory() );\n+\t\tevictCachedCollections( persister, id, source );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cffe71aeba38977f526b5ce7e870609ea419471c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9840 Change all kinds of CacheKey contract to a raw Object\n\n* Replaced all CacheKey with Object\n* Because of statistics, added unwrap operation to all AccessStrategies\n",
      "commitDate": "2015-07-01, 6:14 p.m.",
      "commitName": "cffe71aeba38977f526b5ce7e870609ea419471c",
      "commitAuthor": "Radim Vansa",
      "commitDateOld": "2015-07-01, 3:42 p.m.",
      "commitNameOld": "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
      "commitAuthorOld": "Sanne Grinovero",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d !source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n\t\t\tObject ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tcache.evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 52,
      "functionName": "onRefresh",
      "diff": "@@ -1,118 +1,118 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n-\t\t\tEntityCacheKey ck \u003d cache.generateCacheKey(\n+\t\t\tObject ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister,\n \t\t\t\t\tsource.getFactory(),\n \t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n \t\t\tcache.evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9840 Allow 2nd level cache implementations to customize the various key implementations\n",
      "commitDate": "2015-07-01, 3:42 p.m.",
      "commitName": "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
      "commitAuthor": "Sanne Grinovero",
      "commitDateOld": "2015-05-19, 12:25 a.m.",
      "commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 43.64,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d !source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n\t\t\tEntityCacheKey ck \u003d cache.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister,\n\t\t\t\t\tsource.getFactory(),\n\t\t\t\t\tsource.getTenantIdentifier()\n\t\t\t);\n\t\t\tcache.evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 53,
      "functionName": "onRefresh",
      "diff": "@@ -1,116 +1,118 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tCascade.cascade(\n \t\t\t\tCascadingActions.REFRESH,\n \t\t\t\tCascadePoint.BEFORE_REFRESH,\n \t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n-\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n+\t\t\tfinal EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n+\t\t\tEntityCacheKey ck \u003d cache.generateCacheKey(\n \t\t\t\t\tid,\n-\t\t\t\t\tpersister.getIdentifierType(),\n-\t\t\t\t\tpersister.getRootEntityName()\n+\t\t\t\t\tpersister,\n+\t\t\t\t\tsource.getFactory(),\n+\t\t\t\t\tsource.getTenantIdentifier()\n \t\t\t);\n-\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n+\t\t\tcache.evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb15ee548ca1c8fb80f77497271931404f54c19e": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9328 Avoids creation of Cascade objects at all\nby converting all methods of the Cascade class into\nstatic methods.\n",
      "commitDate": "2014-11-27, 2:43 p.m.",
      "commitName": "fb15ee548ca1c8fb80f77497271931404f54c19e",
      "commitAuthor": "Andrej Golovnin",
      "commitDateOld": "2013-11-23, 11:06 a.m.",
      "commitNameOld": "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 369.15,
      "commitsBetweenForRepo": 357,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d !source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tCascade.cascade(\n\t\t\t\tCascadingActions.REFRESH,\n\t\t\t\tCascadePoint.BEFORE_REFRESH,\n\t\t\t\tsource,\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 69,
      "functionName": "onRefresh",
      "diff": "@@ -1,113 +1,116 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(\n \t\t\t\t\tevent.getEntityName(),\n \t\t\t\t\tobject\n \t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n \t\t\t\t\t\tpersister,\n \t\t\t\t\t\tid,\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev(\n \t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n \t\t\t\t\t\te.getPersister(),\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\tsource.getFactory()\n \t\t\t\t)\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new UnresolvableObjectException(\n \t\t\t\t\t\te.getId(),\n \t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n-\t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n+\t\tCascade.cascade(\n+\t\t\t\tCascadingActions.REFRESH,\n+\t\t\t\tCascadePoint.BEFORE_REFRESH,\n+\t\t\t\tsource,\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity( key );\n \t\t\tif ( persister.hasCollections() ) {\n \t\t\t\tnew EvictVisitor( source ).process( object, persister );\n \t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8741 - More checkstyle cleanups\n",
      "commitDate": "2013-11-23, 11:06 a.m.",
      "commitName": "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013-10-07, 3:20 p.m.",
      "commitNameOld": "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 46.87,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d !source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey( object ) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(\n\t\t\t\t\tevent.getEntityName(),\n\t\t\t\t\tobject\n\t\t\t); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n\t\t\t\t\t\tpersister,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev(\n\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n\t\t\t\t\t\te.getPersister(),\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\tsource.getFactory()\n\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(\n\t\t\t\t\t\te.getId(),\n\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity( key );\n\t\t\tif ( persister.hasCollections() ) {\n\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n\t\t\t}\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( !persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 69,
      "functionName": "onRefresh",
      "diff": "@@ -1,93 +1,113 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n-\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n+\t\tboolean isTransient \u003d !source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n-\t\tif ( refreshedAlready.containsKey(object) ) {\n+\t\tif ( refreshedAlready.containsKey( object ) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n-\t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n+\t\t\tpersister \u003d source.getEntityPersister(\n+\t\t\t\t\tevent.getEntityName(),\n+\t\t\t\t\tobject\n+\t\t\t); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n-\t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n+\t\t\t\tLOG.tracev(\n+\t\t\t\t\t\t\"Refreshing transient {0}\", MessageHelper.infoString(\n+\t\t\t\t\t\tpersister,\n+\t\t\t\t\t\tid,\n+\t\t\t\t\t\tsource.getFactory()\n+\t\t\t\t)\n+\t\t\t\t);\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n-\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n+\t\t\tif ( source.getPersistenceContext().getEntry( key ) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n-\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n-\t\t\t\t\t);\n+\t\t\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n+\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n-\t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n+\t\t\t\tLOG.tracev(\n+\t\t\t\t\t\t\"Refreshing \", MessageHelper.infoString(\n+\t\t\t\t\t\te.getPersister(),\n+\t\t\t\t\t\te.getId(),\n+\t\t\t\t\t\tsource.getFactory()\n+\t\t\t\t)\n+\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n-\t\t\t\tthrow new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\" );\n+\t\t\t\tthrow new UnresolvableObjectException(\n+\t\t\t\t\t\te.getId(),\n+\t\t\t\t\t\t\"this instance does not yet exist as a row in the database\"\n+\t\t\t\t);\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n-\t\t\tsource.getPersistenceContext().removeEntity(key);\n-\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n+\t\t\tsource.getPersistenceContext().removeEntity( key );\n+\t\t\tif ( persister.hasCollections() ) {\n+\t\t\t\tnew EvictVisitor( source ).process( object, persister );\n+\t\t\t}\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n-\t\t\tif ( ! persister.isMutable() ) {\n+\t\t\tif ( !persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n-\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n+\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( previousFetchProfile );\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4428464d096c6a1fff3023cb707a2384ab6c0ffb": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8593 EntityManager.refresh should throw EntityNotFoundException if the entity no longer exists in the database\n",
      "commitDate": "2013-10-07, 3:20 p.m.",
      "commitName": "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
      "commitAuthor": "Scott Marlow",
      "commitDateOld": "2013-04-26, 1:30 p.m.",
      "commitNameOld": "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 164.08,
      "commitsBetweenForRepo": 376,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 72,
      "functionName": "onRefresh",
      "diff": "@@ -1,93 +1,93 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n-\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n+\t\t\t\tthrow new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put( object, object );\n \t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n \t\t\t\tpersister,\n \t\t\t\tobject,\n \t\t\t\trefreshedAlready\n \t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc02da1c12f6a7487b56e76cf817dc72da8314e6": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8159 - Apply fixups indicated by analysis tools\n",
      "commitDate": "2013-04-26, 1:30 p.m.",
      "commitName": "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012-08-16, 3:21 p.m.",
      "commitNameOld": "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 252.92,
      "commitsBetweenForRepo": 561,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put( object, object );\n\t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n\t\t\t\tpersister,\n\t\t\t\tobject,\n\t\t\t\trefreshedAlready\n\t\t);\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 72,
      "functionName": "onRefresh",
      "diff": "@@ -1,90 +1,93 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n-\t\trefreshedAlready.put(object, object);\n-\t\tnew Cascade( CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source)\n-\t\t\t\t.cascade( persister, object, refreshedAlready );\n+\t\trefreshedAlready.put( object, object );\n+\t\tnew Cascade( CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source ).cascade(\n+\t\t\t\tpersister,\n+\t\t\t\tobject,\n+\t\t\t\trefreshedAlready\n+\t\t);\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b5a428b3fed930227ae6a17e3b876c07745d5a3": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7527 - OSGI manifests for hibernate-orm : clean up org.hibernate.engine.spi package duplication between hem and core\n",
      "commitDate": "2012-08-16, 3:21 p.m.",
      "commitName": "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012-03-26, 4:17 a.m.",
      "commitNameOld": "d3b640cb755e20db84d5d528b03e1ae474bb68e7",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 143.46,
      "commitsBetweenForRepo": 263,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade( CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "diff": "@@ -1,90 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n \t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( LOG.isTraceEnabled() ) {\n \t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n-\t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n+\t\tnew Cascade( CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "129c0f13482b99e2705f0e234b6bc0572a95c271": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6732 more logging trace statements are missing guards against unneeded string creation\n",
      "commitDate": "2011-10-26, 6:24 p.m.",
      "commitName": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "commitAuthor": "Sanne Grinovero",
      "commitDateOld": "2011-10-24, 4:26 a.m.",
      "commitNameOld": "bdba5898c90ef7667e7c5df35e72d2e993e32556",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tLOG.trace( \"Already refreshed\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n\t\t\t}\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "diff": "@@ -1,88 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n-            LOG.trace(\"Already refreshed\");\n+\t\t\tLOG.trace( \"Already refreshed\" );\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n-            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n-                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n+\t\t\tif ( LOG.isTraceEnabled() ) {\n+\t\t\t\tLOG.tracev( \"Refreshing transient {0}\", MessageHelper.infoString( persister, id, source.getFactory() ) );\n+\t\t\t}\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n-            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n-                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n+\t\t\tif ( LOG.isTraceEnabled() ) {\n+\t\t\t\tLOG.tracev( \"Refreshing \", MessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory() ) );\n+\t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4489 need method \"refresh(String entityName, Object obj)\"\n",
      "commitDate": "2011-05-31, 2:53 a.m.",
      "commitName": "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2011-05-31, 2:53 a.m.",
      "commitNameOld": "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n            LOG.trace(\"Already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "diff": "@@ -1,88 +1,88 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n             LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n-\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n+\t\t\tpersister \u003d source.getEntityPersister(event.getEntityName(), object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                 + MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb5bc1609d28dc740a249e622850a3b3b15b5ace": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4489 need method \"refresh(String entityName, Object obj)\"\n",
      "commitDate": "2011-05-31, 2:53 a.m.",
      "commitName": "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2011-05-04, 7:20 p.m.",
      "commitNameOld": "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 26.31,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n            LOG.trace(\"Already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "diff": "@@ -1,88 +1,88 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n             LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                 + MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n-\t\tString previousFetchProfile \u003d source.getFetchProfile();\n-\t\tsource.setFetchProfile(\"refresh\");\n+\t\tString previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n+\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile( \"refresh\" );\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n-\t\tsource.setFetchProfile(previousFetchProfile);\n+\t\tsource.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173": {
      "type": "Yfilerename",
      "commitMessage": "HHH-6198 - Split org.hibernate.event package into api/spi/internal\n",
      "commitDate": "2011-05-04, 7:20 p.m.",
      "commitName": "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011-05-04, 6:15 p.m.",
      "commitNameOld": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n            LOG.trace(\"Already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade( CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "diff": "",
      "extendedDetails": {
        "oldPath": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java"
      }
    },
    "47abaf12fa6be50e95b2a3b8b3d424611c873d66": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5697 - Support for multi-tenancy\n",
      "commitDate": "2011-03-26, 11:50 a.m.",
      "commitName": "47abaf12fa6be50e95b2a3b8b3d424611c873d66",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011-03-26, 10:11 a.m.",
      "commitNameOld": "fe8c7183d172946a03818be2cec1c9c2fc819316",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n            LOG.trace(\"Already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "diff": "@@ -1,90 +1,88 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n             LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                 + MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n-\t\t\tfinal CacheKey ck \u003d new CacheKey(\n+\t\t\tfinal CacheKey ck \u003d source.generateCacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n-\t\t\t\t\tpersister.getRootEntityName(),\n-\t\t\t\t\tsource.getEntityMode(),\n-\t\t\t\t\tsource.getFactory()\n+\t\t\t\t\tpersister.getRootEntityName()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fe8c7183d172946a03818be2cec1c9c2fc819316": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5697 - Support for multi-tenancy\n",
      "commitDate": "2011-03-26, 10:11 a.m.",
      "commitName": "fe8c7183d172946a03818be2cec1c9c2fc819316",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011-03-08, 5:19 p.m.",
      "commitNameOld": "346418c4ef7b9a21dc659af43ff614d5db2343f9",
      "commitAuthorOld": "",
      "daysBetweenCommits": 17.66,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n            LOG.trace(\"Already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(),\n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "diff": "@@ -1,90 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n             LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                 + MessageHelper.infoString(persister, id, source.getFactory()));\n-\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n+\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n             if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                 + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n-\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n+\t\t\tfinal EntityKey key \u003d source.generateEntityKey( id, persister );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(),\n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": {
      "type": "Ybodychange",
      "commitMessage": "Give each project a single logger\n",
      "commitDate": "2011-01-18, 5:00 p.m.",
      "commitName": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "commitAuthor": "JPAV",
      "commitDateOld": "2011-01-18, 4:35 p.m.",
      "commitNameOld": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n            LOG.trace(\"Already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(),\n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 68,
      "functionName": "onRefresh",
      "diff": "@@ -1,88 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n-            LOG.alreadyRefreshed();\n+            LOG.trace(\"Already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n-            if (LOG.isTraceEnabled()) LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n+            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing transient \"\n+                                                + MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n-            if (LOG.isTraceEnabled()) LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n+            if (LOG.isTraceEnabled()) LOG.trace(\"Refreshing \"\n+                                                + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(),\n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": {
      "type": "Ybodychange",
      "commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n\u0027d where it was clear how to do so.\n",
      "commitDate": "2011-01-18, 4:35 p.m.",
      "commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthor": "JPAV",
      "commitDateOld": "2010-10-11, 3:41 p.m.",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 99.08,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n            LOG.alreadyRefreshed();\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n            if (LOG.isTraceEnabled()) LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n            if (LOG.isTraceEnabled()) LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(),\n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 72,
      "functionName": "onRefresh",
      "diff": "@@ -1,98 +1,88 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n-\t\t\n+\n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n-\t\t\tlog.trace(\"already refreshed\");\n+            LOG.alreadyRefreshed();\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n-\t\t\n+\n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n-\t\t\tif ( log.isTraceEnabled() ) {\n-\t\t\t\tlog.trace(\n-\t\t\t\t\t\t\"refreshing transient \" +\n-\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n-\t\t\t\t\t);\n-\t\t\t}\n+            if (LOG.isTraceEnabled()) LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tif ( log.isTraceEnabled() ) {\n-\t\t\t\tlog.trace(\n-\t\t\t\t\t\t\"refreshing \" +\n-\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n-\t\t\t\t\t);\n-\t\t\t}\n+            if (LOG.isTraceEnabled()) LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n-\t\t\t\t\tsource.getEntityMode(), \n+\t\t\t\t\tsource.getEntityMode(),\n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n-\t\t\n+\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n-\t\t\n+\n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tif ( ! persister.isMutable() ) {\n \t\t\t\t// this is probably redundant; it should already be read-only\n \t\t\t\tsource.setReadOnly( result, true );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n-\t\t\n+\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
      "commitDate": "2010-10-11, 3:41 p.m.",
      "commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-10-11, 2:51 p.m.",
      "commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java"
      }
    },
    "14bdaec5e75bded557e8410d818a7b77308dd80b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5207 : Unexpected exception occurs during refresh of a detached immutable entity\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19451 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-05-10, 2:34 p.m.",
      "commitName": "14bdaec5e75bded557e8410d818a7b77308dd80b",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2010-02-08, 2:27 p.m.",
      "commitNameOld": "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 90.96,
      "commitsBetweenForRepo": 285,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tif ( ! persister.isMutable() ) {\n\t\t\t\t// this is probably redundant; it should already be read-only\n\t\t\t\tsource.setReadOnly( result, true );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t\t}\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "diff": "@@ -1,92 +1,98 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\t\n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n-\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n+\t\t\tif ( ! persister.isMutable() ) {\n+\t\t\t\t// this is probably redundant; it should already be read-only\n+\t\t\t\tsource.setReadOnly( result, true );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n+\t\t\t}\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4704 - Pass session into EntityTuplizer#setIdentifier\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18733 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-02-08, 2:27 p.m.",
      "commitName": "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-02-05, 1:25 a.m.",
      "commitNameOld": "c18a9306b9f8995331240b66c01fea304e01d06f",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 3.54,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "diff": "@@ -1,92 +1,92 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\t\n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n-\t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n+\t\t\tid \u003d persister.getIdentifier( object, event.getSession() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n \t\tif ( result !\u003d null ) {\n \t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c18a9306b9f8995331240b66c01fea304e01d06f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4880 : EntityManager.refresh does not throw EntityNotFoundException for removed entity\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18700 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-02-05, 1:25 a.m.",
      "commitName": "c18a9306b9f8995331240b66c01fea304e01d06f",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2010-01-27, 4:26 a.m.",
      "commitNameOld": "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 8.87,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tif ( result !\u003d null ) {\n\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\t}\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "diff": "@@ -1,90 +1,92 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\t\n \t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n \t\t\tif ( isTransient ) {\n \t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n \t\t// If it was transient, then set it to the default for the source.\n-\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n+\t\tif ( result !\u003d null ) {\n+\t\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n+\t\t}\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b40cfb58dbe4606609c3fa2b1e5e210466c593df": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4781 : Read-only entities changed to modifiable on refresh\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18643 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-27, 4:26 a.m.",
      "commitName": "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2009-11-24, 6:59 p.m.",
      "commitNameOld": "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 63.39,
      "commitsBetweenForRepo": 262,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n\t\t\tif ( isTransient ) {\n\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n\t\t// If it was transient, then set it to the default for the source.\n\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "diff": "@@ -1,81 +1,90 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\t\n-\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n+\t\tboolean isTransient \u003d ! source.contains( event.getObject() );\n+\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) {\n+\t\t\tif ( isTransient ) {\n+\t\t\t\tsource.setReadOnly( event.getObject(), source.isDefaultReadOnly() );\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n \t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n+\t\t// Keep the same read-only/modifiable setting for the entity that it had before refreshing;\n+\t\t// If it was transient, then set it to the default for the source.\n+\t\tsource.setReadOnly( result, ( e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly() ) );\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4546 add JPA 2.0 locking.  Introduce LockOptions as the wrapper and session.buildLockRequest() (replaces session.lock()).\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18053 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-11-24, 6:59 p.m.",
      "commitName": "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
      "commitAuthor": "Scott Marlow",
      "commitDateOld": "2009-11-20, 9:51 a.m.",
      "commitNameOld": "35ca4c35635f26b9a86b260ad974ba7da429950b",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "diff": "@@ -1,81 +1,81 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\t\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n-\t\tObject result \u003d persister.load( id, object, event.getLockRequest(), source );\n+\t\tObject result \u003d persister.load( id, object, event.getLockOptions(), source );\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35ca4c35635f26b9a86b260ad974ba7da429950b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4546 add JPA 2.0 locking.  Still need more LockRequest support in AbstractEntityPersister.getAppropriateLoader(), may need to refactor.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18016 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-11-20, 9:51 a.m.",
      "commitName": "35ca4c35635f26b9a86b260ad974ba7da429950b",
      "commitAuthor": "Scott Marlow",
      "commitDateOld": "2008-07-30, 12:46 p.m.",
      "commitNameOld": "0d464c2be26dda9d44613dea80f3f32e2e9ef011",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 477.92,
      "commitsBetweenForRepo": 628,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockRequest(), source );\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "diff": "@@ -1,81 +1,81 @@\n \tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n \n \t\tfinal EventSource source \u003d event.getSession();\n \t\t\n \t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n \n \t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n \n \t\tif ( refreshedAlready.containsKey(object) ) {\n \t\t\tlog.trace(\"already refreshed\");\n \t\t\treturn;\n \t\t}\n \n \t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n \t\tfinal EntityPersister persister;\n \t\tfinal Serializable id;\n \t\t\n \t\tif ( e \u003d\u003d null ) {\n \t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n \t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing transient \" +\n \t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n \t\t\t\tthrow new PersistentObjectException(\n \t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n \t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n \t\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( log.isTraceEnabled() ) {\n \t\t\t\tlog.trace(\n \t\t\t\t\t\t\"refreshing \" +\n \t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n \t\t\t\t\t);\n \t\t\t}\n \t\t\tif ( !e.isExistsInDatabase() ) {\n \t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n \t\t\t}\n \n \t\t\tpersister \u003d e.getPersister();\n \t\t\tid \u003d e.getId();\n \t\t}\n \n \t\t// cascade the refresh prior to refreshing this entity\n \t\trefreshedAlready.put(object, object);\n \t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n \t\t\t\t.cascade( persister, object, refreshedAlready );\n \n \t\tif ( e !\u003d null ) {\n \t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n \t\t\tsource.getPersistenceContext().removeEntity(key);\n \t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n \t\t}\n \n \t\tif ( persister.hasCache() ) {\n \t\t\tfinal CacheKey ck \u003d new CacheKey(\n \t\t\t\t\tid,\n \t\t\t\t\tpersister.getIdentifierType(),\n \t\t\t\t\tpersister.getRootEntityName(),\n \t\t\t\t\tsource.getEntityMode(), \n \t\t\t\t\tsource.getFactory()\n \t\t\t);\n \t\t\tpersister.getCacheAccessStrategy().evict( ck );\n \t\t}\n \t\t\n \t\tevictCachedCollections( persister, id, source.getFactory() );\n \t\t\n \t\tString previousFetchProfile \u003d source.getFetchProfile();\n \t\tsource.setFetchProfile(\"refresh\");\n-\t\tObject result \u003d persister.load( id, object, event.getLockMode(), source );\n+\t\tObject result \u003d persister.load( id, object, event.getLockRequest(), source );\n \t\tsource.setFetchProfile(previousFetchProfile);\n \t\t\n \t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a797998927e2cbba9ec34ca7dc31b42a192fa2f1": {
      "type": "Yfilerename",
      "commitMessage": "splitting code back out into individual modules (found better way to isolate documentation)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@12771 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2007-07-16, 11:15 p.m.",
      "commitName": "a797998927e2cbba9ec34ca7dc31b42a192fa2f1",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2007-07-16, 12:18 a.m.",
      "commitNameOld": "9fda5ffa294695f1a1a2e349232f64d80ef26250",
      "commitAuthorOld": "Diego Plentz",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockMode(), source );\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 47,
      "functionName": "onRefresh",
      "diff": "",
      "extendedDetails": {
        "oldPath": "code/core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
        "newPath": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java"
      }
    },
    "d8d6d82e30960e0c255950eaf875ad48831b12b0": {
      "type": "Yintroduced",
      "commitMessage": "SVN layout migration for core/trunk\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@11722 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2007-06-29, 3:23 p.m.",
      "commitName": "d8d6d82e30960e0c255950eaf875ad48831b12b0",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,81 @@\n+\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n+\n+\t\tfinal EventSource source \u003d event.getSession();\n+\t\t\n+\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n+\n+\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n+\n+\t\tif ( refreshedAlready.containsKey(object) ) {\n+\t\t\tlog.trace(\"already refreshed\");\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n+\t\tfinal EntityPersister persister;\n+\t\tfinal Serializable id;\n+\t\t\n+\t\tif ( e \u003d\u003d null ) {\n+\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n+\t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n+\t\t\tif ( log.isTraceEnabled() ) {\n+\t\t\t\tlog.trace(\n+\t\t\t\t\t\t\"refreshing transient \" +\n+\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n+\t\t\t\t\t);\n+\t\t\t}\n+\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n+\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n+\t\t\t\tthrow new PersistentObjectException(\n+\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n+\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n+\t\t\t\t\t);\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tif ( log.isTraceEnabled() ) {\n+\t\t\t\tlog.trace(\n+\t\t\t\t\t\t\"refreshing \" +\n+\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n+\t\t\t\t\t);\n+\t\t\t}\n+\t\t\tif ( !e.isExistsInDatabase() ) {\n+\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n+\t\t\t}\n+\n+\t\t\tpersister \u003d e.getPersister();\n+\t\t\tid \u003d e.getId();\n+\t\t}\n+\n+\t\t// cascade the refresh prior to refreshing this entity\n+\t\trefreshedAlready.put(object, object);\n+\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n+\t\t\t\t.cascade( persister, object, refreshedAlready );\n+\n+\t\tif ( e !\u003d null ) {\n+\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n+\t\t\tsource.getPersistenceContext().removeEntity(key);\n+\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n+\t\t}\n+\n+\t\tif ( persister.hasCache() ) {\n+\t\t\tfinal CacheKey ck \u003d new CacheKey(\n+\t\t\t\t\tid,\n+\t\t\t\t\tpersister.getIdentifierType(),\n+\t\t\t\t\tpersister.getRootEntityName(),\n+\t\t\t\t\tsource.getEntityMode(), \n+\t\t\t\t\tsource.getFactory()\n+\t\t\t);\n+\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n+\t\t}\n+\t\t\n+\t\tevictCachedCollections( persister, id, source.getFactory() );\n+\t\t\n+\t\tString previousFetchProfile \u003d source.getFetchProfile();\n+\t\tsource.setFetchProfile(\"refresh\");\n+\t\tObject result \u003d persister.load( id, object, event.getLockMode(), source );\n+\t\tsource.setFetchProfile(previousFetchProfile);\n+\t\t\n+\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n+\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic void onRefresh(RefreshEvent event, Map refreshedAlready) {\n\n\t\tfinal EventSource source \u003d event.getSession();\n\t\t\n\t\tif ( source.getPersistenceContext().reassociateIfUninitializedProxy( event.getObject() ) ) return;\n\n\t\tfinal Object object \u003d source.getPersistenceContext().unproxyAndReassociate( event.getObject() );\n\n\t\tif ( refreshedAlready.containsKey(object) ) {\n\t\t\tlog.trace(\"already refreshed\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal EntityEntry e \u003d source.getPersistenceContext().getEntry( object );\n\t\tfinal EntityPersister persister;\n\t\tfinal Serializable id;\n\t\t\n\t\tif ( e \u003d\u003d null ) {\n\t\t\tpersister \u003d source.getEntityPersister(null, object); //refresh() does not pass an entityName\n\t\t\tid \u003d persister.getIdentifier( object, event.getSession().getEntityMode() );\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing transient \" +\n\t\t\t\t\t\tMessageHelper.infoString( persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tif ( source.getPersistenceContext().getEntry(key) !\u003d null ) {\n\t\t\t\tthrow new PersistentObjectException(\n\t\t\t\t\t\t\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" +\n\t\t\t\t\t\tMessageHelper.infoString(persister, id, source.getFactory() )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( log.isTraceEnabled() ) {\n\t\t\t\tlog.trace(\n\t\t\t\t\t\t\"refreshing \" +\n\t\t\t\t\t\tMessageHelper.infoString( e.getPersister(), e.getId(), source.getFactory()  )\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !e.isExistsInDatabase() ) {\n\t\t\t\tthrow new HibernateException( \"this instance does not yet exist as a row in the database\" );\n\t\t\t}\n\n\t\t\tpersister \u003d e.getPersister();\n\t\t\tid \u003d e.getId();\n\t\t}\n\n\t\t// cascade the refresh prior to refreshing this entity\n\t\trefreshedAlready.put(object, object);\n\t\tnew Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source)\n\t\t\t\t.cascade( persister, object, refreshedAlready );\n\n\t\tif ( e !\u003d null ) {\n\t\t\tEntityKey key \u003d new EntityKey( id, persister, source.getEntityMode() );\n\t\t\tsource.getPersistenceContext().removeEntity(key);\n\t\t\tif ( persister.hasCollections() ) new EvictVisitor( source ).process(object, persister);\n\t\t}\n\n\t\tif ( persister.hasCache() ) {\n\t\t\tfinal CacheKey ck \u003d new CacheKey(\n\t\t\t\t\tid,\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tpersister.getRootEntityName(),\n\t\t\t\t\tsource.getEntityMode(), \n\t\t\t\t\tsource.getFactory()\n\t\t\t);\n\t\t\tpersister.getCacheAccessStrategy().evict( ck );\n\t\t}\n\t\t\n\t\tevictCachedCollections( persister, id, source.getFactory() );\n\t\t\n\t\tString previousFetchProfile \u003d source.getFetchProfile();\n\t\tsource.setFetchProfile(\"refresh\");\n\t\tObject result \u003d persister.load( id, object, event.getLockMode(), source );\n\t\tsource.setFetchProfile(previousFetchProfile);\n\t\t\n\t\tUnresolvableObjectException.throwIfNull( result, id, persister.getEntityName() );\n\n\t}",
      "path": "code/core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 47,
      "functionName": "onRefresh"
    }
  }
}