{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "H:\\Projects\\apache\\commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "NumberUtils.java",
  "functionName": "isCreatable",
  "functionId": "isCreatable___str-String(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
  "functionStartLine": 1398,
  "functionEndLine": 1509,
  "numCommitsSeen": 180,
  "timeTaken": 2566,
  "changeHistory": [
    "c8e61afdb89c58ea8ffaf04593da41ff0888d30e",
    "c3b1fefbad0c67c8556ba6b4573f135197f87598",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
    "b3c31a379e9ad7cd22cb7f0669b82361ced84992",
    "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
    "cf03e6173b70ad64337704402bea51600cddd1ba",
    "9397608dd35a335d5e14813c0923f9419782980a",
    "5a509030a946646780e963b9f492a4eaff734116",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818",
    "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "26bc3fe010d5154d3ccac526ec22c429fc3af499",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "0531f837cba9ad5a34b12f26310f05f593b3b7e0",
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb"
  ],
  "changeHistoryShort": {
    "c8e61afdb89c58ea8ffaf04593da41ff0888d30e": "Ybodychange",
    "c3b1fefbad0c67c8556ba6b4573f135197f87598": "Ybodychange",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": "Ybodychange",
    "b3c31a379e9ad7cd22cb7f0669b82361ced84992": "Ybodychange",
    "c503d742f094dc2048b72c3f78f5e2e6070a44e1": "Ymultichange(Yrename,Ybodychange)",
    "cf03e6173b70ad64337704402bea51600cddd1ba": "Ybodychange",
    "9397608dd35a335d5e14813c0923f9419782980a": "Ybodychange",
    "5a509030a946646780e963b9f492a4eaff734116": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818": "Ybodychange",
    "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "26bc3fe010d5154d3ccac526ec22c429fc3af499": "Ybodychange",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "0531f837cba9ad5a34b12f26310f05f593b3b7e0": "Ybodychange",
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": "Ybodychange",
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c8e61afdb89c58ea8ffaf04593da41ff0888d30e": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1060: NumberUtils.isNumber assumes number starting with Zero is octal (closes #313)\n",
      "commitDate": "2018-02-11, 6:08 a.m.",
      "commitName": "c8e61afdb89c58ea8ffaf04593da41ff0888d30e",
      "commitAuthor": "Piotr Kosmala",
      "commitDateOld": "2018-02-11, 5:49 a.m.",
      "commitNameOld": "c3b1fefbad0c67c8556ba6b4573f135197f87598",
      "commitAuthorOld": "pascalschumacher",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isCreatable(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 !StringUtils.contains(str, \u0027.\u0027)) { // leading 0, skip if is a decimal number\n            if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) { // leading 0x/0X\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n           } else if (Character.isDigit(chars[start + 1])) {\n               // leading 0, but not hex, must be octal\n               int i \u003d start + 1;\n               for (; i \u003c chars.length; i++) {\n                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                       return false;\n                   }\n               }\n               return true;\n           }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1398,
      "functionName": "isCreatable",
      "diff": "@@ -1,112 +1,112 @@\n     public static boolean isCreatable(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n-        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n+        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 !StringUtils.contains(str, \u0027.\u0027)) { // leading 0, skip if is a decimal number\n             if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) { // leading 0x/0X\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n            } else if (Character.isDigit(chars[start + 1])) {\n                // leading 0, but not hex, must be octal\n                int i \u003d start + 1;\n                for (; i \u003c chars.length; i++) {\n                    if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3b1fefbad0c67c8556ba6b4573f135197f87598": {
      "type": "Ybodychange",
      "commitMessage": "NumberUtils#isCreatable: remove java 6 only code, as commons-lang requires at java 7+ now\n",
      "commitDate": "2018-02-11, 5:49 a.m.",
      "commitName": "c3b1fefbad0c67c8556ba6b4573f135197f87598",
      "commitAuthor": "pascalschumacher",
      "commitDateOld": "2017-06-06, 9:12 a.m.",
      "commitNameOld": "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 249.9,
      "commitsBetweenForRepo": 146,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isCreatable(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n            if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) { // leading 0x/0X\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n           } else if (Character.isDigit(chars[start + 1])) {\n               // leading 0, but not hex, must be octal\n               int i \u003d start + 1;\n               for (; i \u003c chars.length; i++) {\n                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                       return false;\n                   }\n               }\n               return true;\n           }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1398,
      "functionName": "isCreatable",
      "diff": "@@ -1,116 +1,112 @@\n     public static boolean isCreatable(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n-        final boolean hasLeadingPlusSign \u003d start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027;\n         if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n             if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) { // leading 0x/0X\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n            } else if (Character.isDigit(chars[start + 1])) {\n                // leading 0, but not hex, must be octal\n                int i \u003d start + 1;\n                for (; i \u003c chars.length; i++) {\n                    if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n-                if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n-                    return false;\n-                }\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Remove useless parentheses\n",
      "commitDate": "2016-09-19, 7:56 a.m.",
      "commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2016-09-11, 1:00 p.m.",
      "commitNameOld": "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01",
      "commitAuthorOld": "Rob Tompkins",
      "daysBetweenCommits": 7.79,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isCreatable(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n        final boolean hasLeadingPlusSign \u003d start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n            if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) { // leading 0x/0X\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n           } else if (Character.isDigit(chars[start + 1])) {\n               // leading 0, but not hex, must be octal\n               int i \u003d start + 1;\n               for (; i \u003c chars.length; i++) {\n                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                       return false;\n                   }\n               }\n               return true;               \n           }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                    return false;\n                }\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1401,
      "functionName": "isCreatable",
      "diff": "@@ -1,119 +1,116 @@\n     public static boolean isCreatable(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n-        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n-        final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n+        final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n+        final boolean hasLeadingPlusSign \u003d start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027;\n         if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n-            if (\n-                 (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n-                 (chars[start + 1] \u003d\u003d \u0027X\u0027) \n-            ) { // leading 0x/0X\n+            if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) { // leading 0x/0X\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n            } else if (Character.isDigit(chars[start + 1])) {\n                // leading 0, but not hex, must be octal\n                int i \u003d start + 1;\n                for (; i \u003c chars.length; i++) {\n                    if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                        return false;\n                    }\n                }\n                return true;               \n            }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n-        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n+        while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                     return false;\n                 }\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b3c31a379e9ad7cd22cb7f0669b82361ced84992": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1252: replacing system call for java 1.6 to SystemUtils.IS_JAVA_1_6\n",
      "commitDate": "2016-09-11, 10:54 a.m.",
      "commitName": "b3c31a379e9ad7cd22cb7f0669b82361ced84992",
      "commitAuthor": "Rob Tompkins",
      "commitDateOld": "2016-09-10, 9:43 p.m.",
      "commitNameOld": "71d9e00d42b278ce9d216b33bf1a9c8606fbcb49",
      "commitAuthorOld": "Rob Tompkins",
      "daysBetweenCommits": 0.55,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isCreatable(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n        final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n            if (\n                 (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                 (chars[start + 1] \u003d\u003d \u0027X\u0027) \n            ) { // leading 0x/0X\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n           } else if (Character.isDigit(chars[start + 1])) {\n               // leading 0, but not hex, must be octal\n               int i \u003d start + 1;\n               for (; i \u003c chars.length; i++) {\n                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                       return false;\n                   }\n               }\n               return true;               \n           }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                    return false;\n                }\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1401,
      "functionName": "isCreatable",
      "diff": "@@ -1,121 +1,119 @@\n     public static boolean isCreatable(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n-        boolean isJava6 \u003d StringUtils.startsWith(\n-                System.getProperty(\"java.version\"), \"1.6\");\n         // deal with any possible sign up front\n         final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n         final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n         if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n             if (\n                  (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                  (chars[start + 1] \u003d\u003d \u0027X\u0027) \n             ) { // leading 0x/0X\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n            } else if (Character.isDigit(chars[start + 1])) {\n                // leading 0, but not hex, must be octal\n                int i \u003d start + 1;\n                for (; i \u003c chars.length; i++) {\n                    if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                        return false;\n                    }\n                }\n                return true;               \n            }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n-                if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n+                if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                     return false;\n                 }\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c503d742f094dc2048b72c3f78f5e2e6070a44e1": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "LANG-1252: better naming and java 6 specifics around handling a leading +\n",
      "commitDate": "2016-09-10, 9:01 p.m.",
      "commitName": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
      "commitAuthor": "Rob Tompkins",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "LANG-1252: better naming and java 6 specifics around handling a leading +\n",
          "commitDate": "2016-09-10, 9:01 p.m.",
          "commitName": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
          "commitAuthor": "Rob Tompkins",
          "commitDateOld": "2016-06-12, 7:23 a.m.",
          "commitNameOld": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
          "commitAuthorOld": "Nick Manley",
          "daysBetweenCommits": 90.57,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static boolean isCreatable(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n        // deal with any possible sign up front\n        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n        final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n            if (\n                 (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                 (chars[start + 1] \u003d\u003d \u0027X\u0027) \n            ) { // leading 0x/0X\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n           } else if (Character.isDigit(chars[start + 1])) {\n               // leading 0, but not hex, must be octal\n               int i \u003d start + 1;\n               for (; i \u003c chars.length; i++) {\n                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                       return false;\n                   }\n               }\n               return true;               \n           }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                    return false;\n                }\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 1398,
          "functionName": "isCreatable",
          "diff": "@@ -1,115 +1,120 @@\n-    public static boolean isNumber(final String str) {\n+    public static boolean isCreatable(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n+        boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n         // deal with any possible sign up front\n-        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n+        final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n         if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n             if (\n                  (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                  (chars[start + 1] \u003d\u003d \u0027X\u0027) \n             ) { // leading 0x/0X\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n            } else if (Character.isDigit(chars[start + 1])) {\n                // leading 0, but not hex, must be octal\n                int i \u003d start + 1;\n                for (; i \u003c chars.length; i++) {\n                    if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                        return false;\n                    }\n                }\n                return true;               \n            }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+                if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n+                    return false;\n+                }\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "isNumber",
            "newValue": "isCreatable"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-1252: better naming and java 6 specifics around handling a leading +\n",
          "commitDate": "2016-09-10, 9:01 p.m.",
          "commitName": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
          "commitAuthor": "Rob Tompkins",
          "commitDateOld": "2016-06-12, 7:23 a.m.",
          "commitNameOld": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
          "commitAuthorOld": "Nick Manley",
          "daysBetweenCommits": 90.57,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static boolean isCreatable(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n        // deal with any possible sign up front\n        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n        final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n            if (\n                 (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                 (chars[start + 1] \u003d\u003d \u0027X\u0027) \n            ) { // leading 0x/0X\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n           } else if (Character.isDigit(chars[start + 1])) {\n               // leading 0, but not hex, must be octal\n               int i \u003d start + 1;\n               for (; i \u003c chars.length; i++) {\n                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                       return false;\n                   }\n               }\n               return true;               \n           }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                    return false;\n                }\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 1398,
          "functionName": "isCreatable",
          "diff": "@@ -1,115 +1,120 @@\n-    public static boolean isNumber(final String str) {\n+    public static boolean isCreatable(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n+        boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n         // deal with any possible sign up front\n-        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n+        final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n         if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n             if (\n                  (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                  (chars[start + 1] \u003d\u003d \u0027X\u0027) \n             ) { // leading 0x/0X\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n            } else if (Character.isDigit(chars[start + 1])) {\n                // leading 0, but not hex, must be octal\n                int i \u003d start + 1;\n                for (; i \u003c chars.length; i++) {\n                    if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                        return false;\n                    }\n                }\n                return true;               \n            }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+                if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n+                    return false;\n+                }\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "cf03e6173b70ad64337704402bea51600cddd1ba": {
      "type": "Ybodychange",
      "commitMessage": "LANG-992 Fix NumberUtils#isNumber() returns false for \"0.0\", \"0.4790\", et al\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1582585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-03-27, 11:10 p.m.",
      "commitName": "cf03e6173b70ad64337704402bea51600cddd1ba",
      "commitAuthor": "Niall Pemberton",
      "commitDateOld": "2014-02-10, 9:57 p.m.",
      "commitNameOld": "3269d1bc7a28ba4536d4c1ac5a9aaadf5b8f48c3",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 45.01,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n            if (\n                 (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                 (chars[start + 1] \u003d\u003d \u0027X\u0027) \n            ) { // leading 0x/0X\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n           } else if (Character.isDigit(chars[start + 1])) {\n               // leading 0, but not hex, must be octal\n               int i \u003d start + 1;\n               for (; i \u003c chars.length; i++) {\n                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                       return false;\n                   }\n               }\n               return true;               \n           }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1337,
      "functionName": "isNumber",
      "diff": "@@ -1,114 +1,115 @@\n     public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n         if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n             if (\n                  (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                  (chars[start + 1] \u003d\u003d \u0027X\u0027) \n             ) { // leading 0x/0X\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n-           } else { // leading 0, but not hex, must be octal\n+           } else if (Character.isDigit(chars[start + 1])) {\n+               // leading 0, but not hex, must be octal\n                int i \u003d start + 1;\n                for (; i \u003c chars.length; i++) {\n                    if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                        return false;\n                    }\n                }\n                return true;               \n            }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9397608dd35a335d5e14813c0923f9419782980a": {
      "type": "Ybodychange",
      "commitMessage": "LANG-971 NumberUtils#isNumber(String) fails to reject invalid Octal numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1566967 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-02-10, 9:53 p.m.",
      "commitName": "9397608dd35a335d5e14813c0923f9419782980a",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014-02-10, 9:34 p.m.",
      "commitNameOld": "5a509030a946646780e963b9f492a4eaff734116",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n            if (\n                 (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                 (chars[start + 1] \u003d\u003d \u0027X\u0027) \n            ) { // leading 0x/0X\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n           } else { // leading 0, but not hex, must be octal\n               int i \u003d start + 1;\n               for (; i \u003c chars.length; i++) {\n                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                       return false;\n                   }\n               }\n               return true;               \n           }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1336,
      "functionName": "isNumber",
      "diff": "@@ -1,107 +1,114 @@\n     public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n-        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027\n-                           \u0026\u0026 \n-                           (\n-                             (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n-                             (chars[start + 1] \u003d\u003d \u0027X\u0027) \n-                           )\n-           ) {\n-            int i \u003d start + 2;\n-            if (i \u003d\u003d sz) {\n-                return false; // str \u003d\u003d \"0x\"\n-            }\n-            // checking hex (it can\u0027t be anything else)\n-            for (; i \u003c chars.length; i++) {\n-                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n-                    \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n-                    \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n-                    return false;\n+        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) { // leading 0\n+            if (\n+                 (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n+                 (chars[start + 1] \u003d\u003d \u0027X\u0027) \n+            ) { // leading 0x/0X\n+                int i \u003d start + 2;\n+                if (i \u003d\u003d sz) {\n+                    return false; // str \u003d\u003d \"0x\"\n                 }\n-            }\n-            return true;\n+                // checking hex (it can\u0027t be anything else)\n+                for (; i \u003c chars.length; i++) {\n+                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n+                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n+                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+           } else { // leading 0, but not hex, must be octal\n+               int i \u003d start + 1;\n+               for (; i \u003c chars.length; i++) {\n+                   if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n+                       return false;\n+                   }\n+               }\n+               return true;               \n+           }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5a509030a946646780e963b9f492a4eaff734116": {
      "type": "Ybodychange",
      "commitMessage": "LANG-972 NumberUtils#isNumber does not allow for hex 0XABCD\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1566963 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-02-10, 9:34 p.m.",
      "commitName": "5a509030a946646780e963b9f492a4eaff734116",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014-02-06, 8:29 a.m.",
      "commitNameOld": "5a001837b4ae6ca3b55f61179577f6d1d8f38d37",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 4.55,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027\n                           \u0026\u0026 \n                           (\n                             (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n                             (chars[start + 1] \u003d\u003d \u0027X\u0027) \n                           )\n           ) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false; // str \u003d\u003d \"0x\"\n            }\n            // checking hex (it can\u0027t be anything else)\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                    \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                    \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1336,
      "functionName": "isNumber",
      "diff": "@@ -1,101 +1,107 @@\n     public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n-        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n+        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027\n+                           \u0026\u0026 \n+                           (\n+                             (chars[start + 1] \u003d\u003d \u0027x\u0027) || \n+                             (chars[start + 1] \u003d\u003d \u0027X\u0027) \n+                           )\n+           ) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false; // str \u003d\u003d \"0x\"\n             }\n             // checking hex (it can\u0027t be anything else)\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                     \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                     \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:09 a.m.",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013-01-22, 2:07 a.m.",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        final char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false; // str \u003d\u003d \"0x\"\n            }\n            // checking hex (it can\u0027t be anything else)\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                    \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                    \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1310,
      "functionName": "isNumber",
      "diff": "@@ -1,101 +1,101 @@\n     public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n-        char[] chars \u003d str.toCharArray();\n+        final char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n-        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+        final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n         if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false; // str \u003d\u003d \"0x\"\n             }\n             // checking hex (it can\u0027t be anything else)\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                     \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                     \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:07 a.m.",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012-11-13, 8:21 a.m.",
      "commitNameOld": "f5a83bb90cf7b318ac72823e6b99d01d060abe41",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 69.74,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false; // str \u003d\u003d \"0x\"\n            }\n            // checking hex (it can\u0027t be anything else)\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                    \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                    \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1310,
      "functionName": "isNumber",
      "diff": "@@ -1,101 +1,101 @@\n-    public static boolean isNumber(String str) {\n+    public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n         if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false; // str \u003d\u003d \"0x\"\n             }\n             // checking hex (it can\u0027t be anything else)\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                     \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                     \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[str-String]",
        "newValue": "[str-String(modifiers-final)]"
      }
    },
    "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD issues: \"These nested if statements could be combined\"\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1153241 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-08-02, 2:49 p.m.",
      "commitName": "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011-07-19, 4:53 p.m.",
      "commitNameOld": "2c3fa8366e133200d2a6e0c7f309a876ff9b8675",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 13.91,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false; // str \u003d\u003d \"0x\"\n            }\n            // checking hex (it can\u0027t be anything else)\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                    \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                    \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1311,
      "functionName": "isNumber",
      "diff": "@@ -1,103 +1,101 @@\n     public static boolean isNumber(String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n-        if (sz \u003e start + 1) {\n-            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n-                int i \u003d start + 2;\n-                if (i \u003d\u003d sz) {\n-                    return false; // str \u003d\u003d \"0x\"\n-                }\n-                // checking hex (it can\u0027t be anything else)\n-                for (; i \u003c chars.length; i++) {\n-                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n-                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n-                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n+        if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n+            int i \u003d start + 2;\n+            if (i \u003d\u003d sz) {\n+                return false; // str \u003d\u003d \"0x\"\n             }\n+            // checking hex (it can\u0027t be anything else)\n+            for (; i \u003c chars.length; i++) {\n+                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n+                    \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n+                    \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036": {
      "type": "Ybodychange",
      "commitMessage": "Fixing NumberUtils.isNumber so that 1.1L is not considered a number. LANG-664\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1054202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-01-01, 1:56 a.m.",
      "commitName": "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2010-08-03, 12:41 a.m.",
      "commitNameOld": "50c1fdecb4ed33ec1bb0d449f294c299d5369701",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 151.09,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1) {\n            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent or decimal point\n                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1319,
      "functionName": "isNumber",
      "diff": "@@ -1,103 +1,103 @@\n     public static boolean isNumber(String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n         if (sz \u003e start + 1) {\n             if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n-                // not allowing L with an exponent\n-                return foundDigit \u0026\u0026 !hasExp;\n+                // not allowing L with an exponent or decimal point\n+                return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-01-02, 9:11 p.m.",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010-01-02, 9:09 p.m.",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1) {\n            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent\n                return foundDigit \u0026\u0026 !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1312,
      "functionName": "isNumber",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
      }
    },
    "26bc3fe010d5154d3ccac526ec22c429fc3af499": {
      "type": "Ybodychange",
      "commitMessage": "isNumber(String) and createNumber(String) both modified to support \"2.\". LANG-521\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@893088 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-22, 1:52 a.m.",
      "commitName": "26bc3fe010d5154d3ccac526ec22c429fc3af499",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-12-10, 6:56 a.m.",
      "commitNameOld": "c6e8f706dc7a236cc2a49f979d857ee92d0abd7c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1) {\n            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent\n                return foundDigit \u0026\u0026 !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1312,
      "functionName": "isNumber",
      "diff": "@@ -1,95 +1,103 @@\n     public static boolean isNumber(String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n         if (sz \u003e start + 1) {\n             if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n+            if (chars[i] \u003d\u003d \u0027.\u0027) {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent\n+                    return false;\n+                }\n+                // single trailing decimal point after non-exponent is ok\n+                return foundDigit;\n+            }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent\n                 return foundDigit \u0026\u0026 !hasExp;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-10, 6:33 a.m.",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-12-10, 6:31 a.m.",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1) {\n            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent\n                return foundDigit \u0026\u0026 !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1312,
      "functionName": "isNumber",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/math/NumberUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java"
      }
    },
    "0531f837cba9ad5a34b12f26310f05f593b3b7e0": {
      "type": "Ybodychange",
      "commitMessage": "Using StringUtils.isEmpty() when testing Strings.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137705 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-11-04, 3:26 p.m.",
      "commitName": "0531f837cba9ad5a34b12f26310f05f593b3b7e0",
      "commitAuthor": "Fredrik Westermarck",
      "commitDateOld": "2003-09-23, 1:02 p.m.",
      "commitNameOld": "c978c7f029c19a87cf14b4af9a3dc22b812c5190",
      "commitAuthorOld": "Fredrik Westermarck",
      "daysBetweenCommits": 42.14,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1) {\n            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent\n                return foundDigit \u0026\u0026 !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 1341,
      "functionName": "isNumber",
      "diff": "@@ -1,95 +1,95 @@\n     public static boolean isNumber(String str) {\n-        if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n+        if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n         if (sz \u003e start + 1) {\n             if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n                 // not allowing L with an exponent\n                 return foundDigit \u0026\u0026 !hasExp;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": {
      "type": "Ybodychange",
      "commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-09-07, 10:32 a.m.",
      "commitName": "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "2003-09-05, 11:55 a.m.",
      "commitNameOld": "69b8f445d74f22ba99a75c47a38d97d5e85248cc",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isNumber(String str) {\n        if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1) {\n            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponent\n                return foundDigit \u0026\u0026 !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 1243,
      "functionName": "isNumber",
      "diff": "@@ -1,95 +1,95 @@\n     public static boolean isNumber(String str) {\n         if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n             return false;\n         }\n         char[] chars \u003d str.toCharArray();\n         int sz \u003d chars.length;\n         boolean hasExp \u003d false;\n         boolean hasDecPoint \u003d false;\n         boolean allowSigns \u003d false;\n         boolean foundDigit \u003d false;\n         // deal with any possible sign up front\n         int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n         if (sz \u003e start + 1) {\n             if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                 int i \u003d start + 2;\n                 if (i \u003d\u003d sz) {\n                     return false; // str \u003d\u003d \"0x\"\n                 }\n                 // checking hex (it can\u0027t be anything else)\n                 for (; i \u003c chars.length; i++) {\n                     if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                         \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n         }\n         sz--; // don\u0027t want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i \u003d start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n         while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 foundDigit \u003d true;\n                 allowSigns \u003d false;\n \n             } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // we\u0027ve already taken care of hex.\n                 if (hasExp) {\n                     // two E\u0027s\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp \u003d true;\n                 allowSigns \u003d true;\n             } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns \u003d false;\n                 foundDigit \u003d false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i \u003c chars.length) {\n             if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                 // can\u0027t have an E at the last byte\n                 return false;\n             }\n             if (!allowSigns\n                 \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                     || chars[i] \u003d\u003d \u0027D\u0027\n                     || chars[i] \u003d\u003d \u0027f\u0027\n                     || chars[i] \u003d\u003d \u0027F\u0027)) {\n                 return foundDigit;\n             }\n             if (chars[i] \u003d\u003d \u0027l\u0027\n                 || chars[i] \u003d\u003d \u0027L\u0027) {\n-                // not allowing L with an exponoent\n+                // not allowing L with an exponent\n                 return foundDigit \u0026\u0026 !hasExp;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in \u0027E\u0027\n         // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n         return !allowSigns \u0026\u0026 foundDigit;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb": {
      "type": "Yintroduced",
      "commitMessage": "NumberUtils moved to math subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137379 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-06-24, 5:14 p.m.",
      "commitName": "2d06a7ce861432fc702168fd4c94bc00ddfc39eb",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,95 @@\n+    public static boolean isNumber(String str) {\n+        if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n+            return false;\n+        }\n+        char[] chars \u003d str.toCharArray();\n+        int sz \u003d chars.length;\n+        boolean hasExp \u003d false;\n+        boolean hasDecPoint \u003d false;\n+        boolean allowSigns \u003d false;\n+        boolean foundDigit \u003d false;\n+        // deal with any possible sign up front\n+        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+        if (sz \u003e start + 1) {\n+            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n+                int i \u003d start + 2;\n+                if (i \u003d\u003d sz) {\n+                    return false; // str \u003d\u003d \"0x\"\n+                }\n+                // checking hex (it can\u0027t be anything else)\n+                for (; i \u003c chars.length; i++) {\n+                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n+                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n+                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        sz--; // don\u0027t want to loop to the last char, check it afterwords\n+              // for type qualifiers\n+        int i \u003d start;\n+        // loop to the next to last char or to the last char if we need another digit to\n+        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n+        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n+            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+                foundDigit \u003d true;\n+                allowSigns \u003d false;\n+\n+            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent   \n+                    return false;\n+                }\n+                hasDecPoint \u003d true;\n+            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n+                // we\u0027ve already taken care of hex.\n+                if (hasExp) {\n+                    // two E\u0027s\n+                    return false;\n+                }\n+                if (!foundDigit) {\n+                    return false;\n+                }\n+                hasExp \u003d true;\n+                allowSigns \u003d true;\n+            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n+                if (!allowSigns) {\n+                    return false;\n+                }\n+                allowSigns \u003d false;\n+                foundDigit \u003d false; // we need a digit after the E\n+            } else {\n+                return false;\n+            }\n+            i++;\n+        }\n+        if (i \u003c chars.length) {\n+            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+                // no type qualifier, OK\n+                return true;\n+            }\n+            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n+                // can\u0027t have an E at the last byte\n+                return false;\n+            }\n+            if (!allowSigns\n+                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n+                    || chars[i] \u003d\u003d \u0027D\u0027\n+                    || chars[i] \u003d\u003d \u0027f\u0027\n+                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n+                return foundDigit;\n+            }\n+            if (chars[i] \u003d\u003d \u0027l\u0027\n+                || chars[i] \u003d\u003d \u0027L\u0027) {\n+                // not allowing L with an exponoent\n+                return foundDigit \u0026\u0026 !hasExp;\n+            }\n+            // last character is illegal\n+            return false;\n+        }\n+        // allowSigns is true iff the val ends in \u0027E\u0027\n+        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n+        return !allowSigns \u0026\u0026 foundDigit;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public static boolean isNumber(String str) {\n        if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n            return false;\n        }\n        char[] chars \u003d str.toCharArray();\n        int sz \u003d chars.length;\n        boolean hasExp \u003d false;\n        boolean hasDecPoint \u003d false;\n        boolean allowSigns \u003d false;\n        boolean foundDigit \u003d false;\n        // deal with any possible sign up front\n        int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n        if (sz \u003e start + 1) {\n            if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n                int i \u003d start + 2;\n                if (i \u003d\u003d sz) {\n                    return false; // str \u003d\u003d \"0x\"\n                }\n                // checking hex (it can\u0027t be anything else)\n                for (; i \u003c chars.length; i++) {\n                    if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027)\n                        \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don\u0027t want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i \u003d start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] \u003d \"1234E\")\n        while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                foundDigit \u003d true;\n                allowSigns \u003d false;\n\n            } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // we\u0027ve already taken care of hex.\n                if (hasExp) {\n                    // two E\u0027s\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp \u003d true;\n                allowSigns \u003d true;\n            } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns \u003d false;\n                foundDigit \u003d false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i \u003c chars.length) {\n            if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n                // can\u0027t have an E at the last byte\n                return false;\n            }\n            if (!allowSigns\n                \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027\n                    || chars[i] \u003d\u003d \u0027D\u0027\n                    || chars[i] \u003d\u003d \u0027f\u0027\n                    || chars[i] \u003d\u003d \u0027F\u0027)) {\n                return foundDigit;\n            }\n            if (chars[i] \u003d\u003d \u0027l\u0027\n                || chars[i] \u003d\u003d \u0027L\u0027) {\n                // not allowing L with an exponoent\n                return foundDigit \u0026\u0026 !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in \u0027E\u0027\n        // found digit it to make sure weird stuff like \u0027.\u0027 and \u00271E-\u0027 doesn\u0027t pass\n        return !allowSigns \u0026\u0026 foundDigit;\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 803,
      "functionName": "isNumber"
    }
  }
}