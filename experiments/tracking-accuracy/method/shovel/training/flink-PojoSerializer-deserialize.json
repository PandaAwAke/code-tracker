{
  "origin": "codeshovel",
  "repositoryName": "flink",
  "repositoryPath": "H:\\Projects\\apache\\flink/.git",
  "startCommitName": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd",
  "sourceFileName": "PojoSerializer.java",
  "functionName": "deserialize",
  "functionId": "deserialize___source-DataInputView",
  "sourceFilePath": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
  "functionStartLine": 369,
  "functionEndLine": 428,
  "numCommitsSeen": 24,
  "timeTaken": 2046,
  "changeHistory": [
    "ae285f9bd5398fe4d8d86eb3207bbc5beb8a24c8",
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5",
    "21a715867d655bb61df9a9f7eef37e42b99e206a",
    "7407076d3990752eb5fa4072cd036efd2f656cbc",
    "926f835adb9cb77bcda19e4ed009cc07c89cea74",
    "76d4a75e823c31a899f2143fb6be185b90e55532"
  ],
  "changeHistoryShort": {
    "ae285f9bd5398fe4d8d86eb3207bbc5beb8a24c8": "Ybodychange",
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5": "Ybodychange",
    "21a715867d655bb61df9a9f7eef37e42b99e206a": "Yfilerename",
    "7407076d3990752eb5fa4072cd036efd2f656cbc": "Ybodychange",
    "926f835adb9cb77bcda19e4ed009cc07c89cea74": "Ybodychange",
    "76d4a75e823c31a899f2143fb6be185b90e55532": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ae285f9bd5398fe4d8d86eb3207bbc5beb8a24c8": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-6801] [core] Allow deserialized PojoSerializer to have removed fields\n\nPrior to this commit, deserializing the PojoSerializer would fail when\nwe encounter a missing field that existed in the POJO type before. It is\nactually perfectly fine to have a missing field; the deserialized\nPojoSerializer should simply skip reading the removed field\u0027s previously\nserialized values, i.e. much like how Java Object Serialization works.\n\nThis commit relaxes the deserialization of the PojoSerializer, so that a\nnull will be used as a placeholder value to indicate a removed field\nthat previously existed. De-/serialization and copying methods on the\nPojoSerializer will respect null Fields and simply skip them.\n",
      "commitDate": "2017-06-13, 12:38 a.m.",
      "commitName": "ae285f9bd5398fe4d8d86eb3207bbc5beb8a24c8",
      "commitAuthor": "Tzu-Li (Gordon) Tai",
      "commitDateOld": "2017-06-13, 12:38 a.m.",
      "commitNameOld": "c929eb30867bb1f539c98fe9e47f91790bd85764",
      "commitAuthorOld": "Tzu-Li (Gordon) Tai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic T deserialize(DataInputView source) throws IOException {\n\t\tint flags \u003d source.readByte();\n\t\tif((flags \u0026 IS_NULL) !\u003d 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tT target;\n\n\t\tClass\u003c?\u003e actualSubclass \u003d null;\n\t\tTypeSerializer subclassSerializer \u003d null;\n\n\t\tif ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n\t\t\tString subclassName \u003d source.readUTF();\n\t\t\ttry {\n\t\t\t\tactualSubclass \u003d Class.forName(subclassName, true, cl);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", e);\n\t\t\t}\n\t\t\tsubclassSerializer \u003d getSubclassSerializer(actualSubclass);\n\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n\t\t\t// also initialize fields for which the subclass serializer is not responsible\n\t\t\tinitializeFields(target);\n\t\t} else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n\n\t\t\tint subclassTag \u003d source.readByte();\n\t\t\tsubclassSerializer \u003d registeredSerializers[subclassTag];\n\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n\t\t\t// also initialize fields for which the subclass serializer is not responsible\n\t\t\tinitializeFields(target);\n\t\t} else {\n\t\t\ttarget \u003d createInstance();\n\t\t}\n\n\t\tif ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n\t\t\ttry {\n\t\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n\t\t\t\t\tboolean isNull \u003d source.readBoolean();\n\n\t\t\t\t\tif (fields[i] !\u003d null) {\n\t\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\t\tfields[i].set(target, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n\t\t\t\t\t\t\tfields[i].set(target, field);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!isNull) {\n\t\t\t\t\t\t// read and dump a pre-existing field value\n\t\t\t\t\t\tfieldSerializers[i].deserialize(source);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\", e);\n\t\t\t}\n\t\t} else {\n\t\t\tif (subclassSerializer !\u003d null) {\n\t\t\t\ttarget \u003d (T) subclassSerializer.deserialize(target, source);\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 369,
      "functionName": "deserialize",
      "diff": "@@ -1,54 +1,60 @@\n \tpublic T deserialize(DataInputView source) throws IOException {\n \t\tint flags \u003d source.readByte();\n \t\tif((flags \u0026 IS_NULL) !\u003d 0) {\n \t\t\treturn null;\n \t\t}\n \n \t\tT target;\n \n \t\tClass\u003c?\u003e actualSubclass \u003d null;\n \t\tTypeSerializer subclassSerializer \u003d null;\n \n \t\tif ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n \t\t\tString subclassName \u003d source.readUTF();\n \t\t\ttry {\n \t\t\t\tactualSubclass \u003d Class.forName(subclassName, true, cl);\n \t\t\t} catch (ClassNotFoundException e) {\n \t\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", e);\n \t\t\t}\n \t\t\tsubclassSerializer \u003d getSubclassSerializer(actualSubclass);\n \t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n \t\t\t// also initialize fields for which the subclass serializer is not responsible\n \t\t\tinitializeFields(target);\n \t\t} else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n \n \t\t\tint subclassTag \u003d source.readByte();\n \t\t\tsubclassSerializer \u003d registeredSerializers[subclassTag];\n \t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n \t\t\t// also initialize fields for which the subclass serializer is not responsible\n \t\t\tinitializeFields(target);\n \t\t} else {\n \t\t\ttarget \u003d createInstance();\n \t\t}\n \n \t\tif ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n \t\t\ttry {\n \t\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n \t\t\t\t\tboolean isNull \u003d source.readBoolean();\n-\t\t\t\t\tif (isNull) {\n-\t\t\t\t\t\tfields[i].set(target, null);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n-\t\t\t\t\t\tfields[i].set(target, field);\n+\n+\t\t\t\t\tif (fields[i] !\u003d null) {\n+\t\t\t\t\t\tif (isNull) {\n+\t\t\t\t\t\t\tfields[i].set(target, null);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n+\t\t\t\t\t\t\tfields[i].set(target, field);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (!isNull) {\n+\t\t\t\t\t\t// read and dump a pre-existing field value\n+\t\t\t\t\t\tfieldSerializers[i].deserialize(source);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} catch (IllegalAccessException e) {\n \t\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\", e);\n \t\t\t}\n \t\t} else {\n \t\t\tif (subclassSerializer !\u003d null) {\n \t\t\t\ttarget \u003d (T) subclassSerializer.deserialize(target, source);\n \t\t\t}\n \t\t}\n \t\treturn target;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-6178] [core] Allow serializer upgrades for managed state\n\nThis commit adds the functionality of allowing serializer upgrades for\nFlink\u0027s managed state. It consists of 2 major changes: 1) new\nuser-facing API in `TypeSerializer`, and 2) activate serializer upgrades\nin state backends.\n\nFor 1) new user-facing API for `TypeSerializer`, the following is added:\n- new class: TypeSerializerConfigSnapshot\n- new class: CompatibilityResult\n- new method: TypeSerializer#snapshotConfiguration()\n- new method:\n  TypeSerializer#ensureCompatibility(TypeSerializerConfigSnapshot)\n\nGenerally speaking, configuration snapshots contains a point-in-time\nview of a serializer\u0027s state / configuration, and is persisted along\nwith checkpoints. On restore, the configuration is confronted with the\nnew serializer of the state to check for compatibility, which may\nintroduce reconfiguration of the new serializer to be compatible.\n\nThis compatibility check is integrated in the state backends\u0027 restore\nflow in 2). Currently, if the check results in the need to perform state\nmigration, the restore simply fails as the state migration feature isn\u0027t\nyet available.\n",
      "commitDate": "2017-05-07, 2:04 p.m.",
      "commitName": "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5",
      "commitAuthor": "Tzu-Li (Gordon) Tai",
      "commitDateOld": "2017-02-19, 7:01 p.m.",
      "commitNameOld": "082d40fdc415952737a109c913a86d009ed234c1",
      "commitAuthorOld": "Fabian Hueske",
      "daysBetweenCommits": 76.75,
      "commitsBetweenForRepo": 545,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic T deserialize(DataInputView source) throws IOException {\n\t\tint flags \u003d source.readByte();\n\t\tif((flags \u0026 IS_NULL) !\u003d 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tT target;\n\n\t\tClass\u003c?\u003e actualSubclass \u003d null;\n\t\tTypeSerializer subclassSerializer \u003d null;\n\n\t\tif ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n\t\t\tString subclassName \u003d source.readUTF();\n\t\t\ttry {\n\t\t\t\tactualSubclass \u003d Class.forName(subclassName, true, cl);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", e);\n\t\t\t}\n\t\t\tsubclassSerializer \u003d getSubclassSerializer(actualSubclass);\n\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n\t\t\t// also initialize fields for which the subclass serializer is not responsible\n\t\t\tinitializeFields(target);\n\t\t} else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n\n\t\t\tint subclassTag \u003d source.readByte();\n\t\t\tsubclassSerializer \u003d registeredSerializers[subclassTag];\n\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n\t\t\t// also initialize fields for which the subclass serializer is not responsible\n\t\t\tinitializeFields(target);\n\t\t} else {\n\t\t\ttarget \u003d createInstance();\n\t\t}\n\n\t\tif ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n\t\t\ttry {\n\t\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n\t\t\t\t\tboolean isNull \u003d source.readBoolean();\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\tfields[i].set(target, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n\t\t\t\t\t\tfields[i].set(target, field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\", e);\n\t\t\t}\n\t\t} else {\n\t\t\tif (subclassSerializer !\u003d null) {\n\t\t\t\ttarget \u003d (T) subclassSerializer.deserialize(target, source);\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 340,
      "functionName": "deserialize",
      "diff": "@@ -1,55 +1,54 @@\n \tpublic T deserialize(DataInputView source) throws IOException {\n \t\tint flags \u003d source.readByte();\n \t\tif((flags \u0026 IS_NULL) !\u003d 0) {\n \t\t\treturn null;\n \t\t}\n \n \t\tT target;\n \n \t\tClass\u003c?\u003e actualSubclass \u003d null;\n \t\tTypeSerializer subclassSerializer \u003d null;\n \n \t\tif ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n \t\t\tString subclassName \u003d source.readUTF();\n \t\t\ttry {\n \t\t\t\tactualSubclass \u003d Class.forName(subclassName, true, cl);\n \t\t\t} catch (ClassNotFoundException e) {\n \t\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", e);\n \t\t\t}\n \t\t\tsubclassSerializer \u003d getSubclassSerializer(actualSubclass);\n \t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n \t\t\t// also initialize fields for which the subclass serializer is not responsible\n \t\t\tinitializeFields(target);\n \t\t} else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n \n \t\t\tint subclassTag \u003d source.readByte();\n \t\t\tsubclassSerializer \u003d registeredSerializers[subclassTag];\n \t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n \t\t\t// also initialize fields for which the subclass serializer is not responsible\n \t\t\tinitializeFields(target);\n \t\t} else {\n \t\t\ttarget \u003d createInstance();\n \t\t}\n \n \t\tif ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n \t\t\ttry {\n \t\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n \t\t\t\t\tboolean isNull \u003d source.readBoolean();\n \t\t\t\t\tif (isNull) {\n \t\t\t\t\t\tfields[i].set(target, null);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n \t\t\t\t\t\tfields[i].set(target, field);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} catch (IllegalAccessException e) {\n-\t\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n-\n+\t\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\", e);\n \t\t\t}\n \t\t} else {\n \t\t\tif (subclassSerializer !\u003d null) {\n \t\t\t\ttarget \u003d (T) subclassSerializer.deserialize(target, source);\n \t\t\t}\n \t\t}\n \t\treturn target;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "21a715867d655bb61df9a9f7eef37e42b99e206a": {
      "type": "Yfilerename",
      "commitMessage": "[FLINK-3303] [core] Move all type utilities to flink-core\n",
      "commitDate": "2016-02-02, 10:55 a.m.",
      "commitName": "21a715867d655bb61df9a9f7eef37e42b99e206a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016-02-02, 10:55 a.m.",
      "commitNameOld": "7081836e0d640ee640687606bd73b6673d3f2a07",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic T deserialize(DataInputView source) throws IOException {\n\t\tint flags \u003d source.readByte();\n\t\tif((flags \u0026 IS_NULL) !\u003d 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tT target;\n\n\t\tClass\u003c?\u003e actualSubclass \u003d null;\n\t\tTypeSerializer subclassSerializer \u003d null;\n\n\t\tif ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n\t\t\tString subclassName \u003d source.readUTF();\n\t\t\ttry {\n\t\t\t\tactualSubclass \u003d Class.forName(subclassName, true, cl);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", e);\n\t\t\t}\n\t\t\tsubclassSerializer \u003d getSubclassSerializer(actualSubclass);\n\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n\t\t\t// also initialize fields for which the subclass serializer is not responsible\n\t\t\tinitializeFields(target);\n\t\t} else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n\n\t\t\tint subclassTag \u003d source.readByte();\n\t\t\tsubclassSerializer \u003d registeredSerializers[subclassTag];\n\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n\t\t\t// also initialize fields for which the subclass serializer is not responsible\n\t\t\tinitializeFields(target);\n\t\t} else {\n\t\t\ttarget \u003d createInstance();\n\t\t}\n\n\t\tif ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n\t\t\ttry {\n\t\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n\t\t\t\t\tboolean isNull \u003d source.readBoolean();\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\tfields[i].set(target, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n\t\t\t\t\t\tfields[i].set(target, field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n\n\t\t\t}\n\t\t} else {\n\t\t\tif (subclassSerializer !\u003d null) {\n\t\t\t\ttarget \u003d (T) subclassSerializer.deserialize(target, source);\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 391,
      "functionName": "deserialize",
      "diff": "",
      "extendedDetails": {
        "oldPath": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
        "newPath": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java"
      }
    },
    "7407076d3990752eb5fa4072cd036efd2f656cbc": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1369] [types] Add support for Subclasses, Interfaces, Abstract Classes.\n\n- Abstract classes with fields are handled as POJO types.\n- Interfaces and abstract classes without fields are handled as generic types.\n\nThis closes #236\nThis closes #316\n",
      "commitDate": "2015-02-10, 7:15 a.m.",
      "commitName": "7407076d3990752eb5fa4072cd036efd2f656cbc",
      "commitAuthor": "Aljoscha Krettek",
      "commitDateOld": "2015-02-09, 7:19 a.m.",
      "commitNameOld": "7bc78cbf97d341ebfed32fdfe20f21e4d146a869",
      "commitAuthorOld": "Aljoscha Krettek",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic T deserialize(DataInputView source) throws IOException {\n\t\tint flags \u003d source.readByte();\n\t\tif((flags \u0026 IS_NULL) !\u003d 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tT target;\n\n\t\tClass\u003c?\u003e actualSubclass \u003d null;\n\t\tTypeSerializer subclassSerializer \u003d null;\n\n\t\tif ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n\t\t\tString subclassName \u003d source.readUTF();\n\t\t\ttry {\n\t\t\t\tactualSubclass \u003d Class.forName(subclassName, true, cl);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", e);\n\t\t\t}\n\t\t\tsubclassSerializer \u003d getSubclassSerializer(actualSubclass);\n\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n\t\t\t// also initialize fields for which the subclass serializer is not responsible\n\t\t\tinitializeFields(target);\n\t\t} else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n\n\t\t\tint subclassTag \u003d source.readByte();\n\t\t\tsubclassSerializer \u003d registeredSerializers[subclassTag];\n\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n\t\t\t// also initialize fields for which the subclass serializer is not responsible\n\t\t\tinitializeFields(target);\n\t\t} else {\n\t\t\ttarget \u003d createInstance();\n\t\t}\n\n\t\tif ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n\t\t\ttry {\n\t\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n\t\t\t\t\tboolean isNull \u003d source.readBoolean();\n\t\t\t\t\tif (isNull) {\n\t\t\t\t\t\tfields[i].set(target, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n\t\t\t\t\t\tfields[i].set(target, field);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n\n\t\t\t}\n\t\t} else {\n\t\t\tif (subclassSerializer !\u003d null) {\n\t\t\t\ttarget \u003d (T) subclassSerializer.deserialize(target, source);\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 382,
      "functionName": "deserialize",
      "diff": "@@ -1,29 +1,55 @@\n \tpublic T deserialize(DataInputView source) throws IOException {\n-\t\tboolean isNull \u003d source.readBoolean();\n-\t\tif(isNull) {\n+\t\tint flags \u003d source.readByte();\n+\t\tif((flags \u0026 IS_NULL) !\u003d 0) {\n \t\t\treturn null;\n \t\t}\n+\n \t\tT target;\n-\t\ttry {\n-\t\t\ttarget \u003d clazz.newInstance();\n-\t\t}\n-\t\tcatch (Throwable t) {\n-\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", t);\n-\t\t}\n-\t\t\n-\t\ttry {\n-\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n-\t\t\t\tisNull \u003d source.readBoolean();\n-\t\t\t\tif(isNull) {\n-\t\t\t\t\tfields[i].set(target, null);\n-\t\t\t\t} else {\n-\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n-\t\t\t\t\tfields[i].set(target, field);\n-\t\t\t\t}\n+\n+\t\tClass\u003c?\u003e actualSubclass \u003d null;\n+\t\tTypeSerializer subclassSerializer \u003d null;\n+\n+\t\tif ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n+\t\t\tString subclassName \u003d source.readUTF();\n+\t\t\ttry {\n+\t\t\t\tactualSubclass \u003d Class.forName(subclassName, true, cl);\n+\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", e);\n \t\t\t}\n-\t\t} catch (IllegalAccessException e) {\n-\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" +\n-\t\t\t\t\t\"before.\");\n+\t\t\tsubclassSerializer \u003d getSubclassSerializer(actualSubclass);\n+\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n+\t\t\t// also initialize fields for which the subclass serializer is not responsible\n+\t\t\tinitializeFields(target);\n+\t\t} else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n+\n+\t\t\tint subclassTag \u003d source.readByte();\n+\t\t\tsubclassSerializer \u003d registeredSerializers[subclassTag];\n+\t\t\ttarget \u003d (T) subclassSerializer.createInstance();\n+\t\t\t// also initialize fields for which the subclass serializer is not responsible\n+\t\t\tinitializeFields(target);\n+\t\t} else {\n+\t\t\ttarget \u003d createInstance();\n+\t\t}\n+\n+\t\tif ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n+\t\t\ttry {\n+\t\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n+\t\t\t\t\tboolean isNull \u003d source.readBoolean();\n+\t\t\t\t\tif (isNull) {\n+\t\t\t\t\t\tfields[i].set(target, null);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n+\t\t\t\t\t\tfields[i].set(target, field);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n+\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (subclassSerializer !\u003d null) {\n+\t\t\t\ttarget \u003d (T) subclassSerializer.deserialize(target, source);\n+\t\t\t}\n \t\t}\n \t\treturn target;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "926f835adb9cb77bcda19e4ed009cc07c89cea74": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1032] Rework support for POJO types in the Java API\n",
      "commitDate": "2014-10-08, 5:39 a.m.",
      "commitName": "926f835adb9cb77bcda19e4ed009cc07c89cea74",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014-09-30, 9:10 a.m.",
      "commitNameOld": "76d4a75e823c31a899f2143fb6be185b90e55532",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 7.85,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic T deserialize(DataInputView source) throws IOException {\n\t\tboolean isNull \u003d source.readBoolean();\n\t\tif(isNull) {\n\t\t\treturn null;\n\t\t}\n\t\tT target;\n\t\ttry {\n\t\t\ttarget \u003d clazz.newInstance();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", t);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n\t\t\t\tisNull \u003d source.readBoolean();\n\t\t\t\tif(isNull) {\n\t\t\t\t\tfields[i].set(target, null);\n\t\t\t\t} else {\n\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n\t\t\t\t\tfields[i].set(target, field);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" +\n\t\t\t\t\t\"before.\");\n\t\t}\n\t\treturn target;\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 201,
      "functionName": "deserialize",
      "diff": "@@ -1,20 +1,29 @@\n \tpublic T deserialize(DataInputView source) throws IOException {\n+\t\tboolean isNull \u003d source.readBoolean();\n+\t\tif(isNull) {\n+\t\t\treturn null;\n+\t\t}\n \t\tT target;\n \t\ttry {\n \t\t\ttarget \u003d clazz.newInstance();\n \t\t}\n \t\tcatch (Throwable t) {\n \t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", t);\n \t\t}\n \t\t\n \t\ttry {\n \t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n-\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n-\t\t\t\tfields[i].set(target, field);\n+\t\t\t\tisNull \u003d source.readBoolean();\n+\t\t\t\tif(isNull) {\n+\t\t\t\t\tfields[i].set(target, null);\n+\t\t\t\t} else {\n+\t\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n+\t\t\t\t\tfields[i].set(target, field);\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (IllegalAccessException e) {\n \t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" +\n \t\t\t\t\t\"before.\");\n \t\t}\n \t\treturn target;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76d4a75e823c31a899f2143fb6be185b90e55532": {
      "type": "Yintroduced",
      "commitMessage": "[FLINK-1005] Extend TypeSerializer interface to handle non-mutable object deserialization more efficiently.\n",
      "commitDate": "2014-09-30, 9:10 a.m.",
      "commitName": "76d4a75e823c31a899f2143fb6be185b90e55532",
      "commitAuthor": "Stephan Ewen",
      "diff": "@@ -0,0 +1,20 @@\n+\tpublic T deserialize(DataInputView source) throws IOException {\n+\t\tT target;\n+\t\ttry {\n+\t\t\ttarget \u003d clazz.newInstance();\n+\t\t}\n+\t\tcatch (Throwable t) {\n+\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", t);\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n+\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n+\t\t\t\tfields[i].set(target, field);\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" +\n+\t\t\t\t\t\"before.\");\n+\t\t}\n+\t\treturn target;\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic T deserialize(DataInputView source) throws IOException {\n\t\tT target;\n\t\ttry {\n\t\t\ttarget \u003d clazz.newInstance();\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow new RuntimeException(\"Cannot instantiate class.\", t);\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tfor (int i \u003d 0; i \u003c numFields; i++) {\n\t\t\t\tObject field \u003d fieldSerializers[i].deserialize(source);\n\t\t\t\tfields[i].set(target, field);\n\t\t\t}\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" +\n\t\t\t\t\t\"before.\");\n\t\t}\n\t\treturn target;\n\t}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 190,
      "functionName": "deserialize"
    }
  }
}