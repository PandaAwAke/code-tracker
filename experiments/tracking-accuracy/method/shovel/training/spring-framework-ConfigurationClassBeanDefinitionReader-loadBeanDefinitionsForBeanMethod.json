{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "H:\\Projects\\spring-projects\\spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "ConfigurationClassBeanDefinitionReader.java",
  "functionName": "loadBeanDefinitionsForBeanMethod",
  "functionId": "loadBeanDefinitionsForBeanMethod___beanMethod-BeanMethod",
  "sourceFilePath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
  "functionStartLine": 174,
  "functionEndLine": 274,
  "numCommitsSeen": 161,
  "timeTaken": 8227,
  "changeHistory": [
    "c037e75f26ac5ef69e4d5fc3045e101ca674dcaf",
    "fc699b2b3784413bb7348b8c2a92eb2ab871479f",
    "81cb740e0ae23b6bd167f5c42ceae8294a27a14a",
    "bca5a362168e2dad27f273966857fb2f6b9fcd88",
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "e892e02f41031ae18f09aef34bf82d31ddbb12c7",
    "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
    "aae0bd2fb43092bd3e1bc5c3296265e760b4fc43",
    "2d23f42609c2e6a2ee6b0507f4b800870a63ca26",
    "0ed9ca097bb499b46c67d34d59e08a1337758097",
    "bb5b5d52edf60350f09cf11c41e6fba534bebb54",
    "981aefc2c0d2a6fbf9c08d4d54d17923a75a2e01",
    "f46c706e443860e9ada7768a16cfa01526c10645",
    "6d80da2e3129044df2294e5c3e7fb137b9286e6a",
    "fe8dec912d53db4819064b50d667c34300bb59b1",
    "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
    "239ce1466ce118294f5c7b8e842a80815fd813de",
    "b257253a2b6890ef532f27a662c441fc4fd21f3b",
    "6b82d293d5ed2ec6f4e02432594a73e354d17928",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "52bef0b7b024e794186437dee78945fbb5bd209a",
    "cf0fc278bbc5ef4a3b08cc0a98d581ee8f930eae",
    "0a790c143feeabf571e98f8ee0700a4586cbb67c",
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
    "6b2b5c4c233bba63fa5da2b11146ffaf66f9de80",
    "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9",
    "c7b019cd5c5285d81f0aea967be8af021eac8b07",
    "f519406c37b23eef816704baeb3a496f7430bb89",
    "ec1f0e6211172f43e842aabef8d4c66d946d99f2",
    "da71f266aed8c3dbea7c995ab4e2f3dae51cca45",
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
    "cea8f7f69e8939d4d20073862890f0b1c1824499",
    "b5d21108da24f8344be3bc708c7afdfca9a1d089",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
    "14bd47551900ced88eeacf2a5f63c187ff72028c",
    "69a762e86ac075035bfcdc899aadf2b36abaf167",
    "1697932c57af5389fe07971e91866980e966403f",
    "7f96f57375d3b33d08bf3be6d5206066f3142cfe",
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
    "ef02c61e581dcd1f3cf110608da72ed133777d62",
    "8a5c2a6a56e7b88b44af7111edb2bfc8b1781f48",
    "dc191bec2dfceb7ee052ac238c84eb564d27e1ee",
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
    "c593f063970df90d7de7b85c6da5733aadcafde6",
    "e48fe0d89271113bcac4e7c41e86cb1d8230594e"
  ],
  "changeHistoryShort": {
    "c037e75f26ac5ef69e4d5fc3045e101ca674dcaf": "Ybodychange",
    "fc699b2b3784413bb7348b8c2a92eb2ab871479f": "Ybodychange",
    "81cb740e0ae23b6bd167f5c42ceae8294a27a14a": "Ybodychange",
    "bca5a362168e2dad27f273966857fb2f6b9fcd88": "Ybodychange",
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ybodychange",
    "e892e02f41031ae18f09aef34bf82d31ddbb12c7": "Ybodychange",
    "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7": "Ybodychange",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": "Ybodychange",
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc": "Ybodychange",
    "aae0bd2fb43092bd3e1bc5c3296265e760b4fc43": "Ybodychange",
    "2d23f42609c2e6a2ee6b0507f4b800870a63ca26": "Ybodychange",
    "0ed9ca097bb499b46c67d34d59e08a1337758097": "Ybodychange",
    "bb5b5d52edf60350f09cf11c41e6fba534bebb54": "Ybodychange",
    "981aefc2c0d2a6fbf9c08d4d54d17923a75a2e01": "Ybodychange",
    "f46c706e443860e9ada7768a16cfa01526c10645": "Ybodychange",
    "6d80da2e3129044df2294e5c3e7fb137b9286e6a": "Ybodychange",
    "fe8dec912d53db4819064b50d667c34300bb59b1": "Ybodychange",
    "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65": "Ybodychange",
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": "Ybodychange",
    "239ce1466ce118294f5c7b8e842a80815fd813de": "Ybodychange",
    "b257253a2b6890ef532f27a662c441fc4fd21f3b": "Ybodychange",
    "6b82d293d5ed2ec6f4e02432594a73e354d17928": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "52bef0b7b024e794186437dee78945fbb5bd209a": "Ybodychange",
    "cf0fc278bbc5ef4a3b08cc0a98d581ee8f930eae": "Ybodychange",
    "0a790c143feeabf571e98f8ee0700a4586cbb67c": "Yparameterchange",
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "6b2b5c4c233bba63fa5da2b11146ffaf66f9de80": "Ybodychange",
    "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9": "Ybodychange",
    "c7b019cd5c5285d81f0aea967be8af021eac8b07": "Ybodychange",
    "f519406c37b23eef816704baeb3a496f7430bb89": "Ybodychange",
    "ec1f0e6211172f43e842aabef8d4c66d946d99f2": "Ybodychange",
    "da71f266aed8c3dbea7c995ab4e2f3dae51cca45": "Ybodychange",
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0": "Ybodychange",
    "cea8f7f69e8939d4d20073862890f0b1c1824499": "Ybodychange",
    "b5d21108da24f8344be3bc708c7afdfca9a1d089": "Ybodychange",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": "Ybodychange",
    "14bd47551900ced88eeacf2a5f63c187ff72028c": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "69a762e86ac075035bfcdc899aadf2b36abaf167": "Ybodychange",
    "1697932c57af5389fe07971e91866980e966403f": "Yfilerename",
    "7f96f57375d3b33d08bf3be6d5206066f3142cfe": "Ybodychange",
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7": "Yfilerename",
    "ef02c61e581dcd1f3cf110608da72ed133777d62": "Yfilerename",
    "8a5c2a6a56e7b88b44af7111edb2bfc8b1781f48": "Ybodychange",
    "dc191bec2dfceb7ee052ac238c84eb564d27e1ee": "Ybodychange",
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4": "Ybodychange",
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39": "Ymultichange(Yparameterchange,Ybodychange)",
    "c593f063970df90d7de7b85c6da5733aadcafde6": "Yfilerename",
    "e48fe0d89271113bcac4e7c41e86cb1d8230594e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c037e75f26ac5ef69e4d5fc3045e101ca674dcaf": {
      "type": "Ybodychange",
      "commitMessage": "Improve debug logging at BeanDefinitionReader and BeanFactory level\n\nIssue: SPR-17090\n",
      "commitDate": "2018-07-27, 11:46 a.m.",
      "commitName": "c037e75f26ac5ef69e4d5fc3045e101ca674dcaf",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018-07-20, 9:05 a.m.",
      "commitNameOld": "9a43d2ec208d2e8cd0866431acf26af3529f8677",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 7.11,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n\n\t\t// Consider name and any aliases\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n\t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method \u0027\" + beanMethod.getMetadata().getMethodName() +\n\t\t\t\t\t\t\"\u0027 clashes with bean name for containing configuration class; please make those names unique!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n\t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tboolean autowireCandidate \u003d bean.getBoolean(\"autowireCandidate\");\n\t\tif (!autowireCandidate) {\n\t\t\tbeanDef.setAutowireCandidate(false);\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n\t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 174,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,102 +1,101 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n \n \t\t// Consider name and any aliases\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n \t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n \t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method \u0027\" + beanMethod.getMetadata().getMethodName() +\n \t\t\t\t\t\t\"\u0027 clashes with bean name for containing configuration class; please make those names unique!\");\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n \t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tboolean autowireCandidate \u003d bean.getBoolean(\"autowireCandidate\");\n \t\tif (!autowireCandidate) {\n \t\t\tbeanDef.setAutowireCandidate(false);\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n-\t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n+\t\tif (logger.isTraceEnabled()) {\n+\t\t\tlogger.trace(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n-\n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc699b2b3784413bb7348b8c2a92eb2ab871479f": {
      "type": "Ybodychange",
      "commitMessage": "@Bean provides autowireCandidate flag (analogous to XML definitions)\n\nIssue: SPR-16204\n",
      "commitDate": "2018-07-04, 4:41 p.m.",
      "commitName": "fc699b2b3784413bb7348b8c2a92eb2ab871479f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018-06-28, 8:15 a.m.",
      "commitNameOld": "81cb740e0ae23b6bd167f5c42ceae8294a27a14a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.35,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n\n\t\t// Consider name and any aliases\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n\t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method \u0027\" + beanMethod.getMetadata().getMethodName() +\n\t\t\t\t\t\t\"\u0027 clashes with bean name for containing configuration class; please make those names unique!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n\t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tboolean autowireCandidate \u003d bean.getBoolean(\"autowireCandidate\");\n\t\tif (!autowireCandidate) {\n\t\t\tbeanDef.setAutowireCandidate(false);\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n\t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 174,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,97 +1,102 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n \n \t\t// Consider name and any aliases\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n \t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n \t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method \u0027\" + beanMethod.getMetadata().getMethodName() +\n \t\t\t\t\t\t\"\u0027 clashes with bean name for containing configuration class; please make those names unique!\");\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n \t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n+\t\tboolean autowireCandidate \u003d bean.getBoolean(\"autowireCandidate\");\n+\t\tif (!autowireCandidate) {\n+\t\t\tbeanDef.setAutowireCandidate(false);\n+\t\t}\n+\n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "81cb740e0ae23b6bd167f5c42ceae8294a27a14a": {
      "type": "Ybodychange",
      "commitMessage": "New postProcessProperties variant on InstantiationAwareBeanPostProcessor\n\nAllows for skipping the now-deprecated postProcessPropertyValues callback with its expensive PropertyDescriptor retrieval requirement. RequiredAnnotationBeanPostProcessor (which is dependent on postProcessPropertyValues) and the @Required annotation itself are also deprecated now: in favor of constructor injection (or afterPropertiesSet).\n\nIssue: SPR-16918\n",
      "commitDate": "2018-06-28, 8:15 a.m.",
      "commitName": "81cb740e0ae23b6bd167f5c42ceae8294a27a14a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018-05-02, 9:20 a.m.",
      "commitNameOld": "c8b6233bd03d43c8a91ec197e9cf1ea15bba478c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 56.95,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n\n\t\t// Consider name and any aliases\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n\t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method \u0027\" + beanMethod.getMetadata().getMethodName() +\n\t\t\t\t\t\t\"\u0027 clashes with bean name for containing configuration class; please make those names unique!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n\t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n\t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 174,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,96 +1,97 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n \n \t\t// Consider name and any aliases\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n \t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n \t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method \u0027\" + beanMethod.getMetadata().getMethodName() +\n \t\t\t\t\t\t\"\u0027 clashes with bean name for containing configuration class; please make those names unique!\");\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n-\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n+\t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n+\t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bca5a362168e2dad27f273966857fb2f6b9fcd88": {
      "type": "Ybodychange",
      "commitMessage": "Explicit error message for bean name clash with containing configuration class\n\nIssue: SPR-15775\n",
      "commitDate": "2017-07-17, 6:54 p.m.",
      "commitName": "bca5a362168e2dad27f273966857fb2f6b9fcd88",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-06-12, 2:53 a.m.",
      "commitNameOld": "27aabb15f9c54f0d495989c917ef65a7b1235845",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 35.67,
      "commitsBetweenForRepo": 221,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n\n\t\t// Consider name and any aliases\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n\t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method \u0027\" + beanMethod.getMetadata().getMethodName() +\n\t\t\t\t\t\t\"\u0027 clashes with bean name for containing configuration class; please make those names unique!\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n\t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 173,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,91 +1,96 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n \n \t\t// Consider name and any aliases\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n+\t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n+\t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method \u0027\" + beanMethod.getMetadata().getMethodName() +\n+\t\t\t\t\t\t\"\u0027 clashes with bean name for containing configuration class; please make those names unique!\");\n+\t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017-06-07, 8:19 a.m.",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-05-31, 4:51 p.m.",
      "commitNameOld": "b494c53b40a76a3ce01a54b1bd384b6809f1a147",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n\n\t\t// Consider name and any aliases\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n\t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 173,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,91 +1,91 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n-\t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n+\t\tAssert.state(bean !\u003d null, \"No @Bean annotation attributes\");\n+\n+\t\t// Consider name and any aliases\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n-\t\tif (destroyMethodName !\u003d null) {\n-\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n-\t\t}\n+\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e892e02f41031ae18f09aef34bf82d31ddbb12c7": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2017-03-21, 12:44 p.m.",
      "commitName": "e892e02f41031ae18f09aef34bf82d31ddbb12c7",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-12-09, 9:01 a.m.",
      "commitNameOld": "a7ec6dc0afb5ad83371ed073a26a31cb9e1dd4f1",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 102.11,
      "commitsBetweenForRepo": 642,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (destroyMethodName !\u003d null) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 172,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,90 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n-\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n+\t\tString beanName \u003d (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName !\u003d null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7": {
      "type": "Ybodychange",
      "commitMessage": "Consistent alias processing behind AnnotatedTypeMetadata abstraction (also for ASM)\n\nIssue: SPR-14427\n",
      "commitDate": "2016-07-15, 7:59 a.m.",
      "commitName": "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-07-05, 11:00 a.m.",
      "commitNameOld": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 9.87,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (destroyMethodName !\u003d null) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 172,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,90 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName !\u003d null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n-\t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n+\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
      "type": "Ybodychange",
      "commitMessage": "Explicit type can be replaced by \u003c\u003e\n\nIssue: SPR-13188\n",
      "commitDate": "2016-07-05, 11:00 a.m.",
      "commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2015-07-28, 6:08 a.m.",
      "commitNameOld": "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 343.2,
      "commitsBetweenForRepo": 1426,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (destroyMethodName !\u003d null) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 172,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,90 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n-\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n+\t\tList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName !\u003d null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc": {
      "type": "Ybodychange",
      "commitMessage": "Removed unused fields from ConfigurationClassBeanDefinitionReader\n\nIssue: SPR-11740\nIssue: SPR-13280\n",
      "commitDate": "2015-07-28, 6:08 a.m.",
      "commitName": "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-07-25, 3:53 p.m.",
      "commitNameOld": "aae0bd2fb43092bd3e1bc5c3296265e760b4fc43",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 2.59,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (destroyMethodName !\u003d null) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 172,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,92 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName !\u003d null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n-\t\t// TODO [SPR-13280] Determine why type is hard coded to org.springframework.context.annotation.Scope,\n-\t\t// since AnnotationScopeMetadataResolver supports a custom scope annotation type.\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aae0bd2fb43092bd3e1bc5c3296265e760b4fc43": {
      "type": "Ybodychange",
      "commitMessage": "Update TODO for SPR-13280\n",
      "commitDate": "2015-07-25, 3:53 p.m.",
      "commitName": "aae0bd2fb43092bd3e1bc5c3296265e760b4fc43",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2015-06-13, 10:07 a.m.",
      "commitNameOld": "2d23f42609c2e6a2ee6b0507f4b800870a63ca26",
      "commitAuthorOld": "Sam Brannen",
      "daysBetweenCommits": 42.24,
      "commitsBetweenForRepo": 280,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (destroyMethodName !\u003d null) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\t// TODO [SPR-13280] Determine why type is hard coded to org.springframework.context.annotation.Scope,\n\t\t// since AnnotationScopeMetadataResolver supports a custom scope annotation type.\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 181,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,92 +1,92 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName !\u003d null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n-\t\t// TODO Determine why type is hard coded to org.springframework.context.annotation.Scope,\n+\t\t// TODO [SPR-13280] Determine why type is hard coded to org.springframework.context.annotation.Scope,\n \t\t// since AnnotationScopeMetadataResolver supports a custom scope annotation type.\n \t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes !\u003d null) {\n \t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n \t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2d23f42609c2e6a2ee6b0507f4b800870a63ca26": {
      "type": "Ybodychange",
      "commitMessage": "Introduce alias for \u0027value\u0027 attribute in @Scope\n\nIssue: SPR-11393\n",
      "commitDate": "2015-06-13, 10:07 a.m.",
      "commitName": "2d23f42609c2e6a2ee6b0507f4b800870a63ca26",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2015-05-20, 11:19 a.m.",
      "commitNameOld": "0ed9ca097bb499b46c67d34d59e08a1337758097",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 23.95,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (destroyMethodName !\u003d null) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\t// TODO Determine why type is hard coded to org.springframework.context.annotation.Scope,\n\t\t// since AnnotationScopeMetadataResolver supports a custom scope annotation type.\n\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes !\u003d null) {\n\t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 181,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,90 +1,92 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName !\u003d null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n-\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n-\t\tif (scope !\u003d null) {\n-\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n-\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n+\t\t// TODO Determine why type is hard coded to org.springframework.context.annotation.Scope,\n+\t\t// since AnnotationScopeMetadataResolver supports a custom scope annotation type.\n+\t\tAnnotationAttributes attributes \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n+\t\tif (attributes !\u003d null) {\n+\t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n+\t\t\tproxyMode \u003d attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ed9ca097bb499b46c67d34d59e08a1337758097": {
      "type": "Ybodychange",
      "commitMessage": "Customize destruction callback for AutoCloseable beans\n\nPreviously, a Bean implementing `AutoCloseable` (or `Closeable`) was\nalways destroyed regardless of its bean definition. In particular, the\ndocumented way of disabling the destruction callback via an empty String\ndid not work.\n\nAutoCloseable beans are now treated pretty much as any other bean: we\nstill use the presence of the interface to optimize the check of a\ndestroy method and we only auto-discover the method name to invoke if\nthe inferred mode is enabled.\n\nIssue: SPR-13022\n",
      "commitDate": "2015-05-20, 11:19 a.m.",
      "commitName": "0ed9ca097bb499b46c67d34d59e08a1337758097",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2015-05-20, 8:34 a.m.",
      "commitNameOld": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (destroyMethodName !\u003d null) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 180,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,90 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \t\tString methodName \u003d metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n-\t\tif (StringUtils.hasText(destroyMethodName)) {\n+\t\tif (destroyMethodName !\u003d null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bb5b5d52edf60350f09cf11c41e6fba534bebb54": {
      "type": "Ybodychange",
      "commitMessage": "Revised condition override check based on method names instead of bean names\n\nIssue: SPR-12744\n",
      "commitDate": "2015-02-25, 12:45 p.m.",
      "commitName": "bb5b5d52edf60350f09cf11c41e6fba534bebb54",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-02-10, 1:26 p.m.",
      "commitNameOld": "981aefc2c0d2a6fbf9c08d4d54d17923a75a2e01",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 14.97,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\t\tString methodName \u003d metadata.getMethodName();\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(methodName);\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 184,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,89 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n+\t\tString methodName \u003d metadata.getMethodName();\n+\n+\t\t// Do we need to mark the bean as skipped by its condition?\n+\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n+\t\t\treturn;\n+\t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n-\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n-\n-\t\t// Do we need to mark the bean as skipped by its condition?\n-\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n-\t\t\tconfigClass.skippedBeans.add(beanName);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (configClass.skippedBeans.contains(beanName)) {\n-\t\t\treturn;\n-\t\t}\n+\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n-\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n+\t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n-\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n+\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "981aefc2c0d2a6fbf9c08d4d54d17923a75a2e01": {
      "type": "Ybodychange",
      "commitMessage": "Properly honor conditions on overriding bean methods\n\nIssue: SPR-12694\n",
      "commitDate": "2015-02-10, 1:26 p.m.",
      "commitName": "981aefc2c0d2a6fbf9c08d4d54d17923a75a2e01",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-12-01, 12:54 p.m.",
      "commitNameOld": "c5c5473d44f101271e47921fb7d2a125199be517",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 71.02,
      "commitsBetweenForRepo": 192,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\n\t\t// Do we need to mark the bean as skipped by its condition?\n\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tconfigClass.skippedBeans.add(beanName);\n\t\t\treturn;\n\t\t}\n\t\tif (configClass.skippedBeans.contains(beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Register aliases even when overridden\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 184,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,81 +1,89 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n-\t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n+\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n+\n+\t\t// Consider name and any aliases\n+\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n+\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n+\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n+\n+\t\t// Do we need to mark the bean as skipped by its condition?\n+\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\tconfigClass.skippedBeans.add(beanName);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (configClass.skippedBeans.contains(beanName)) {\n \t\t\treturn;\n \t\t}\n \n-\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n-\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n+\t\t// Register aliases even when overridden\n+\t\tfor (String alias : names) {\n+\t\t\tthis.registry.registerAlias(beanName, alias);\n+\t\t}\n+\n+\t\t// Has this effectively been overridden before (e.g. via XML)?\n+\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n+\t\t\treturn;\n+\t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n+\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n-\t\t// Consider name and any aliases\n-\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n-\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n-\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n-\t\tfor (String alias : names) {\n-\t\t\tthis.registry.registerAlias(beanName, alias);\n-\t\t}\n-\n-\t\t// Has this effectively been overridden before (e.g. via XML)?\n-\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n-\t\t\treturn;\n-\t\t}\n-\n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f46c706e443860e9ada7768a16cfa01526c10645": {
      "type": "Ybodychange",
      "commitMessage": "Bean method metadata exposed through AnnotatedBeanDefinition\n\nIssue: SPR-12232\n",
      "commitDate": "2014-09-26, 8:46 a.m.",
      "commitName": "f46c706e443860e9ada7768a16cfa01526c10645",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-09-03, 6:59 a.m.",
      "commitNameOld": "6563405be5308954394b67608f09af35e7d35b59",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 23.07,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\treturn;\n\t\t}\n\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 176,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,81 +1,81 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n-\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n+\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n-\t\t\tbeanDefToRegister \u003d\n-\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n+\t\t\tbeanDefToRegister \u003d new ConfigurationClassBeanDefinition(\n+\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d80da2e3129044df2294e5c3e7fb137b9286e6a": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2013-10-25, 8:21 p.m.",
      "commitName": "6d80da2e3129044df2294e5c3e7fb137b9286e6a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013-08-28, 4:14 p.m.",
      "commitNameOld": "fe8dec912d53db4819064b50d667c34300bb59b1",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 58.17,
      "commitsBetweenForRepo": 208,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\treturn;\n\t\t}\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d\n\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 173,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,80 +1,80 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n-\t\t// Has this  effectively been overridden before (e.g. via XML)?\n+\t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fe8dec912d53db4819064b50d667c34300bb59b1": {
      "type": "Ybodychange",
      "commitMessage": "@Bean methods are allowed to override existing bean definitions with a role other than ROLE_APPLICATION now (e.g. framework-generated default beans)\n\nAlso, DefaultListableBeanFactory logs a warning when overriding an application definition with a framework-generated definition now, which is expected to be an accident.\n\nIssue: SPR-10607\n",
      "commitDate": "2013-08-28, 4:14 p.m.",
      "commitName": "fe8dec912d53db4819064b50d667c34300bb59b1",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013-08-27, 6:00 p.m.",
      "commitNameOld": "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\treturn;\n\t\t}\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// Consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// Has this  effectively been overridden before (e.g. via XML)?\n\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d\n\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 172,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,89 +1,80 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n-\t\t// consider name and any aliases\n+\t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n-\t\t// has this already been overridden (e.g. via XML)?\n-\t\tif (this.registry.containsBeanDefinition(beanName)) {\n-\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n-\t\t\t// is the existing bean definition one that was created from a configuration class?\n-\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n-\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n-\t\t\t\t// overriding is legal, return immediately\n-\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n-\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n-\t\t\t\t}\n-\t\t\t\treturn;\n-\t\t\t}\n+\t\t// Has this  effectively been overridden before (e.g. via XML)?\n+\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n+\t\t\treturn;\n \t\t}\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n-\t\t// consider scoping\n+\t\t// Consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n-\t\t// replace the original bean definition with the target one, if necessary\n+\t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n+\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n-\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n+\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65": {
      "type": "Ybodychange",
      "commitMessage": "Introduced @Description annotation for populating BeanDefinition.getDescription()\n\nIssue: SPR-10583\n",
      "commitDate": "2013-08-23, 10:49 a.m.",
      "commitName": "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013-06-12, 2:45 p.m.",
      "commitNameOld": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 71.84,
      "commitsBetweenForRepo": 263,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\treturn;\n\t\t}\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider name and any aliases\n\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d\n\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 178,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,116 +1,89 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n-\t\tif (conditionEvaluator.shouldSkip(beanMethod.getMetadata(),\n-\t\t\t\tConfigurationPhase.REGISTER_BEAN)) {\n+\t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n-\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n+\t\tConfigurationClassBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n-\t\t// consider role\n-\t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n-\t\tif (role !\u003d null) {\n-\t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n-\t\t}\n-\n \t\t// consider name and any aliases\n-\t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n+\t\tAnnotationAttributes bean \u003d AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n-\t\t\tbeanDef.setPrimary(true);\n-\t\t}\n-\n-\t\t// is this bean to be instantiated lazily?\n-\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n-\t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n-\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n-\t\t}\n-\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n-\t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n-\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n-\t\t}\n-\n-\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n-\t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n-\t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n-\t\t\tif (otherBeans.length \u003e 0) {\n-\t\t\t\tbeanDef.setDependsOn(otherBeans);\n-\t\t\t}\n-\t\t}\n+\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n-\t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n+\t\tAnnotationAttributes scope \u003d AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": {
      "type": "Ybodychange",
      "commitMessage": "Improve support for @Conditional on @Configuration\n\nIntroduce new ConfigurationCondition interface allowing more\nfine-grained control for @Conditional when used with @Configuration\nbeans.\n\nPrimarily added so that the evaluation of conditions that inspect bean\ndefinitions can be deferred until all @Configuration classes have been\nparsed.\n\nIssue: SPR-10534\n",
      "commitDate": "2013-06-12, 2:45 p.m.",
      "commitName": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-06-04, 1:27 p.m.",
      "commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 8.05,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tif (conditionEvaluator.shouldSkip(beanMethod.getMetadata(),\n\t\t\t\tConfigurationPhase.REGISTER_BEAN)) {\n\t\t\treturn;\n\t\t}\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider role\n\t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n\t\tif (role !\u003d null) {\n\t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n\t\t}\n\n\t\t// consider name and any aliases\n\t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n\t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n\t\t\tif (otherBeans.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(otherBeans);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d\n\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 180,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,116 +1,116 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n-\t\tif (ConditionEvaluator.get(beanMethod.getMetadata(), false).shouldSkip(\n-\t\t\t\tthis.registry, this.environment)) {\n+\t\tif (conditionEvaluator.shouldSkip(beanMethod.getMetadata(),\n+\t\t\t\tConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n \t\tif (role !\u003d null) {\n \t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n \t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n \t\t\tif (otherBeans.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(otherBeans);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "239ce1466ce118294f5c7b8e842a80815fd813de": {
      "type": "Ybodychange",
      "commitMessage": "Update @Conditional processing logic\n\nDefer @Conditional processing on @Configuration classes until the bean\ndefinitions are loaded, rather than when the @Configuration class is\nparsed. This provides better support for @Conditional implementations\nthat inspect bean definitions.\n\nThis commit also fixes some minor problems with original implementation\nand replaces the ConditionalAnnotationHelper class with\nConditionEvaluator.\n\nIssue: SPR-10534\n",
      "commitDate": "2013-06-04, 1:27 p.m.",
      "commitName": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-05-13, 6:04 p.m.",
      "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthorOld": "Rob Winch",
      "daysBetweenCommits": 21.81,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tif (ConditionEvaluator.get(beanMethod.getMetadata(), false).shouldSkip(\n\t\t\t\tthis.registry, this.environment)) {\n\t\t\treturn;\n\t\t}\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider role\n\t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n\t\tif (role !\u003d null) {\n\t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n\t\t}\n\n\t\t// consider name and any aliases\n\t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n\t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n\t\t\tif (otherBeans.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(otherBeans);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d\n\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 174,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,116 +1,116 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n-\t\tif (ConditionalAnnotationHelper.shouldSkip(beanMethod, this.registry,\n-\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n+\t\tif (ConditionEvaluator.get(beanMethod.getMetadata(), false).shouldSkip(\n+\t\t\t\tthis.registry, this.environment)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n \t\tif (role !\u003d null) {\n \t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n \t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n \t\t\tif (otherBeans.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(otherBeans);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b257253a2b6890ef532f27a662c441fc4fd21f3b": {
      "type": "Ybodychange",
      "commitMessage": "Support for @Conditional configuration\n\nIntroduce new @Conditional annotation that can be used to filter\nwhich @Configuration classes or methods are loaded. @Conditional\ncan be used directly or as a meta-annotation. Condition implementations\nare provided via the \u0027Condition\u0027 interface and are free to filter based\non any criteria available at the time that they run. The\nConditionalContext provides access to the BeanDefinitionRegistry,\nEnvironment and ConfigurableListableBeanFactory along with a\nResourceLoader and ClassLoader.\n\nThe existing @Profile annotation has been refactored as a @Conditional\nwith the added benefit that it can now be used as a method level\nannotation.\n",
      "commitDate": "2013-05-08, 10:41 p.m.",
      "commitName": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-04-23, 7:49 a.m.",
      "commitNameOld": "d3a406876834b91a4cf3b1e840855caeb0446d28",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 15.62,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tif (ConditionalAnnotationHelper.shouldSkip(beanMethod, this.registry,\n\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n\t\t\treturn;\n\t\t}\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider role\n\t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n\t\tif (role !\u003d null) {\n\t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n\t\t}\n\n\t\t// consider name and any aliases\n\t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n\t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n\t\t\tif (otherBeans.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(otherBeans);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d\n\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 155,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,112 +1,116 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n+\t\tif (ConditionalAnnotationHelper.shouldSkip(beanMethod, this.registry,\n+\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n+\t\t\treturn;\n+\t\t}\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n \t\tif (role !\u003d null) {\n \t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n \t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n \t\t\tif (otherBeans.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(otherBeans);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b82d293d5ed2ec6f4e02432594a73e354d17928": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassPostProcessor allows for overriding of scoped-proxy bean definitions\n\nIssue: SPR-10265\n",
      "commitDate": "2013-02-06, 3:01 p.m.",
      "commitName": "6b82d293d5ed2ec6f4e02432594a73e354d17928",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012-12-28, 2:49 p.m.",
      "commitNameOld": "1762157ad1a89ff8778387a2c72a8e36ff341a40",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 40.01,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider role\n\t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n\t\tif (role !\u003d null) {\n\t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n\t\t}\n\n\t\t// consider name and any aliases\n\t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n\t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n\t\t\tif (otherBeans.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(otherBeans);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n\t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d\n\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 157,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,111 +1,112 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tAnnotationAttributes role \u003d attributesFor(metadata, Role.class);\n \t\tif (role !\u003d null) {\n \t\t\tbeanDef.setRole(role.\u003cInteger\u003egetNumber(\"value\"));\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tAnnotationAttributes bean \u003d attributesFor(metadata, Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tAnnotationAttributes lazy \u003d attributesFor(metadata, Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tAnnotationAttributes lazy \u003d attributesFor(configClass.getMetadata(), Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tAnnotationAttributes dependsOn \u003d attributesFor(metadata, DependsOn.class);\n \t\t\tString[] otherBeans \u003d dependsOn.getStringArray(\"value\");\n \t\t\tif (otherBeans.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(otherBeans);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope \u003d attributesFor(metadata, Scope.class);\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode \u003d scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n-\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n+\t\t\tbeanDefToRegister \u003d\n+\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012-01-31, 8:37 a.m.",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012-01-31, 8:37 a.m.",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider role\n\t\tMap\u003cString, Object\u003e roleAttributes \u003d metadata.getAnnotationAttributes(Role.class.getName());\n\t\tif (roleAttributes !\u003d null) {\n\t\t\tint role \u003d (Integer) roleAttributes.get(\"value\");\n\t\t\tbeanDef.setRole(role);\n\t\t}\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 158,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
        "newPath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java"
      }
    },
    "52bef0b7b024e794186437dee78945fbb5bd209a": {
      "type": "Ybodychange",
      "commitMessage": "Allow static modifier on @Bean methods\n\nDeclaring @Bean methods as \u0027static\u0027 is now permitted, whereas previously\nit raised an exception at @Configuration class validation time.\n\nA static @Bean method can be called by the container without requiring\nthe instantiation of its declaring @Configuration class. This is\nparticularly useful when dealing with BeanFactoryPostProcessor beans,\nas they can interfere with the standard post-processing lifecycle\nnecessary to handle @Autowired, @Inject, @Value, @PostConstruct and\nother annotations.\n\nstatic @Bean methods cannot recieve CGLIB enhancement for scoping and\nAOP concerns. This is acceptable in BFPP cases as they rarely if ever\nneed it, and should not in typical cases ever be called by another\n@Bean method.  Once invoked by the container, the resulting bean will\nbe cached as usual, but multiple invocations of the static @Bean method\nwill result in creation of multiple instances of the bean.\n\nstatic @Bean methods may not, for obvious reasons, refer to normal\ninstance @Bean methods, but again this is not likely a concern for BFPP\ntypes. In the rare case that they do need a bean reference, parameter\ninjection into the static @Bean method is technically an option, but\nshould be avoided as it will potentially cause premature instantiation\nof more beans that the user may have intended.\n\nNote particularly that a WARN-level log message is now issued for any\nnon-static @Bean method with a return type assignable to BFPP.  This\nserves as a strong recommendation to users that they always mark BFPP\n@Bean methods as static.\n\nSee @Bean Javadoc for complete details.\n\nIssue: SPR-8257, SPR-8269\n",
      "commitDate": "2011-05-10, 7:55 a.m.",
      "commitName": "52bef0b7b024e794186437dee78945fbb5bd209a",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011-05-08, 9:49 a.m.",
      "commitNameOld": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 1.92,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tif (metadata.isStatic()) {\n\t\t\t// static @Bean method\n\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\telse {\n\t\t\t// instance @Bean method\n\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\t}\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider role\n\t\tMap\u003cString, Object\u003e roleAttributes \u003d metadata.getAnnotationAttributes(Role.class.getName());\n\t\tif (roleAttributes !\u003d null) {\n\t\t\tint role \u003d (Integer) roleAttributes.get(\"value\");\n\t\t\tbeanDef.setRole(role);\n\t\t}\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 158,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,101 +1,109 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n-\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n-\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n+\t\tif (metadata.isStatic()) {\n+\t\t\t// static @Bean method\n+\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n+\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n+\t\t}\n+\t\telse {\n+\t\t\t// instance @Bean method\n+\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n+\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n+\t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tMap\u003cString, Object\u003e roleAttributes \u003d metadata.getAnnotationAttributes(Role.class.getName());\n \t\tif (roleAttributes !\u003d null) {\n \t\t\tint role \u003d (Integer) roleAttributes.get(\"value\");\n \t\t\tbeanDef.setRole(role);\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cf0fc278bbc5ef4a3b08cc0a98d581ee8f930eae": {
      "type": "Ybodychange",
      "commitMessage": "Introduce @Role\n\nAs a mechanism for setting the \u0027role\u0027 hint on BeanDefinitions created\nvia component-scanning or @Bean methods.\n",
      "commitDate": "2011-05-06, 3:08 p.m.",
      "commitName": "cf0fc278bbc5ef4a3b08cc0a98d581ee8f930eae",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011-05-06, 3:04 p.m.",
      "commitNameOld": "856da7edb984cd8ad5643a376e536f40e06d8faa",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider role\n\t\tMap\u003cString, Object\u003e roleAttributes \u003d metadata.getAnnotationAttributes(Role.class.getName());\n\t\tif (roleAttributes !\u003d null) {\n\t\t\tint role \u003d (Integer) roleAttributes.get(\"value\");\n\t\t\tbeanDef.setRole(role);\n\t\t}\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 182,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,94 +1,101 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n+\t\t// consider role\n+\t\tMap\u003cString, Object\u003e roleAttributes \u003d metadata.getAnnotationAttributes(Role.class.getName());\n+\t\tif (roleAttributes !\u003d null) {\n+\t\t\tint role \u003d (Integer) roleAttributes.get(\"value\");\n+\t\t\tbeanDef.setRole(role);\n+\t\t}\n+\n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a790c143feeabf571e98f8ee0700a4586cbb67c": {
      "type": "Yparameterchange",
      "commitMessage": "Rename ConfigurationClassMethod \u003d\u003e BeanMethod\n",
      "commitDate": "2011-05-06, 3:01 p.m.",
      "commitName": "0a790c143feeabf571e98f8ee0700a4586cbb67c",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011-05-06, 3:01 p.m.",
      "commitNameOld": "f683f781c584b12790752ddfb0ee334e61a0b9e9",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 206,
      "functionName": "loadBeanDefinitionsForBeanMethod",
      "diff": "@@ -1,94 +1,94 @@\n-\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n+\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[beanMethod-ConfigurationClassMethod]",
        "newValue": "[beanMethod-BeanMethod]"
      }
    },
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
      "commitDate": "2011-02-08, 9:42 a.m.",
      "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
          "commitDate": "2011-02-08, 9:42 a.m.",
          "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2010-12-08, 2:58 a.m.",
          "commitNameOld": "e693d9fa587db6f3392fb545cffbd3e50893c4a1",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 62.28,
          "commitsBetweenForRepo": 124,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
          "functionStartLine": 201,
          "functionName": "loadBeanDefinitionsForBeanMethod",
          "diff": "@@ -1,94 +1,94 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n-\t\tConfigurationClass configClass \u003d method.getConfigurationClass();\n-\t\tMethodMetadata metadata \u003d method.getMetadata();\n+\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n+\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n+\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n-\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n+\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n-\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "loadBeanDefinitionsForModelMethod",
            "newValue": "loadBeanDefinitionsForBeanMethod"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
          "commitDate": "2011-02-08, 9:42 a.m.",
          "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2010-12-08, 2:58 a.m.",
          "commitNameOld": "e693d9fa587db6f3392fb545cffbd3e50893c4a1",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 62.28,
          "commitsBetweenForRepo": 124,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
          "functionStartLine": 201,
          "functionName": "loadBeanDefinitionsForBeanMethod",
          "diff": "@@ -1,94 +1,94 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n-\t\tConfigurationClass configClass \u003d method.getConfigurationClass();\n-\t\tMethodMetadata metadata \u003d method.getMetadata();\n+\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n+\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n+\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n-\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n+\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n-\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-ConfigurationClassMethod]",
            "newValue": "[beanMethod-ConfigurationClassMethod]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
          "commitDate": "2011-02-08, 9:42 a.m.",
          "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2010-12-08, 2:58 a.m.",
          "commitNameOld": "e693d9fa587db6f3392fb545cffbd3e50893c4a1",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 62.28,
          "commitsBetweenForRepo": 124,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
          "functionStartLine": 201,
          "functionName": "loadBeanDefinitionsForBeanMethod",
          "diff": "@@ -1,94 +1,94 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n-\t\tConfigurationClass configClass \u003d method.getConfigurationClass();\n-\t\tMethodMetadata metadata \u003d method.getMetadata();\n+\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n+\t\tConfigurationClass configClass \u003d beanMethod.getConfigurationClass();\n+\t\tMethodMetadata metadata \u003d beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n-\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n+\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n-\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6b2b5c4c233bba63fa5da2b11146ffaf66f9de80": {
      "type": "Ybodychange",
      "commitMessage": "introduced BeanDefinitionRegistryPostProcessor extension to BeanFactoryPostProcessor; @Configuration classes support definition of BeanFactoryPostProcessor beans as well (SPR-6455, SPR-6611)\n\n",
      "commitDate": "2010-01-31, 9:05 a.m.",
      "commitName": "6b2b5c4c233bba63fa5da2b11146ffaf66f9de80",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-01-29, 6:31 p.m.",
      "commitNameOld": "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 1.61,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tConfigurationClass configClass \u003d method.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overridden (e.g. via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 166,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,94 +1,94 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tConfigurationClass configClass \u003d method.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d method.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n-\t\t// has this already been overriden (i.e.: via XML)?\n+\t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9": {
      "type": "Ybodychange",
      "commitMessage": "Resolved SPR-6618. Restrictions were too tight on overloaded bean methods and were preventing it altogether.  Overloading is now allowed, as long as there is no ambiguity at runtime which bean method should be invoked.\n",
      "commitDate": "2009-12-30, 2:42 p.m.",
      "commitName": "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-11-12, 2:29 a.m.",
      "commitNameOld": "9f07b151853f21bc363340fd3056ec14118a1e89",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 48.51,
      "commitsBetweenForRepo": 306,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tConfigurationClass configClass \u003d method.getConfigurationClass();\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 121,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,94 +1,94 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n-\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n+\t\tConfigurationClass configClass \u003d method.getConfigurationClass();\n \t\tMethodMetadata metadata \u003d method.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7b019cd5c5285d81f0aea967be8af021eac8b07": {
      "type": "Ybodychange",
      "commitMessage": "@Required does not get processed on beans returned by @Bean factory methods (SPR-5744)\n",
      "commitDate": "2009-07-24, 9:29 a.m.",
      "commitName": "c7b019cd5c5285d81f0aea967be8af021eac8b07",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-07-22, 11:23 a.m.",
      "commitNameOld": "f519406c37b23eef816704baeb3a496f7430bb89",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.92,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 117,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,93 +1,94 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \t\tMethodMetadata metadata \u003d method.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n+\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f519406c37b23eef816704baeb3a496f7430bb89": {
      "type": "Ybodychange",
      "commitMessage": "@Primary/@Lazy/@DependsOn supported as meta-annotations; @Bean supported as meta-annotation on factory methods as well\n",
      "commitDate": "2009-07-22, 11:23 a.m.",
      "commitName": "f519406c37b23eef816704baeb3a496f7430bb89",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-07-21, 10:23 a.m.",
      "commitNameOld": "ec1f0e6211172f43e842aabef8d4c66d946d99f2",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.04,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tthis.registry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (this.registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 116,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,93 +1,93 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \t\tMethodMetadata metadata \u003d method.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n-\t\t\tregistry.registerAlias(beanName, alias);\n+\t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n-\t\tif (registry.containsBeanDefinition(beanName)) {\n+\t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n+\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n-\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n+\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n-\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n+\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n-\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n+\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec1f0e6211172f43e842aabef8d4c66d946d99f2": {
      "type": "Ybodychange",
      "commitMessage": "support scope meta-annotations on factory methods as well\n",
      "commitDate": "2009-07-21, 10:23 a.m.",
      "commitName": "ec1f0e6211172f43e842aabef8d4c66d946d99f2",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-05-13, 4:49 p.m.",
      "commitNameOld": "14732c5dc2700dbd15a4148bb7244938099b9c89",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 68.73,
      "commitsBetweenForRepo": 404,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\tif (scopeAttributes !\u003d null) {\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 115,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,93 +1,93 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \t\tMethodMetadata metadata \u003d method.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n-\t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n-\t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n+\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n+\t\tif (scopeAttributes !\u003d null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n-\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n+\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da71f266aed8c3dbea7c995ab4e2f3dae51cca45": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassBeanDefinition implements AnnotatedBeanDefinition\n",
      "commitDate": "2009-05-12, 7:12 p.m.",
      "commitName": "da71f266aed8c3dbea7c995ab4e2f3dae51cca45",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-05-12, 6:27 p.m.",
      "commitNameOld": "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n\t\tbeanDef.setResource(configClass.getResource());\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n\t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 114,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,92 +1,93 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n+\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \t\tMethodMetadata metadata \u003d method.getMetadata();\n \n-\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n-\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n+\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition(configClass);\n+\t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n \t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0": {
      "type": "Ybodychange",
      "commitMessage": "added SourceExtractor support\n",
      "commitDate": "2009-05-12, 6:27 p.m.",
      "commitName": "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-26, 7:41 a.m.",
      "commitNameOld": "cea8f7f69e8939d4d20073862890f0b1c1824499",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 16.45,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n\t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 112,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,91 +1,92 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tMethodMetadata metadata \u003d method.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n+\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n \t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cea8f7f69e8939d4d20073862890f0b1c1824499": {
      "type": "Ybodychange",
      "commitMessage": "custom stereotype annotations can be meta-annotated with @Service, @Controller etc as well; @Scope and @Transactional are now supported as meta-annotations on custom annotations\n",
      "commitDate": "2009-04-26, 7:41 a.m.",
      "commitName": "cea8f7f69e8939d4d20073862890f0b1c1824499",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-24, 7:16 a.m.",
      "commitNameOld": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n\t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 106,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,91 +1,91 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tMethodMetadata metadata \u003d method.getMetadata();\n \n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length \u003e 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n \t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n-\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n+\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b5d21108da24f8344be3bc708c7afdfca9a1d089": {
      "type": "Ybodychange",
      "commitMessage": "@Configuration parsing fully relies on Spring\u0027s MetadataReader abstraction now\n",
      "commitDate": "2009-04-24, 7:16 a.m.",
      "commitName": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-22, 6:46 a.m.",
      "commitNameOld": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tMethodMetadata metadata \u003d method.getMetadata();\n\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n\t\tfor (String alias : names) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created from a configuration class?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n\t\t}\n\n\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n\t\t\tif (dependsOn.length \u003e 0) {\n\t\t\t\tbeanDef.setDependsOn(dependsOn);\n\t\t\t}\n\t\t}\n\n\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n\t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 107,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,91 +1,91 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n+\t\tMethodMetadata metadata \u003d method.getMetadata();\n+\n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n-\t\tbeanDef.setUniqueFactoryMethodName(method.getName());\n+\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n-\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n-\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n-\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n-\t\tfor (String alias : bean.name()) {\n+\t\tMap\u003cString, Object\u003e beanAttributes \u003d metadata.getAnnotationAttributes(Bean.class.getName());\n+\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n+\t\tString beanName \u003d (names.size() \u003e 0 ? names.remove(0) : method.getMetadata().getMethodName());\n+\t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n-\t\t\t// is the existing bean definition one that was created by JavaConfig?\n+\t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n+\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n-\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n-\t\tif (lazy !\u003d null) {\n-\t\t\tbeanDef.setLazyInit(lazy.value());\n+\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n+\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n-\t\telse {\n-\t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n-\t\t\tif (defaultLazy !\u003d null) {\n-\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n+\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n+\t\t}\n+\n+\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n+\t\t\tString[] dependsOn \u003d (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n+\t\t\tif (dependsOn.length \u003e 0) {\n+\t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n-\t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n-\t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n-\t\t\tbeanDef.setDependsOn(dependsOn.value());\n-\t\t}\n-\n-\t\tAutowire autowire \u003d bean.autowire();\n+\t\tAutowire autowire \u003d (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n-\t\tString initMethodName \u003d bean.initMethod();\n+\t\tString initMethodName \u003d (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n-\t\tString destroyMethodName \u003d bean.destroyMethod();\n+\t\tString destroyMethodName \u003d (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n-\t\tScope scope \u003d method.getAnnotation(Scope.class);\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n-\t\tif (scope !\u003d null) {\n-\t\t\tbeanDef.setScope(scope.value());\n-\t\t\tproxyMode \u003d scope.proxyMode();\n+\t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n+\t\t\tMap\u003cString, Object\u003e scopeAttributes \u003d metadata.getAnnotationAttributes(Scope.class.getName());\n+\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n+\t\t\tproxyMode \u003d (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": {
      "type": "Ybodychange",
      "commitMessage": "next cut of JavaConfig metadata reading revision: using cached MetadataReaders\n",
      "commitDate": "2009-04-22, 6:46 a.m.",
      "commitName": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-19, 7:45 p.m.",
      "commitNameOld": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.46,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setUniqueFactoryMethodName(method.getName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name()) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n\t\tif (lazy !\u003d null) {\n\t\t\tbeanDef.setLazyInit(lazy.value());\n\t\t}\n\t\telse {\n\t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n\t\t\tif (defaultLazy !\u003d null) {\n\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n\t\t\t}\n\t\t}\n\n\t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n\t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n\t\t\tbeanDef.setDependsOn(dependsOn.value());\n\t\t}\n\n\t\tAutowire autowire \u003d bean.autowire();\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.value());\n\t\t\tproxyMode \u003d scope.proxyMode();\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
      "functionStartLine": 105,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,91 +1,91 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n-\t\tbeanDef.setFactoryMethodName(method.getName());\n+\t\tbeanDef.setUniqueFactoryMethodName(method.getName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n \t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n \t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n \t\tfor (String alias : bean.name()) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n \t\tif (lazy !\u003d null) {\n \t\t\tbeanDef.setLazyInit(lazy.value());\n \t\t}\n \t\telse {\n \t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n \t\t\tif (defaultLazy !\u003d null) {\n \t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n \t\t\t}\n \t\t}\n \n \t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n \t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n \t\t\tbeanDef.setDependsOn(dependsOn.value());\n \t\t}\n \n \t\tAutowire autowire \u003d bean.autowire();\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName \u003d bean.initMethod();\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName \u003d bean.destroyMethod();\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScope scope \u003d method.getAnnotation(Scope.class);\n \t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n \t\tif (scope !\u003d null) {\n \t\t\tbeanDef.setScope(scope.value());\n \t\t\tproxyMode \u003d scope.proxyMode();\n \t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister \u003d beanDef;\n \t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14bd47551900ced88eeacf2a5f63c187ff72028c": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
      "commitDate": "2009-04-19, 7:45 p.m.",
      "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009-04-19, 7:45 p.m.",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-04-19, 6:28 p.m.",
          "commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name()) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n\t\tif (lazy !\u003d null) {\n\t\t\tbeanDef.setLazyInit(lazy.value());\n\t\t}\n\t\telse {\n\t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n\t\t\tif (defaultLazy !\u003d null) {\n\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n\t\t\t}\n\t\t}\n\n\t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n\t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n\t\t\tbeanDef.setDependsOn(dependsOn.value());\n\t\t}\n\n\t\tAutowire autowire \u003d bean.autowire();\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.value());\n\t\t\tproxyMode \u003d scope.proxyMode();\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
          "functionStartLine": 104,
          "functionName": "loadBeanDefinitionsForModelMethod",
          "diff": "@@ -1,93 +1,91 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n-\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n-\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n-\n-\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n-\n-\t\t// consider scoping\n-\t\tScope scope \u003d method.getAnnotation(Scope.class);\n-\t\tif(scope !\u003d null)\n-\t\t\tbeanDef.setScope(scope.value());\n+\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n-\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n+\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n+\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n \t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n-\t\tfor (String alias : bean.name())\n+\t\tfor (String alias : bean.name()) {\n \t\t\tregistry.registerAlias(beanName, alias);\n+\t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n-\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n-\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n-\n+\t\tif (registry.containsBeanDefinition(beanName)) {\n+\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n-\n \t\t\t\t// overriding is legal, return immediately\n-\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n-\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n+\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (method.getAnnotation(Primary.class) !\u003d null)\n+\t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n \t\t\tbeanDef.setPrimary(true);\n-\n-\t\t// is this bean to be instantiated lazily?\n-\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n-\t\tif (defaultLazy !\u003d null)\n-\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n-\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n-\t\tif (lazy !\u003d null)\n-\t\t\tbeanDef.setLazyInit(lazy.value());\n-\n-\t\t// does this bean have a custom init-method specified?\n-\t\tString initMethodName \u003d bean.initMethod();\n-\t\tif (hasText(initMethodName))\n-\t\t\tbeanDef.setInitMethodName(initMethodName);\n-\n-\t\t// does this bean have a custom destroy-method specified?\n-\t\tString destroyMethodName \u003d bean.destroyMethod();\n-\t\tif (hasText(destroyMethodName))\n-\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n-\n-\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n-\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n-\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n-\n-\t\t\t// Create a scoped proxy definition for the original bean name,\n-\t\t\t// \"hiding\" the target bean in an internal target definition.\n-\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n-\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n-\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n-\n-\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n-\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n-\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n-\t\t\t// don\u0027t need to set it explicitly here.\n-\t\t\telse\n-\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n-\n-\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n-\t\t\ttargetDef.setAutowireCandidate(false);\n-\n-\t\t\t// Register the target bean as separate bean in the factory\n-\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n-\n-\t\t\t// replace the original bean definition with the target one\n-\t\t\tbeanDef \u003d scopedProxyDefinition;\n \t\t}\n \n-\t\tif (bean.dependsOn().length \u003e 0)\n-\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n+\t\t// is this bean to be instantiated lazily?\n+\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n+\t\tif (lazy !\u003d null) {\n+\t\t\tbeanDef.setLazyInit(lazy.value());\n+\t\t}\n+\t\telse {\n+\t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n+\t\t\tif (defaultLazy !\u003d null) {\n+\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\t\t}\n+\t\t}\n \n-\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n-\t\t\tconfigClass.getName(), beanName));\n+\t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n+\t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n+\t\t\tbeanDef.setDependsOn(dependsOn.value());\n+\t\t}\n \n-\t\tregistry.registerBeanDefinition(beanName, beanDef);\n+\t\tAutowire autowire \u003d bean.autowire();\n+\t\tif (autowire.isAutowire()) {\n+\t\t\tbeanDef.setAutowireMode(autowire.value());\n+\t\t}\n \n+\t\tString initMethodName \u003d bean.initMethod();\n+\t\tif (StringUtils.hasText(initMethodName)) {\n+\t\t\tbeanDef.setInitMethodName(initMethodName);\n+\t\t}\n+\n+\t\tString destroyMethodName \u003d bean.destroyMethod();\n+\t\tif (StringUtils.hasText(destroyMethodName)) {\n+\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n+\t\t}\n+\n+\t\t// consider scoping\n+\t\tScope scope \u003d method.getAnnotation(Scope.class);\n+\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n+\t\tif (scope !\u003d null) {\n+\t\t\tbeanDef.setScope(scope.value());\n+\t\t\tproxyMode \u003d scope.proxyMode();\n+\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n+\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// replace the original bean definition with the target one, if necessary\n+\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n+\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n+\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n+\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n+\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n+\t\t}\n+\n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n+\t\t}\n+\n+\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationModelBeanDefinitionReader.java",
            "newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
            "oldMethodName": "loadBeanDefinitionsForModelMethod",
            "newMethodName": "loadBeanDefinitionsForModelMethod"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009-04-19, 7:45 p.m.",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-04-19, 6:28 p.m.",
          "commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name()) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n\t\tif (lazy !\u003d null) {\n\t\t\tbeanDef.setLazyInit(lazy.value());\n\t\t}\n\t\telse {\n\t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n\t\t\tif (defaultLazy !\u003d null) {\n\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n\t\t\t}\n\t\t}\n\n\t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n\t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n\t\t\tbeanDef.setDependsOn(dependsOn.value());\n\t\t}\n\n\t\tAutowire autowire \u003d bean.autowire();\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.value());\n\t\t\tproxyMode \u003d scope.proxyMode();\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
          "functionStartLine": 104,
          "functionName": "loadBeanDefinitionsForModelMethod",
          "diff": "@@ -1,93 +1,91 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n-\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n-\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n-\n-\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n-\n-\t\t// consider scoping\n-\t\tScope scope \u003d method.getAnnotation(Scope.class);\n-\t\tif(scope !\u003d null)\n-\t\t\tbeanDef.setScope(scope.value());\n+\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n-\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n+\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n+\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n \t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n-\t\tfor (String alias : bean.name())\n+\t\tfor (String alias : bean.name()) {\n \t\t\tregistry.registerAlias(beanName, alias);\n+\t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n-\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n-\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n-\n+\t\tif (registry.containsBeanDefinition(beanName)) {\n+\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n-\n \t\t\t\t// overriding is legal, return immediately\n-\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n-\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n+\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (method.getAnnotation(Primary.class) !\u003d null)\n+\t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n \t\t\tbeanDef.setPrimary(true);\n-\n-\t\t// is this bean to be instantiated lazily?\n-\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n-\t\tif (defaultLazy !\u003d null)\n-\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n-\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n-\t\tif (lazy !\u003d null)\n-\t\t\tbeanDef.setLazyInit(lazy.value());\n-\n-\t\t// does this bean have a custom init-method specified?\n-\t\tString initMethodName \u003d bean.initMethod();\n-\t\tif (hasText(initMethodName))\n-\t\t\tbeanDef.setInitMethodName(initMethodName);\n-\n-\t\t// does this bean have a custom destroy-method specified?\n-\t\tString destroyMethodName \u003d bean.destroyMethod();\n-\t\tif (hasText(destroyMethodName))\n-\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n-\n-\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n-\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n-\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n-\n-\t\t\t// Create a scoped proxy definition for the original bean name,\n-\t\t\t// \"hiding\" the target bean in an internal target definition.\n-\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n-\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n-\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n-\n-\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n-\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n-\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n-\t\t\t// don\u0027t need to set it explicitly here.\n-\t\t\telse\n-\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n-\n-\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n-\t\t\ttargetDef.setAutowireCandidate(false);\n-\n-\t\t\t// Register the target bean as separate bean in the factory\n-\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n-\n-\t\t\t// replace the original bean definition with the target one\n-\t\t\tbeanDef \u003d scopedProxyDefinition;\n \t\t}\n \n-\t\tif (bean.dependsOn().length \u003e 0)\n-\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n+\t\t// is this bean to be instantiated lazily?\n+\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n+\t\tif (lazy !\u003d null) {\n+\t\t\tbeanDef.setLazyInit(lazy.value());\n+\t\t}\n+\t\telse {\n+\t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n+\t\t\tif (defaultLazy !\u003d null) {\n+\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\t\t}\n+\t\t}\n \n-\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n-\t\t\tconfigClass.getName(), beanName));\n+\t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n+\t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n+\t\t\tbeanDef.setDependsOn(dependsOn.value());\n+\t\t}\n \n-\t\tregistry.registerBeanDefinition(beanName, beanDef);\n+\t\tAutowire autowire \u003d bean.autowire();\n+\t\tif (autowire.isAutowire()) {\n+\t\t\tbeanDef.setAutowireMode(autowire.value());\n+\t\t}\n \n+\t\tString initMethodName \u003d bean.initMethod();\n+\t\tif (StringUtils.hasText(initMethodName)) {\n+\t\t\tbeanDef.setInitMethodName(initMethodName);\n+\t\t}\n+\n+\t\tString destroyMethodName \u003d bean.destroyMethod();\n+\t\tif (StringUtils.hasText(destroyMethodName)) {\n+\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n+\t\t}\n+\n+\t\t// consider scoping\n+\t\tScope scope \u003d method.getAnnotation(Scope.class);\n+\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n+\t\tif (scope !\u003d null) {\n+\t\t\tbeanDef.setScope(scope.value());\n+\t\t\tproxyMode \u003d scope.proxyMode();\n+\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n+\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// replace the original bean definition with the target one, if necessary\n+\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n+\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n+\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n+\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n+\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n+\t\t}\n+\n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n+\t\t}\n+\n+\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009-04-19, 7:45 p.m.",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-04-19, 6:28 p.m.",
          "commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\n\t\t// consider name and any aliases\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name()) {\n\t\t\tregistry.registerAlias(beanName, alias);\n\t\t}\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (registry.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n\t\t\tbeanDef.setPrimary(true);\n\t\t}\n\n\t\t// is this bean to be instantiated lazily?\n\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n\t\tif (lazy !\u003d null) {\n\t\t\tbeanDef.setLazyInit(lazy.value());\n\t\t}\n\t\telse {\n\t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n\t\t\tif (defaultLazy !\u003d null) {\n\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n\t\t\t}\n\t\t}\n\n\t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n\t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n\t\t\tbeanDef.setDependsOn(dependsOn.value());\n\t\t}\n\n\t\tAutowire autowire \u003d bean.autowire();\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (StringUtils.hasText(destroyMethodName)) {\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t}\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n\t\tif (scope !\u003d null) {\n\t\t\tbeanDef.setScope(scope.value());\n\t\t\tproxyMode \u003d scope.proxyMode();\n\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\n\t\t// replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n\t\t}\n\n\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
          "functionStartLine": 104,
          "functionName": "loadBeanDefinitionsForModelMethod",
          "diff": "@@ -1,93 +1,91 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n-\n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n-\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n-\n-\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n-\n-\t\t// consider scoping\n-\t\tScope scope \u003d method.getAnnotation(Scope.class);\n-\t\tif(scope !\u003d null)\n-\t\t\tbeanDef.setScope(scope.value());\n+\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n-\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n+\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n+\t\tList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n \t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n-\t\tfor (String alias : bean.name())\n+\t\tfor (String alias : bean.name()) {\n \t\t\tregistry.registerAlias(beanName, alias);\n+\t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n-\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n-\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n-\n+\t\tif (registry.containsBeanDefinition(beanName)) {\n+\t\t\tBeanDefinition existingBeanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n-\n \t\t\t\t// overriding is legal, return immediately\n-\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n-\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n+\t\t\t\t\t\t\t\"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (method.getAnnotation(Primary.class) !\u003d null)\n+\t\tif (method.getAnnotation(Primary.class) !\u003d null) {\n \t\t\tbeanDef.setPrimary(true);\n-\n-\t\t// is this bean to be instantiated lazily?\n-\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n-\t\tif (defaultLazy !\u003d null)\n-\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n-\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n-\t\tif (lazy !\u003d null)\n-\t\t\tbeanDef.setLazyInit(lazy.value());\n-\n-\t\t// does this bean have a custom init-method specified?\n-\t\tString initMethodName \u003d bean.initMethod();\n-\t\tif (hasText(initMethodName))\n-\t\t\tbeanDef.setInitMethodName(initMethodName);\n-\n-\t\t// does this bean have a custom destroy-method specified?\n-\t\tString destroyMethodName \u003d bean.destroyMethod();\n-\t\tif (hasText(destroyMethodName))\n-\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n-\n-\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n-\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n-\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n-\n-\t\t\t// Create a scoped proxy definition for the original bean name,\n-\t\t\t// \"hiding\" the target bean in an internal target definition.\n-\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n-\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n-\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n-\n-\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n-\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n-\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n-\t\t\t// don\u0027t need to set it explicitly here.\n-\t\t\telse\n-\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n-\n-\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n-\t\t\ttargetDef.setAutowireCandidate(false);\n-\n-\t\t\t// Register the target bean as separate bean in the factory\n-\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n-\n-\t\t\t// replace the original bean definition with the target one\n-\t\t\tbeanDef \u003d scopedProxyDefinition;\n \t\t}\n \n-\t\tif (bean.dependsOn().length \u003e 0)\n-\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n+\t\t// is this bean to be instantiated lazily?\n+\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n+\t\tif (lazy !\u003d null) {\n+\t\t\tbeanDef.setLazyInit(lazy.value());\n+\t\t}\n+\t\telse {\n+\t\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n+\t\t\tif (defaultLazy !\u003d null) {\n+\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\t\t}\n+\t\t}\n \n-\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n-\t\t\tconfigClass.getName(), beanName));\n+\t\tDependsOn dependsOn \u003d method.getAnnotation(DependsOn.class);\n+\t\tif (dependsOn !\u003d null \u0026\u0026 dependsOn.value().length \u003e 0) {\n+\t\t\tbeanDef.setDependsOn(dependsOn.value());\n+\t\t}\n \n-\t\tregistry.registerBeanDefinition(beanName, beanDef);\n+\t\tAutowire autowire \u003d bean.autowire();\n+\t\tif (autowire.isAutowire()) {\n+\t\t\tbeanDef.setAutowireMode(autowire.value());\n+\t\t}\n \n+\t\tString initMethodName \u003d bean.initMethod();\n+\t\tif (StringUtils.hasText(initMethodName)) {\n+\t\t\tbeanDef.setInitMethodName(initMethodName);\n+\t\t}\n+\n+\t\tString destroyMethodName \u003d bean.destroyMethod();\n+\t\tif (StringUtils.hasText(destroyMethodName)) {\n+\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n+\t\t}\n+\n+\t\t// consider scoping\n+\t\tScope scope \u003d method.getAnnotation(Scope.class);\n+\t\tScopedProxyMode proxyMode \u003d ScopedProxyMode.NO;\n+\t\tif (scope !\u003d null) {\n+\t\t\tbeanDef.setScope(scope.value());\n+\t\t\tproxyMode \u003d scope.proxyMode();\n+\t\t\tif (proxyMode \u003d\u003d ScopedProxyMode.DEFAULT) {\n+\t\t\t\tproxyMode \u003d ScopedProxyMode.NO;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// replace the original bean definition with the target one, if necessary\n+\t\tBeanDefinition beanDefToRegister \u003d beanDef;\n+\t\tif (proxyMode !\u003d ScopedProxyMode.NO) {\n+\t\t\tBeanDefinitionHolder proxyDef \u003d ScopedProxyUtils.createScopedProxy(\n+\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode \u003d\u003d ScopedProxyMode.TARGET_CLASS);\n+\t\t\tbeanDefToRegister \u003d proxyDef.getBeanDefinition();\n+\t\t}\n+\n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n+\t\t}\n+\n+\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-BeanMethod]",
            "newValue": "[method-ConfigurationClassMethod]"
          }
        }
      ]
    },
    "69a762e86ac075035bfcdc899aadf2b36abaf167": {
      "type": "Ybodychange",
      "commitMessage": "resolved:\n+ Provide @Primary annotation (SPR-5590)\n+ Provide @Lazy annotation (SPR-5591)\n+ Test @Bean initMethod/destroyMethod functionality (SPR-5592)\n+ Test @Bean dependsOn functionality (SPR-5593)\n\n",
      "commitDate": "2009-03-28, 6:21 p.m.",
      "commitName": "69a762e86ac075035bfcdc899aadf2b36abaf167",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-27, 12:57 a.m.",
      "commitNameOld": "1697932c57af5389fe07971e91866980e966403f",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tif(scope !\u003d null)\n\t\t\tbeanDef.setScope(scope.value());\n\n\t\t// consider name and any aliases\n\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name())\n\t\t\tregistry.registerAlias(beanName, alias);\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (method.getAnnotation(Primary.class) !\u003d null)\n\t\t\tbeanDef.setPrimary(true);\n\n\t\t// is this bean to be instantiated lazily?\n\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n\t\tif (defaultLazy !\u003d null)\n\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n\t\tif (lazy !\u003d null)\n\t\t\tbeanDef.setLazyInit(lazy.value());\n\n\t\t// does this bean have a custom init-method specified?\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (hasText(initMethodName))\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\n\t\t// does this bean have a custom destroy-method specified?\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (hasText(destroyMethodName))\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n\n\t\t\t// Create a scoped proxy definition for the original bean name,\n\t\t\t// \"hiding\" the target bean in an internal target definition.\n\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n\n\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n\t\t\t// don\u0027t need to set it explicitly here.\n\t\t\telse\n\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n\n\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\t\ttargetDef.setAutowireCandidate(false);\n\n\t\t\t// Register the target bean as separate bean in the factory\n\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n\n\t\t\t// replace the original bean definition with the target one\n\t\t\tbeanDef \u003d scopedProxyDefinition;\n\t\t}\n\n\t\tif (bean.dependsOn().length \u003e 0)\n\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n\n\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\tconfigClass.getName(), beanName));\n\n\t\tregistry.registerBeanDefinition(beanName, beanDef);\n\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 122,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,92 +1,93 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n \n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n \n \t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n \n \t\t// consider scoping\n \t\tScope scope \u003d method.getAnnotation(Scope.class);\n \t\tif(scope !\u003d null)\n \t\t\tbeanDef.setScope(scope.value());\n \n \t\t// consider name and any aliases\n \t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n \t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n \t\tfor (String alias : bean.name())\n \t\t\tregistry.registerAlias(beanName, alias);\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n \t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n \n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n \t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\t// TODO: re-enable for Lazy support\n-\t\t// // is this bean marked as primary for disambiguation?\n-\t\t// if (bean.primary() \u003d\u003d Primary.TRUE)\n-\t\t// beanDef.setPrimary(true);\n-\t\t//\n-\t\t// // is this bean lazily instantiated?\n-\t\t// if ((bean.lazy() \u003d\u003d Lazy.TRUE)\n-\t\t// || ((bean.lazy() \u003d\u003d Lazy.UNSPECIFIED) \u0026\u0026 (defaults.defaultLazy() \u003d\u003d Lazy.TRUE)))\n-\t\t// beanDef.setLazyInit(true);\n+\t\tif (method.getAnnotation(Primary.class) !\u003d null)\n+\t\t\tbeanDef.setPrimary(true);\n+\n+\t\t// is this bean to be instantiated lazily?\n+\t\tLazy defaultLazy \u003d configClass.getAnnotation(Lazy.class);\n+\t\tif (defaultLazy !\u003d null)\n+\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\tLazy lazy \u003d method.getAnnotation(Lazy.class);\n+\t\tif (lazy !\u003d null)\n+\t\t\tbeanDef.setLazyInit(lazy.value());\n \n \t\t// does this bean have a custom init-method specified?\n \t\tString initMethodName \u003d bean.initMethod();\n \t\tif (hasText(initMethodName))\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \n \t\t// does this bean have a custom destroy-method specified?\n \t\tString destroyMethodName \u003d bean.destroyMethod();\n \t\tif (hasText(destroyMethodName))\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n \t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n \t\t\tRootBeanDefinition targetDef \u003d beanDef;\n \n \t\t\t// Create a scoped proxy definition for the original bean name,\n \t\t\t// \"hiding\" the target bean in an internal target definition.\n \t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n \t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n \t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n \n \t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n \t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n \t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n \t\t\t// don\u0027t need to set it explicitly here.\n \t\t\telse\n \t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n \n \t\t\t// The target bean should be ignored in favor of the scoped proxy.\n \t\t\ttargetDef.setAutowireCandidate(false);\n \n \t\t\t// Register the target bean as separate bean in the factory\n \t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n \n \t\t\t// replace the original bean definition with the target one\n \t\t\tbeanDef \u003d scopedProxyDefinition;\n \t\t}\n \n \t\tif (bean.dependsOn().length \u003e 0)\n \t\t\tbeanDef.setDependsOn(bean.dependsOn());\n \n \t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\tconfigClass.getName(), beanName));\n \n \t\tregistry.registerBeanDefinition(beanName, beanDef);\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1697932c57af5389fe07971e91866980e966403f": {
      "type": "Yfilerename",
      "commitMessage": "consolidated context.annotation.support -\u003e context.annotation\n\n",
      "commitDate": "2009-03-27, 12:57 a.m.",
      "commitName": "1697932c57af5389fe07971e91866980e966403f",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-26, 11:10 p.m.",
      "commitNameOld": "2c0c523d7099ed1ad77864242f25d30e218b2a95",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tif(scope !\u003d null)\n\t\t\tbeanDef.setScope(scope.value());\n\n\t\t// consider name and any aliases\n\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name())\n\t\t\tregistry.registerAlias(beanName, alias);\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// TODO: re-enable for Lazy support\n\t\t// // is this bean marked as primary for disambiguation?\n\t\t// if (bean.primary() \u003d\u003d Primary.TRUE)\n\t\t// beanDef.setPrimary(true);\n\t\t//\n\t\t// // is this bean lazily instantiated?\n\t\t// if ((bean.lazy() \u003d\u003d Lazy.TRUE)\n\t\t// || ((bean.lazy() \u003d\u003d Lazy.UNSPECIFIED) \u0026\u0026 (defaults.defaultLazy() \u003d\u003d Lazy.TRUE)))\n\t\t// beanDef.setLazyInit(true);\n\n\t\t// does this bean have a custom init-method specified?\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (hasText(initMethodName))\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\n\t\t// does this bean have a custom destroy-method specified?\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (hasText(destroyMethodName))\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n\n\t\t\t// Create a scoped proxy definition for the original bean name,\n\t\t\t// \"hiding\" the target bean in an internal target definition.\n\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n\n\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n\t\t\t// don\u0027t need to set it explicitly here.\n\t\t\telse\n\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n\n\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\t\ttargetDef.setAutowireCandidate(false);\n\n\t\t\t// Register the target bean as separate bean in the factory\n\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n\n\t\t\t// replace the original bean definition with the target one\n\t\t\tbeanDef \u003d scopedProxyDefinition;\n\t\t}\n\n\t\tif (bean.dependsOn().length \u003e 0)\n\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n\n\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\tconfigClass.getName(), beanName));\n\n\t\tregistry.registerBeanDefinition(beanName, beanDef);\n\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 122,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java",
        "newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationModelBeanDefinitionReader.java"
      }
    },
    "7f96f57375d3b33d08bf3be6d5206066f3142cfe": {
      "type": "Ybodychange",
      "commitMessage": "polishing\n",
      "commitDate": "2009-03-23, 2:23 a.m.",
      "commitName": "7f96f57375d3b33d08bf3be6d5206066f3142cfe",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-23, 12:48 a.m.",
      "commitNameOld": "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tif(scope !\u003d null)\n\t\t\tbeanDef.setScope(scope.value());\n\n\t\t// consider name and any aliases\n\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name())\n\t\t\tregistry.registerAlias(beanName, alias);\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// TODO: re-enable for Lazy support\n\t\t// // is this bean marked as primary for disambiguation?\n\t\t// if (bean.primary() \u003d\u003d Primary.TRUE)\n\t\t// beanDef.setPrimary(true);\n\t\t//\n\t\t// // is this bean lazily instantiated?\n\t\t// if ((bean.lazy() \u003d\u003d Lazy.TRUE)\n\t\t// || ((bean.lazy() \u003d\u003d Lazy.UNSPECIFIED) \u0026\u0026 (defaults.defaultLazy() \u003d\u003d Lazy.TRUE)))\n\t\t// beanDef.setLazyInit(true);\n\n\t\t// does this bean have a custom init-method specified?\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (hasText(initMethodName))\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\n\t\t// does this bean have a custom destroy-method specified?\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (hasText(destroyMethodName))\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n\n\t\t\t// Create a scoped proxy definition for the original bean name,\n\t\t\t// \"hiding\" the target bean in an internal target definition.\n\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n\n\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n\t\t\t// don\u0027t need to set it explicitly here.\n\t\t\telse\n\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n\n\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\t\ttargetDef.setAutowireCandidate(false);\n\n\t\t\t// Register the target bean as separate bean in the factory\n\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n\n\t\t\t// replace the original bean definition with the target one\n\t\t\tbeanDef \u003d scopedProxyDefinition;\n\t\t}\n\n\t\tif (bean.dependsOn().length \u003e 0)\n\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n\n\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\tconfigClass.getName(), beanName));\n\n\t\tregistry.registerBeanDefinition(beanName, beanDef);\n\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 126,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,95 +1,92 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n \t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n \n \t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n \n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n \n \t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n \n-\t\t// TODO: prune defaults\n-\t\t//Configuration defaults \u003d configClass.getMetadata();\n-\n \t\t// consider scoping\n \t\tScope scope \u003d method.getAnnotation(Scope.class);\n \t\tif(scope !\u003d null)\n \t\t\tbeanDef.setScope(scope.value());\n \n \t\t// consider name and any aliases\n \t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n \t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n \t\tfor (String alias : bean.name())\n \t\t\tregistry.registerAlias(beanName, alias);\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n \t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n \n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n \n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n \t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\t// TODO: re-enable for Lazy support\n \t\t// // is this bean marked as primary for disambiguation?\n \t\t// if (bean.primary() \u003d\u003d Primary.TRUE)\n \t\t// beanDef.setPrimary(true);\n \t\t//\n \t\t// // is this bean lazily instantiated?\n \t\t// if ((bean.lazy() \u003d\u003d Lazy.TRUE)\n \t\t// || ((bean.lazy() \u003d\u003d Lazy.UNSPECIFIED) \u0026\u0026 (defaults.defaultLazy() \u003d\u003d Lazy.TRUE)))\n \t\t// beanDef.setLazyInit(true);\n \n \t\t// does this bean have a custom init-method specified?\n \t\tString initMethodName \u003d bean.initMethod();\n \t\tif (hasText(initMethodName))\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \n \t\t// does this bean have a custom destroy-method specified?\n \t\tString destroyMethodName \u003d bean.destroyMethod();\n \t\tif (hasText(destroyMethodName))\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n \t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n \t\t\tRootBeanDefinition targetDef \u003d beanDef;\n \n \t\t\t// Create a scoped proxy definition for the original bean name,\n \t\t\t// \"hiding\" the target bean in an internal target definition.\n \t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n \t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n \t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n \n \t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n \t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n \t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n \t\t\t// don\u0027t need to set it explicitly here.\n \t\t\telse\n \t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n \n \t\t\t// The target bean should be ignored in favor of the scoped proxy.\n \t\t\ttargetDef.setAutowireCandidate(false);\n \n \t\t\t// Register the target bean as separate bean in the factory\n \t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n \n \t\t\t// replace the original bean definition with the target one\n \t\t\tbeanDef \u003d scopedProxyDefinition;\n \t\t}\n \n \t\tif (bean.dependsOn().length \u003e 0)\n \t\t\tbeanDef.setDependsOn(bean.dependsOn());\n \n \t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\tconfigClass.getName(), beanName));\n \n \t\tregistry.registerBeanDefinition(beanName, beanDef);\n \n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7": {
      "type": "Yfilerename",
      "commitMessage": "+ Moving .config.java module -\u003e .context\n\n",
      "commitDate": "2009-03-23, 12:48 a.m.",
      "commitName": "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-23, 12:25 a.m.",
      "commitNameOld": "63b5c48461f69cc611f4378d52f46197998334db",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\n\t\t// TODO: prune defaults\n\t\t//Configuration defaults \u003d configClass.getMetadata();\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tif(scope !\u003d null)\n\t\t\tbeanDef.setScope(scope.value());\n\n\t\t// consider name and any aliases\n\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name())\n\t\t\tregistry.registerAlias(beanName, alias);\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// TODO: re-enable for Lazy support\n\t\t// // is this bean marked as primary for disambiguation?\n\t\t// if (bean.primary() \u003d\u003d Primary.TRUE)\n\t\t// beanDef.setPrimary(true);\n\t\t//\n\t\t// // is this bean lazily instantiated?\n\t\t// if ((bean.lazy() \u003d\u003d Lazy.TRUE)\n\t\t// || ((bean.lazy() \u003d\u003d Lazy.UNSPECIFIED) \u0026\u0026 (defaults.defaultLazy() \u003d\u003d Lazy.TRUE)))\n\t\t// beanDef.setLazyInit(true);\n\n\t\t// does this bean have a custom init-method specified?\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (hasText(initMethodName))\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\n\t\t// does this bean have a custom destroy-method specified?\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (hasText(destroyMethodName))\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n\n\t\t\t// Create a scoped proxy definition for the original bean name,\n\t\t\t// \"hiding\" the target bean in an internal target definition.\n\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n\n\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n\t\t\t// don\u0027t need to set it explicitly here.\n\t\t\telse\n\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n\n\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\t\ttargetDef.setAutowireCandidate(false);\n\n\t\t\t// Register the target bean as separate bean in the factory\n\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n\n\t\t\t// replace the original bean definition with the target one\n\t\t\tbeanDef \u003d scopedProxyDefinition;\n\t\t}\n\n\t\tif (bean.dependsOn().length \u003e 0)\n\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n\n\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\tconfigClass.getName(), beanName));\n\n\t\tregistry.registerBeanDefinition(beanName, beanDef);\n\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 124,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java",
        "newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java"
      }
    },
    "ef02c61e581dcd1f3cf110608da72ed133777d62": {
      "type": "Yfilerename",
      "commitMessage": "+ Repackaged src and test from .config.java.* -\u003e .context.annotation.*\n\n",
      "commitDate": "2009-03-23, 12:23 a.m.",
      "commitName": "ef02c61e581dcd1f3cf110608da72ed133777d62",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-23, 12:14 a.m.",
      "commitNameOld": "3f196517f99b7a7148e68531d1fa1b475ff81939",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\n\t\t// TODO: prune defaults\n\t\t//Configuration defaults \u003d configClass.getMetadata();\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tif(scope !\u003d null)\n\t\t\tbeanDef.setScope(scope.value());\n\n\t\t// consider name and any aliases\n\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name())\n\t\t\tregistry.registerAlias(beanName, alias);\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// TODO: re-enable for Lazy support\n\t\t// // is this bean marked as primary for disambiguation?\n\t\t// if (bean.primary() \u003d\u003d Primary.TRUE)\n\t\t// beanDef.setPrimary(true);\n\t\t//\n\t\t// // is this bean lazily instantiated?\n\t\t// if ((bean.lazy() \u003d\u003d Lazy.TRUE)\n\t\t// || ((bean.lazy() \u003d\u003d Lazy.UNSPECIFIED) \u0026\u0026 (defaults.defaultLazy() \u003d\u003d Lazy.TRUE)))\n\t\t// beanDef.setLazyInit(true);\n\n\t\t// does this bean have a custom init-method specified?\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (hasText(initMethodName))\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\n\t\t// does this bean have a custom destroy-method specified?\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (hasText(destroyMethodName))\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n\n\t\t\t// Create a scoped proxy definition for the original bean name,\n\t\t\t// \"hiding\" the target bean in an internal target definition.\n\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n\n\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n\t\t\t// don\u0027t need to set it explicitly here.\n\t\t\telse\n\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n\n\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\t\ttargetDef.setAutowireCandidate(false);\n\n\t\t\t// Register the target bean as separate bean in the factory\n\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n\n\t\t\t// replace the original bean definition with the target one\n\t\t\tbeanDef \u003d scopedProxyDefinition;\n\t\t}\n\n\t\tif (bean.dependsOn().length \u003e 0)\n\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n\n\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\tconfigClass.getName(), beanName));\n\n\t\tregistry.registerBeanDefinition(beanName, beanDef);\n\n\t}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 124,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java",
        "newPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java"
      }
    },
    "8a5c2a6a56e7b88b44af7111edb2bfc8b1781f48": {
      "type": "Ybodychange",
      "commitMessage": "+ Added tests for custom @Bean naming and aliasing\n+ Eliminated BeanDefinitionRegistrar and BeanRegistrar types\n+ Simplified ConfigurationEnhancer logic\n+ Updated JavaDoc for ConfigurationModel and related classes\n+ Updated JavaDoc for all ASM visitors\n\n",
      "commitDate": "2009-03-22, 6:39 p.m.",
      "commitName": "8a5c2a6a56e7b88b44af7111edb2bfc8b1781f48",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-21, 9:43 p.m.",
      "commitNameOld": "72fae2ea1930c5c0d004220895bf890abcfecde4",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n\n\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n\n\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n\t\tbeanDef.setFactoryMethodName(method.getName());\n\n\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n\n\t\t// TODO: prune defaults\n\t\t//Configuration defaults \u003d configClass.getMetadata();\n\n\t\t// consider scoping\n\t\tScope scope \u003d method.getAnnotation(Scope.class);\n\t\tif(scope !\u003d null)\n\t\t\tbeanDef.setScope(scope.value());\n\n\t\t// consider name and any aliases\n\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n\t\tfor (String alias : bean.name())\n\t\t\tregistry.registerAlias(beanName, alias);\n\n\t\t// has this already been overriden (i.e.: via XML)?\n\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n\n\t\t\t// is the existing bean definition one that was created by JavaConfig?\n\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n\n\t\t\t\t// overriding is legal, return immediately\n\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// TODO: re-enable for Lazy support\n\t\t// // is this bean marked as primary for disambiguation?\n\t\t// if (bean.primary() \u003d\u003d Primary.TRUE)\n\t\t// beanDef.setPrimary(true);\n\t\t//\n\t\t// // is this bean lazily instantiated?\n\t\t// if ((bean.lazy() \u003d\u003d Lazy.TRUE)\n\t\t// || ((bean.lazy() \u003d\u003d Lazy.UNSPECIFIED) \u0026\u0026 (defaults.defaultLazy() \u003d\u003d Lazy.TRUE)))\n\t\t// beanDef.setLazyInit(true);\n\n\t\t// does this bean have a custom init-method specified?\n\t\tString initMethodName \u003d bean.initMethod();\n\t\tif (hasText(initMethodName))\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\n\t\t// does this bean have a custom destroy-method specified?\n\t\tString destroyMethodName \u003d bean.destroyMethod();\n\t\tif (hasText(destroyMethodName))\n\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\n\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n\n\t\t\t// Create a scoped proxy definition for the original bean name,\n\t\t\t// \"hiding\" the target bean in an internal target definition.\n\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n\n\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n\t\t\t// don\u0027t need to set it explicitly here.\n\t\t\telse\n\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n\n\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n\t\t\ttargetDef.setAutowireCandidate(false);\n\n\t\t\t// Register the target bean as separate bean in the factory\n\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n\n\t\t\t// replace the original bean definition with the target one\n\t\t\tbeanDef \u003d scopedProxyDefinition;\n\t\t}\n\n\t\tif (bean.dependsOn().length \u003e 0)\n\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n\n\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\tconfigClass.getName(), beanName));\n\n\t\tregistry.registerBeanDefinition(beanName, beanDef);\n\n\t}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 124,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,3 +1,95 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n-\t\tnew BeanRegistrar().register(method, registry);\n+\t\tRootBeanDefinition beanDef \u003d new ConfigurationClassBeanDefinition();\n+\n+\t\tConfigurationClass configClass \u003d method.getDeclaringClass();\n+\n+\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n+\t\tbeanDef.setFactoryMethodName(method.getName());\n+\n+\t\tBean bean \u003d method.getRequiredAnnotation(Bean.class);\n+\n+\t\t// TODO: prune defaults\n+\t\t//Configuration defaults \u003d configClass.getMetadata();\n+\n+\t\t// consider scoping\n+\t\tScope scope \u003d method.getAnnotation(Scope.class);\n+\t\tif(scope !\u003d null)\n+\t\t\tbeanDef.setScope(scope.value());\n+\n+\t\t// consider name and any aliases\n+\t\tArrayList\u003cString\u003e names \u003d new ArrayList\u003cString\u003e(Arrays.asList(bean.name()));\n+\t\tString beanName \u003d (names.size() \u003e 0) ? names.remove(0) : method.getName();\n+\t\tfor (String alias : bean.name())\n+\t\t\tregistry.registerAlias(beanName, alias);\n+\n+\t\t// has this already been overriden (i.e.: via XML)?\n+\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n+\t\t\tBeanDefinition existingBeanDef \u003d getBeanDefinitionIncludingAncestry(beanName, registry);\n+\n+\t\t\t// is the existing bean definition one that was created by JavaConfig?\n+\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n+\t\t\t\t// no -\u003e then it\u0027s an external override, probably XML\n+\n+\t\t\t\t// overriding is legal, return immediately\n+\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n+\t\t\t\t\t+ \"\u0027%s\u0027 already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// TODO: re-enable for Lazy support\n+\t\t// // is this bean marked as primary for disambiguation?\n+\t\t// if (bean.primary() \u003d\u003d Primary.TRUE)\n+\t\t// beanDef.setPrimary(true);\n+\t\t//\n+\t\t// // is this bean lazily instantiated?\n+\t\t// if ((bean.lazy() \u003d\u003d Lazy.TRUE)\n+\t\t// || ((bean.lazy() \u003d\u003d Lazy.UNSPECIFIED) \u0026\u0026 (defaults.defaultLazy() \u003d\u003d Lazy.TRUE)))\n+\t\t// beanDef.setLazyInit(true);\n+\n+\t\t// does this bean have a custom init-method specified?\n+\t\tString initMethodName \u003d bean.initMethod();\n+\t\tif (hasText(initMethodName))\n+\t\t\tbeanDef.setInitMethodName(initMethodName);\n+\n+\t\t// does this bean have a custom destroy-method specified?\n+\t\tString destroyMethodName \u003d bean.destroyMethod();\n+\t\tif (hasText(destroyMethodName))\n+\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n+\n+\t\t// is this method annotated with @Scope(scopedProxy\u003d...)?\n+\t\tif (scope !\u003d null \u0026\u0026 scope.proxyMode() !\u003d ScopedProxyMode.NO) {\n+\t\t\tRootBeanDefinition targetDef \u003d beanDef;\n+\n+\t\t\t// Create a scoped proxy definition for the original bean name,\n+\t\t\t// \"hiding\" the target bean in an internal target definition.\n+\t\t\tString targetBeanName \u003d resolveHiddenScopedProxyBeanName(beanName);\n+\t\t\tRootBeanDefinition scopedProxyDefinition \u003d new RootBeanDefinition(ScopedProxyFactoryBean.class);\n+\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n+\n+\t\t\tif (scope.proxyMode() \u003d\u003d ScopedProxyMode.TARGET_CLASS)\n+\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n+\t\t\t// ScopedFactoryBean\u0027s \"proxyTargetClass\" default is TRUE, so we\n+\t\t\t// don\u0027t need to set it explicitly here.\n+\t\t\telse\n+\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n+\n+\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n+\t\t\ttargetDef.setAutowireCandidate(false);\n+\n+\t\t\t// Register the target bean as separate bean in the factory\n+\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n+\n+\t\t\t// replace the original bean definition with the target one\n+\t\t\tbeanDef \u003d scopedProxyDefinition;\n+\t\t}\n+\n+\t\tif (bean.dependsOn().length \u003e 0)\n+\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n+\n+\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n+\t\t\tconfigClass.getName(), beanName));\n+\n+\t\tregistry.registerBeanDefinition(beanName, beanDef);\n+\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc191bec2dfceb7ee052ac238c84eb564d27e1ee": {
      "type": "Ybodychange",
      "commitMessage": "Whitespace and license polish\n\n",
      "commitDate": "2009-03-07, 4:41 p.m.",
      "commitName": "dc191bec2dfceb7ee052ac238c84eb564d27e1ee",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-07, 1:14 a.m.",
      "commitNameOld": "5de6e2c3953ab594fd04c4f2e59a102633a0a64f",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.64,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tnew BeanRegistrar().register(method, registry);\n\t}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 119,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,4 +1,3 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n \t\tnew BeanRegistrar().register(method, registry);\n-\t\t//method.getRegistrar().register(method, registry);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4": {
      "type": "Ybodychange",
      "commitMessage": "+ Fleshed out, documented, tested and polished the ConfigurationPostProcessor implementation\n+ Removed @FactoryMethod indirection and extension point in favor of direct processing of @Bean annotations\n\n",
      "commitDate": "2009-03-05, 10:12 p.m.",
      "commitName": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-05, 3:08 p.m.",
      "commitNameOld": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tnew BeanRegistrar().register(method, registry);\n\t\t//method.getRegistrar().register(method, registry);\n\t}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 142,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "@@ -1,3 +1,4 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n-\t\tmethod.getRegistrar().register(method, registry);\n+\t\tnew BeanRegistrar().register(method, registry);\n+\t\t//method.getRegistrar().register(method, registry);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
      "commitDate": "2009-03-05, 3:08 p.m.",
      "commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
          "commitDate": "2009-03-05, 3:08 p.m.",
          "commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009-02-28, 1:57 a.m.",
          "commitNameOld": "e3153f705ffd70157deffb2935e3db5b2a2a38a1",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.55,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tmethod.getRegistrar().register(method, registry);\n\t}",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java",
          "functionStartLine": 143,
          "functionName": "loadBeanDefinitionsForModelMethod",
          "diff": "@@ -1,3 +1,3 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ModelMethod method) {\n-\t\tmethod.getRegistrar().register(method, beanFactory);\n+\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\t\tmethod.getRegistrar().register(method, registry);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-ModelMethod]",
            "newValue": "[method-BeanMethod]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
          "commitDate": "2009-03-05, 3:08 p.m.",
          "commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009-02-28, 1:57 a.m.",
          "commitNameOld": "e3153f705ffd70157deffb2935e3db5b2a2a38a1",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.55,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n\t\tmethod.getRegistrar().register(method, registry);\n\t}",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java",
          "functionStartLine": 143,
          "functionName": "loadBeanDefinitionsForModelMethod",
          "diff": "@@ -1,3 +1,3 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ModelMethod method) {\n-\t\tmethod.getRegistrar().register(method, beanFactory);\n+\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\t\tmethod.getRegistrar().register(method, registry);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "c593f063970df90d7de7b85c6da5733aadcafde6": {
      "type": "Yfilerename",
      "commitMessage": "Consolidating types and reducing visibility wherever possible. Non-internal public API is now at 18 types (21 including internal packages).\n",
      "commitDate": "2009-02-27, 10:43 p.m.",
      "commitName": "c593f063970df90d7de7b85c6da5733aadcafde6",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-02-27, 10:08 p.m.",
      "commitNameOld": "6deb1acab435d18f024e07a564ac77147729e0ec",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void loadBeanDefinitionsForModelMethod(ModelMethod method) {\n        method.getRegistrar().register(method, beanFactory);\n    }",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 149,
      "functionName": "loadBeanDefinitionsForModelMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/internal/factory/support/ConfigurationModelBeanDefinitionReader.java",
        "newPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java"
      }
    },
    "e48fe0d89271113bcac4e7c41e86cb1d8230594e": {
      "type": "Yintroduced",
      "commitMessage": "Initial cut at migrating JavaConfig essentials into Core. test.basic.BasicTests successfully excercises the simplest possible @Configuration class (contains a single @Bean method). 39 classes were pulled in from from JavaConfig to support this use case.\n\n",
      "commitDate": "2009-02-26, 8:35 p.m.",
      "commitName": "e48fe0d89271113bcac4e7c41e86cb1d8230594e",
      "commitAuthor": "Chris Beams",
      "diff": "@@ -0,0 +1,3 @@\n+    private void loadBeanDefinitionsForModelMethod(ModelMethod method) {\n+        method.getRegistrar().register(method, beanFactory);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadBeanDefinitionsForModelMethod(ModelMethod method) {\n        method.getRegistrar().register(method, beanFactory);\n    }",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/internal/factory/support/ConfigurationModelBeanDefinitionReader.java",
      "functionStartLine": 150,
      "functionName": "loadBeanDefinitionsForModelMethod"
    }
  }
}