{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "MethodResolutionLogic.java",
  "functionName": "isApplicable",
  "functionId": "isApplicable___method-ResolvedMethodDeclaration__name-String__argumentsTypes-List__ResolvedType____typeSolver-TypeSolver__withWildcardTolerance-boolean",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
  "functionStartLine": 71,
  "functionEndLine": 143,
  "numCommitsSeen": 166,
  "timeTaken": 1562,
  "changeHistory": [
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
    "c990d23490f5c4ac4322119b03d5951b63eef055",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
    "69e724f5a168e148ea4479c872cfbf656fce8acc",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
    "b20f28d6034a54108c056947c631c360fa079138",
    "c48864ccaea00039c2f6a8390d21cffd3fbde054",
    "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
    "84afc7be2fabd511eccc69e29fca9c4238c9469e",
    "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
    "8907128c87954825abed135e781f272f67648f95",
    "ead147279ca0b84d2f479a714943b20cd689e7c7",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "9506a1844d5076b4edcc2b9a5bc375acf7e95c35",
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
    "3337bf584f7ef47f4f56b81743ca0d83930763bf",
    "0b419e87200878fe13db395a415efc4d1338cef2",
    "adb02497ed443e836ae552e20bcb11ab8c1ab623",
    "b36f33050149a62a5b3c8c7451ae93f736715029",
    "eec165d9e3ef0ab1d93f69a231964984a3379762",
    "558fc9b4f808d718b9b266071078752ba68d4203",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
    "a7fa0c3db19bd74be9affdd624447251963b68af",
    "80f951258992f75441239c79e0f31eda7d47e107",
    "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd"
  ],
  "changeHistoryShort": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650": "Ymultichange(Yparameterchange,Ybodychange)",
    "c990d23490f5c4ac4322119b03d5951b63eef055": "Ybodychange",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": "Ymultichange(Yparameterchange,Ybodychange)",
    "69e724f5a168e148ea4479c872cfbf656fce8acc": "Ybodychange",
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": "Ybodychange",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "6e654694b8d141fd5503b46f9e77b8763cfa9a81": "Ybodychange",
    "b20f28d6034a54108c056947c631c360fa079138": "Ybodychange",
    "c48864ccaea00039c2f6a8390d21cffd3fbde054": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd": "Ybodychange",
    "84afc7be2fabd511eccc69e29fca9c4238c9469e": "Ybodychange",
    "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601": "Ybodychange",
    "8907128c87954825abed135e781f272f67648f95": "Yfilerename",
    "ead147279ca0b84d2f479a714943b20cd689e7c7": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "9506a1844d5076b4edcc2b9a5bc375acf7e95c35": "Yfilerename",
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": "Ybodychange",
    "3337bf584f7ef47f4f56b81743ca0d83930763bf": "Ybodychange",
    "0b419e87200878fe13db395a415efc4d1338cef2": "Ybodychange",
    "adb02497ed443e836ae552e20bcb11ab8c1ab623": "Ybodychange",
    "b36f33050149a62a5b3c8c7451ae93f736715029": "Yfilerename",
    "eec165d9e3ef0ab1d93f69a231964984a3379762": "Ybodychange",
    "558fc9b4f808d718b9b266071078752ba68d4203": "Ybodychange",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": "Ybodychange",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": "Ybodychange",
    "a7fa0c3db19bd74be9affdd624447251963b68af": "Ybodychange",
    "80f951258992f75441239c79e0f31eda7d47e107": "Ymultichange(Yparameterchange,Ybodychange)",
    "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd": "Yintroduced"
  },
  "changeHistoryDetails": {
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018-01-10, 7:52 a.m.",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018-01-10, 3:01 a.m.",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNumberOfParams() - 1;\n            if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                // check if the last value is directly assignable as an array\n                ResolvedType expectedType \u003d method.getLastParam().getType();\n                ResolvedType actualType \u003d argumentsTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                if (pos \u003e argumentsTypes.size()) {\n                  return false;\n                }\n                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n            return false;\n        }\n        Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n            ResolvedType expectedType \u003d method.getParam(i).getType();\n            ResolvedType actualType \u003d argumentsTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                        if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 72,
      "functionName": "isApplicable",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java"
      }
    },
    "e15d5a8aa84a34917e4ef47135dfc62e58ea7650": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "correcting module core to use new classes\n",
      "commitDate": "2017-09-29, 2:07 a.m.",
      "commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "correcting module core to use new classes\n",
          "commitDate": "2017-09-29, 2:07 a.m.",
          "commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-09-28, 4:36 p.m.",
          "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.4,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNumberOfParams() - 1;\n            if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                // check if the last value is directly assignable as an array\n                ResolvedType expectedType \u003d method.getLastParam().getType();\n                ResolvedType actualType \u003d argumentsTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                if (pos \u003e argumentsTypes.size()) {\n                  return false;\n                }\n                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n            return false;\n        }\n        Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n            ResolvedType expectedType \u003d method.getParam(i).getType();\n            ResolvedType actualType \u003d argumentsTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                        if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 72,
          "functionName": "isApplicable",
          "diff": "@@ -1,73 +1,73 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNumberOfParams() - 1;\n             if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n-                Type expectedType \u003d method.getLastParam().getType();\n-                Type actualType \u003d argumentsTypes.get(pos);\n+                ResolvedType expectedType \u003d method.getLastParam().getType();\n+                ResolvedType actualType \u003d argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n-                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n+                    for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 if (pos \u003e argumentsTypes.size()) {\n                   return false;\n                 }\n                 argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n             return false;\n         }\n-        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+        Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n-            Type expectedType \u003d method.getParam(i).getType();\n-            Type actualType \u003d argumentsTypes.get(i);\n+            ResolvedType expectedType \u003d method.getParam(i).getType();\n+            ResolvedType actualType \u003d argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n-                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n+                    (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n-                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n+                List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n-                for (TypeParameterDeclaration tp : typeParameters) {\n+                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n-                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n+                        if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
            "newValue": "[method-ResolvedMethodDeclaration, name-String, argumentsTypes-List\u003cResolvedType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "correcting module core to use new classes\n",
          "commitDate": "2017-09-29, 2:07 a.m.",
          "commitName": "e15d5a8aa84a34917e4ef47135dfc62e58ea7650",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-09-28, 4:36 p.m.",
          "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.4,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNumberOfParams() - 1;\n            if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                // check if the last value is directly assignable as an array\n                ResolvedType expectedType \u003d method.getLastParam().getType();\n                ResolvedType actualType \u003d argumentsTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                if (pos \u003e argumentsTypes.size()) {\n                  return false;\n                }\n                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n            return false;\n        }\n        Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n            ResolvedType expectedType \u003d method.getParam(i).getType();\n            ResolvedType actualType \u003d argumentsTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                        if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 72,
          "functionName": "isApplicable",
          "diff": "@@ -1,73 +1,73 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(ResolvedMethodDeclaration method, String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNumberOfParams() - 1;\n             if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n-                Type expectedType \u003d method.getLastParam().getType();\n-                Type actualType \u003d argumentsTypes.get(pos);\n+                ResolvedType expectedType \u003d method.getLastParam().getType();\n+                ResolvedType actualType \u003d argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n-                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n+                    for (ResolvedTypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 if (pos \u003e argumentsTypes.size()) {\n                   return false;\n                 }\n                 argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n             return false;\n         }\n-        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+        Map\u003cString, ResolvedType\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n-            Type expectedType \u003d method.getParam(i).getType();\n-            Type actualType \u003d argumentsTypes.get(i);\n+            ResolvedType expectedType \u003d method.getParam(i).getType();\n+            ResolvedType actualType \u003d argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n-                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n+                    (method.getParam(i).isVariadic() \u0026\u0026 new ResolvedArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n-                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n+                List\u003cResolvedTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n-                for (TypeParameterDeclaration tp : typeParameters) {\n+                for (ResolvedTypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n-                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n+                        if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "c990d23490f5c4ac4322119b03d5951b63eef055": {
      "type": "Ybodychange",
      "commitMessage": "loads of changes to support our code",
      "commitDate": "2016-12-13, 8:10 a.m.",
      "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthor": "Fred Lefévère-Laoide",
      "commitDateOld": "2016-11-06, 3:42 a.m.",
      "commitNameOld": "a7803cf050435e3162f7fdde83fb9692a891e92e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 37.19,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNumberOfParams() - 1;\n            if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d argumentsTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                if (pos \u003e argumentsTypes.size()) {\n                  return false;\n                }\n                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d argumentsTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 85,
      "functionName": "isApplicable",
      "diff": "@@ -1,70 +1,73 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNumberOfParams() - 1;\n             if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType \u003d method.getLastParam().getType();\n                 Type actualType \u003d argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n+                if (pos \u003e argumentsTypes.size()) {\n+                  return false;\n+                }\n                 argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n             return false;\n         }\n         Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n             Type expectedType \u003d method.getParam(i).getType();\n             Type actualType \u003d argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
      "type": "Ybodychange",
      "commitMessage": "adding more comments in model declarations\n",
      "commitDate": "2016-10-21, 2:55 a.m.",
      "commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 4:06 p.m.",
      "commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNumberOfParams() - 1;\n            if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d argumentsTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d argumentsTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 67,
      "functionName": "isApplicable",
      "diff": "@@ -1,70 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n-            int pos \u003d method.getNoParams() - 1;\n-            if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n+            int pos \u003d method.getNumberOfParams() - 1;\n+            if (method.getNumberOfParams() \u003d\u003d argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType \u003d method.getLastParam().getType();\n                 Type actualType \u003d argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n-        if (method.getNoParams() !\u003d argumentsTypes.size()) {\n+        if (method.getNumberOfParams() !\u003d argumentsTypes.size()) {\n             return false;\n         }\n         Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n-        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n+        for (int i \u003d 0; i \u003c method.getNumberOfParams(); i++) {\n             Type expectedType \u003d method.getParam(i).getType();\n             Type actualType \u003d argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n-                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() - 1) {\n+                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNumberOfParams() - 1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016-10-20, 2:39 a.m.",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 2:32 a.m.",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d argumentsTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d argumentsTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d argumentsTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 67,
      "functionName": "isApplicable",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/MethodResolutionLogic.java"
      }
    },
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
      "commitDate": "2016-10-17, 1:25 p.m.",
      "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016-10-17, 1:25 p.m.",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-16, 12:13 p.m.",
          "commitNameOld": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d argumentsTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d argumentsTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d argumentsTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 51,
          "functionName": "isApplicable",
          "diff": "@@ -1,70 +1,70 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n-            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n+            if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType \u003d method.getLastParam().getType();\n-                Type actualType \u003d paramTypes.get(pos);\n+                Type actualType \u003d argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n-                            paramTypes.set(pos, actualType.asArrayType().getComponentType());\n+                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n-                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n-                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n-        if (method.getNoParams() !\u003d paramTypes.size()) {\n+        if (method.getNoParams() !\u003d argumentsTypes.size()) {\n             return false;\n         }\n         Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             Type expectedType \u003d method.getParam(i).getType();\n-            Type actualType \u003d paramTypes.get(i);\n+            Type actualType \u003d argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
            "newValue": "[method-MethodDeclaration, name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016-10-17, 1:25 p.m.",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-16, 12:13 p.m.",
          "commitNameOld": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d argumentsTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d argumentsTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d argumentsTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 51,
          "functionName": "isApplicable",
          "diff": "@@ -1,70 +1,70 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n-            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n+            if (method.getNoParams() \u003d\u003d argumentsTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType \u003d method.getLastParam().getType();\n-                Type actualType \u003d paramTypes.get(pos);\n+                Type actualType \u003d argumentsTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n-                            paramTypes.set(pos, actualType.asArrayType().getComponentType());\n+                            argumentsTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n-                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                            argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n-                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                argumentsTypes \u003d groupVariadicParamValues(argumentsTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n-        if (method.getNoParams() !\u003d paramTypes.size()) {\n+        if (method.getNoParams() !\u003d argumentsTypes.size()) {\n             return false;\n         }\n         Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             Type expectedType \u003d method.getParam(i).getType();\n-            Type actualType \u003d paramTypes.get(i);\n+            Type actualType \u003d argumentsTypes.get(i);\n             if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "69e724f5a168e148ea4479c872cfbf656fce8acc": {
      "type": "Ybodychange",
      "commitMessage": "improvement on verifying method compatibility\n",
      "commitDate": "2016-10-15, 8:29 a.m.",
      "commitName": "69e724f5a168e148ea4479c872cfbf656fce8acc",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 4:57 p.m.",
      "commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d paramTypes.get(i);\n            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "diff": "@@ -1,70 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType \u003d method.getLastParam().getType();\n                 Type actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             Type expectedType \u003d method.getParam(i).getType();\n             Type actualType \u003d paramTypes.get(i);\n-            if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n+            if ((expectedType.isTypeVariable() \u0026\u0026 !(expectedType.isWildcard())) \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceType(),\n                         actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
      "type": "Ybodychange",
      "commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
      "commitDate": "2016-10-14, 4:57 p.m.",
      "commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 1:24 p.m.",
      "commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n                            paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                        } else {\n                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d paramTypes.get(i);\n            if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceType(),\n                        actualType.asReferenceType(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "diff": "@@ -1,70 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType \u003d method.getLastParam().getType();\n                 Type actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n-                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n-                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n+                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {\n+                            paramTypes.set(pos, actualType.asArrayType().getComponentType());\n                         } else {\n                             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             Type expectedType \u003d method.getParam(i).getType();\n             Type actualType \u003d paramTypes.get(i);\n             if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n-                        expectedType.asReferenceTypeUsage(),\n-                        actualType.asReferenceTypeUsage(),\n+                        expectedType.asReferenceType(),\n+                        actualType.asReferenceType(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
      "type": "Ybodychange",
      "commitMessage": "reorganize packages in model\n",
      "commitDate": "2016-10-14, 12:51 p.m.",
      "commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 2:36 a.m.",
      "commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                        } else {\n                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d paramTypes.get(i);\n            if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameterDeclaration tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "diff": "@@ -1,70 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 Type expectedType \u003d method.getLastParam().getType();\n                 Type actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n-                    for (TypeParameter tp : method.getTypeParameters()) {\n+                    for (TypeParameterDeclaration tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                         } else {\n                             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             Type expectedType \u003d method.getParam(i).getType();\n             Type actualType \u003d paramTypes.get(i);\n             if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n-                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n+                List\u003cTypeParameterDeclaration\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n-                for (TypeParameter tp : typeParameters) {\n+                for (TypeParameterDeclaration tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                         if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016-10-13, 4:11 p.m.",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 3:29 p.m.",
          "commitNameOld": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                        } else {\n                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d paramTypes.get(i);\n            if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "diff": "@@ -1,70 +1,70 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n-                TypeUsage expectedType \u003d method.getLastParam().getType();\n-                TypeUsage actualType \u003d paramTypes.get(pos);\n+                Type expectedType \u003d method.getLastParam().getType();\n+                Type actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                         } else {\n                             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n-        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-            TypeUsage expectedType \u003d method.getParam(i).getType();\n-            TypeUsage actualType \u003d paramTypes.get(i);\n+            Type expectedType \u003d method.getParam(i).getType();\n+            Type actualType \u003d paramTypes.get(i);\n             if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n-                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n+                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n-                        if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]",
            "newValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cType\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 3:29 p.m.",
          "commitNameOld": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                Type expectedType \u003d method.getLastParam().getType();\n                Type actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                        } else {\n                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            Type expectedType \u003d method.getParam(i).getType();\n            Type actualType \u003d paramTypes.get(i);\n            if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "diff": "@@ -1,70 +1,70 @@\n-    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cType\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n-                TypeUsage expectedType \u003d method.getLastParam().getType();\n-                TypeUsage actualType \u003d paramTypes.get(pos);\n+                Type expectedType \u003d method.getLastParam().getType();\n+                Type actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                         } else {\n                             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n-        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+        Map\u003cString, Type\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n-            TypeUsage expectedType \u003d method.getParam(i).getType();\n-            TypeUsage actualType \u003d paramTypes.get(i);\n+            Type expectedType \u003d method.getParam(i).getType();\n+            Type actualType \u003d paramTypes.get(i);\n             if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                 matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                 continue;\n             }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n-                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n+                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayType(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n-                        if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                        if (new ArrayType(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6e654694b8d141fd5503b46f9e77b8763cfa9a81": {
      "type": "Ybodychange",
      "commitMessage": "issue80: resolve conflicts between variadic and not variadic alternatives\n",
      "commitDate": "2016-10-13, 3:29 p.m.",
      "commitName": "6e654694b8d141fd5503b46f9e77b8763cfa9a81",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-13, 12:07 p.m.",
      "commitNameOld": "b20f28d6034a54108c056947c631c360fa079138",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                        } else {\n                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n                continue;\n            }\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "diff": "@@ -1,66 +1,70 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType \u003d method.getLastParam().getType();\n                 TypeUsage actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                             paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                         } else {\n                             paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                         }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n+            if (expectedType.isTypeVariable() \u0026\u0026 expectedType.asTypeParameter().declaredOnMethod()) {\n+                matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);\n+                continue;\n+            }\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n                     if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                         if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                             continue;\n                         }\n                     }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b20f28d6034a54108c056947c631c360fa079138": {
      "type": "Ybodychange",
      "commitMessage": "issue80: other fix for variadic arguments\n",
      "commitDate": "2016-10-13, 12:07 p.m.",
      "commitName": "b20f28d6034a54108c056947c631c360fa079138",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-13, 11:26 a.m.",
      "commitNameOld": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n                        } else {\n                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                        }\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n                        if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 42,
      "functionName": "isApplicable",
      "diff": "@@ -1,57 +1,66 @@\n     private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType \u003d method.getLastParam().getType();\n                 TypeUsage actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n-                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                        if (actualType.isArray() \u0026\u0026 expectedType.isAssignableBy(actualType.asArrayTypeUsage().getComponentType())) {\n+                            paramTypes.set(pos, actualType.asArrayTypeUsage().getComponentType());\n+                        } else {\n+                            paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                        }\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                         needForWildCardTolerance \u003d true;\n                         continue;\n                     }\n+                    if (method.hasVariadicParameter() \u0026\u0026 i \u003d\u003d method.getNoParams() -1) {\n+                        if (new ArrayTypeUsage(expectedType).isAssignableBy(actualType)) {\n+                            continue;\n+                        }\n+                    }\n                     return false;\n                 }\n             }\n         }\n         return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c48864ccaea00039c2f6a8390d21cffd3fbde054": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
      "commitDate": "2016-10-13, 11:26 a.m.",
      "commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
          "commitDate": "2016-10-13, 11:26 a.m.",
          "commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 6:43 a.m.",
          "commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "diff": "@@ -1,52 +1,57 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType \u003d method.getLastParam().getType();\n                 TypeUsage actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+        boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n+                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n+                        needForWildCardTolerance \u003d true;\n+                        continue;\n+                    }\n                     return false;\n                 }\n             }\n         }\n-        return true;\n+        return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]",
            "newValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver, withWildcardTolerance-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
          "commitDate": "2016-10-13, 11:26 a.m.",
          "commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 6:43 a.m.",
          "commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "diff": "@@ -1,52 +1,57 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType \u003d method.getLastParam().getType();\n                 TypeUsage actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+        boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n+                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n+                        needForWildCardTolerance \u003d true;\n+                        continue;\n+                    }\n                     return false;\n                 }\n             }\n         }\n-        return true;\n+        return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[private, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue80: usage of an extremely dirty trick for matching method calls involving wildcards\n",
          "commitDate": "2016-10-13, 11:26 a.m.",
          "commitName": "c48864ccaea00039c2f6a8390d21cffd3fbde054",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-13, 6:43 a.m.",
          "commitNameOld": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        boolean needForWildCardTolerance \u003d false;\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n                        needForWildCardTolerance \u003d true;\n                        continue;\n                    }\n                    return false;\n                }\n            }\n        }\n        return !withWildcardTolerance || needForWildCardTolerance;\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
          "functionStartLine": 42,
          "functionName": "isApplicable",
          "diff": "@@ -1,52 +1,57 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n+    private static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver, boolean withWildcardTolerance) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType \u003d method.getLastParam().getType();\n                 TypeUsage actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n+        boolean needForWildCardTolerance \u003d false;\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                     (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n+                    if (actualType.isWildcard() \u0026\u0026 withWildcardTolerance \u0026\u0026 !expectedType.isPrimitive()) {\n+                        needForWildCardTolerance \u003d true;\n+                        continue;\n+                    }\n                     return false;\n                 }\n             }\n         }\n-        return true;\n+        return !withWildcardTolerance || needForWildCardTolerance;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improving support for variadic arguments\n",
      "commitDate": "2016-10-13, 6:43 a.m.",
      "commitName": "e3e4b88ee821fdcec76aa3c940cb4b4f466bc2cd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-11, 4:53 p.m.",
      "commitNameOld": "37576d078d11264fec1a28bbffea400003160b6b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 38,
      "functionName": "isApplicable",
      "diff": "@@ -1,51 +1,52 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType \u003d method.getLastParam().getType();\n                 TypeUsage actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n-            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n+            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType) ||\n+                    (method.getParam(i).isVariadic() \u0026\u0026 new ArrayTypeUsage(expectedType).isAssignableBy(actualType));\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84afc7be2fabd511eccc69e29fca9c4238c9469e": {
      "type": "Ybodychange",
      "commitMessage": "unused code removed\n",
      "commitDate": "2016-10-05, 9:04 a.m.",
      "commitName": "84afc7be2fabd511eccc69e29fca9c4238c9469e",
      "commitAuthor": "rpau",
      "commitDateOld": "2016-10-03, 9:24 a.m.",
      "commitNameOld": "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 1.99,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 38,
      "functionName": "isApplicable",
      "diff": "@@ -1,52 +1,51 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n-        List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType \u003d method.getLastParam().getType();\n                 TypeUsage actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                 typeParameters.addAll(method.declaringType().getTypeParameters());\n                 for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601": {
      "type": "Ybodychange",
      "commitMessage": "Regard type parameter of method\u0027s declaring type when testing if method is applicable. Solves issue #67.\n",
      "commitDate": "2016-10-03, 9:24 a.m.",
      "commitName": "e2cc24a4f5a54a058c1d9ba971b7c8aa0a445601",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016-09-28, 7:58 a.m.",
      "commitNameOld": "325c0dcdee2e0fcfe28f64abec9e39fc9d9adba5",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n                typeParameters.addAll(method.declaringType().getTypeParameters());\n                for (TypeParameter tp : typeParameters) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 38,
      "functionName": "isApplicable",
      "diff": "@@ -1,50 +1,52 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         if (method.hasVariadicParameter()) {\n             int pos \u003d method.getNoParams() - 1;\n             if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                 // check if the last value is directly assignable as an array\n                 TypeUsage expectedType \u003d method.getLastParam().getType();\n                 TypeUsage actualType \u003d paramTypes.get(pos);\n                 if (!expectedType.isAssignableBy(actualType)) {\n                     for (TypeParameter tp : method.getTypeParameters()) {\n                         expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                     }\n                     if (!expectedType.isAssignableBy(actualType)) {\n                         paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                     }\n                 } // else it is already assignable, nothing to do\n             } else {\n                 paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n             }\n         }\n \n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n-                for (TypeParameter tp : method.getTypeParameters()) {\n+                List\u003cTypeParameter\u003e typeParameters \u003d method.getTypeParameters();\n+                typeParameters.addAll(method.declaringType().getTypeParameters());\n+                for (TypeParameter tp : typeParameters) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8907128c87954825abed135e781f272f67648f95": {
      "type": "Yfilerename",
      "commitMessage": "modules: create logic module\n",
      "commitDate": "2015-11-20, 5:00 p.m.",
      "commitName": "8907128c87954825abed135e781f272f67648f95",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-20, 12:31 p.m.",
      "commitNameOld": "01dd50e954e60eb6c50ddbff8937e4186c8bb587",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 37,
      "functionName": "isApplicable",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java"
      }
    },
    "ead147279ca0b84d2f479a714943b20cd689e7c7": {
      "type": "Ybodychange",
      "commitMessage": "issue7: consider type parameters and varargs combinations\n",
      "commitDate": "2015-11-20, 11:04 a.m.",
      "commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-14, 6:41 a.m.",
      "commitNameOld": "454904fe0cb3b15aa506e3f5fa8f0c9fb1313f61",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        if (method.hasVariadicParameter()) {\n            int pos \u003d method.getNoParams() - 1;\n            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n                // check if the last value is directly assignable as an array\n                TypeUsage expectedType \u003d method.getLastParam().getType();\n                TypeUsage actualType \u003d paramTypes.get(pos);\n                if (!expectedType.isAssignableBy(actualType)) {\n                    for (TypeParameter tp : method.getTypeParameters()) {\n                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                    }\n                    if (!expectedType.isAssignableBy(actualType)) {\n                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n                    }\n                } // else it is already assignable, nothing to do\n            } else {\n                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n            }\n        }\n\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
      "functionStartLine": 38,
      "functionName": "isApplicable",
      "diff": "@@ -1,31 +1,50 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n+        List\u003cTypeUsage\u003e originalParamTypes \u003d paramTypes;\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n-        // TODO Consider varargs\n+        if (method.hasVariadicParameter()) {\n+            int pos \u003d method.getNoParams() - 1;\n+            if (method.getNoParams() \u003d\u003d paramTypes.size()) {\n+                // check if the last value is directly assignable as an array\n+                TypeUsage expectedType \u003d method.getLastParam().getType();\n+                TypeUsage actualType \u003d paramTypes.get(pos);\n+                if (!expectedType.isAssignableBy(actualType)) {\n+                    for (TypeParameter tp : method.getTypeParameters()) {\n+                        expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n+                    }\n+                    if (!expectedType.isAssignableBy(actualType)) {\n+                        paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+                    }\n+                } // else it is already assignable, nothing to do\n+            } else {\n+                paramTypes \u003d groupVariadicParamValues(paramTypes, pos, method.getLastParam().getType());\n+            }\n+        }\n+\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015-11-13, 4:12 a.m.",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 3:53 a.m.",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c method.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
      "functionStartLine": 21,
      "functionName": "isApplicable",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java"
      }
    },
    "9506a1844d5076b4edcc2b9a5bc375acf7e95c35": {
      "type": "Yfilerename",
      "commitMessage": "creating AbstractClassDeclaration\n",
      "commitDate": "2015-11-02, 2:55 p.m.",
      "commitName": "9506a1844d5076b4edcc2b9a5bc375acf7e95c35",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-02, 2:48 p.m.",
      "commitNameOld": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java",
      "functionStartLine": 21,
      "functionName": "isApplicable",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/logic/MethodResolutionLogic.java"
      }
    },
    "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8": {
      "type": "Ybodychange",
      "commitMessage": "removing TypeSolver from model.declarations\n",
      "commitDate": "2015-11-02, 2:48 p.m.",
      "commitName": "39477e7f9375d6a539eb0ddc69eb69d986b2a8c8",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-01, 8:35 a.m.",
      "commitNameOld": "52869e6fb17d3b13f60dea0064b90a81307392b4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.26,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType();\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 18,
      "functionName": "isApplicable",
      "diff": "@@ -1,31 +1,31 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n-            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n+            TypeUsage expectedType \u003d method.getParam(i).getType();\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                 isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                         expectedType.asReferenceTypeUsage(),\n                         actualType.asReferenceTypeUsage(),\n                         matchedParameters);\n             }\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3337bf584f7ef47f4f56b81743ca0d83930763bf": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-11-01, 6:02 a.m.",
      "commitName": "3337bf584f7ef47f4f56b81743ca0d83930763bf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-31, 7:08 p.m.",
      "commitNameOld": "0b419e87200878fe13db395a415efc4d1338cef2",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.5,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n                        expectedType.asReferenceTypeUsage(),\n                        actualType.asReferenceTypeUsage(),\n                        matchedParameters);\n            }\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 21,
      "functionName": "isApplicable",
      "diff": "@@ -1,24 +1,31 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n+        Map\u003cString, TypeUsage\u003e matchedParameters \u003d new HashMap\u003c\u003e();\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n             TypeUsage actualType \u003d paramTypes.get(i);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n+            if (!isAssignableWithoutSubstitution \u0026\u0026 expectedType.isReferenceType() \u0026\u0026 actualType.isReferenceType()) {\n+                isAssignableWithoutSubstitution \u003d isAssignableMatchTypeParameters(\n+                        expectedType.asReferenceTypeUsage(),\n+                        actualType.asReferenceTypeUsage(),\n+                        matchedParameters);\n+            }\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b419e87200878fe13db395a415efc4d1338cef2": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-10-31, 7:08 p.m.",
      "commitName": "0b419e87200878fe13db395a415efc4d1338cef2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-31, 5:22 a.m.",
      "commitNameOld": "960364fad3fc2ead6113d4c5d4b7d9ebf23e2f9a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.57,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n            TypeUsage actualType \u003d paramTypes.get(i);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(actualType)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "diff": "@@ -1,23 +1,24 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n-            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i));\n+            TypeUsage actualType \u003d paramTypes.get(i);\n+            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(actualType);\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n-                if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n+                if (!expectedType.isAssignableBy(actualType)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "adb02497ed443e836ae552e20bcb11ab8c1ab623": {
      "type": "Ybodychange",
      "commitMessage": "TypeUsage: clean up completed\n",
      "commitDate": "2015-10-30, 6:51 p.m.",
      "commitName": "adb02497ed443e836ae552e20bcb11ab8c1ab623",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 6:37 p.m.",
      "commitNameOld": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i));\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "diff": "@@ -1,23 +1,23 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n-            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n+            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i));\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n                     expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n-                if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n+                if (!expectedType.isAssignableBy(paramTypes.get(i))) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36f33050149a62a5b3c8c7451ae93f736715029": {
      "type": "Yfilerename",
      "commitMessage": "reorganize packages\n",
      "commitDate": "2015-10-30, 5:53 a.m.",
      "commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 5:29 a.m.",
      "commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/MethodResolutionLogic.java"
      }
    },
    "eec165d9e3ef0ab1d93f69a231964984a3379762": {
      "type": "Ybodychange",
      "commitMessage": "consider array modifiers\n",
      "commitDate": "2015-08-25, 5:57 a.m.",
      "commitName": "eec165d9e3ef0ab1d93f69a231964984a3379762",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-25, 3:22 a.m.",
      "commitNameOld": "558fc9b4f808d718b9b266071078752ba68d4203",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                }\n\n                if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "diff": "@@ -1,23 +1,23 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n             boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n             if (!isAssignableWithoutSubstitution) {\n                 for (TypeParameter tp : method.getTypeParameters()) {\n-                    expectedType \u003d replaceTypeParam(expectedType, tp);\n+                    expectedType \u003d replaceTypeParam(expectedType, tp, typeSolver);\n                 }\n \n                 if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                     return false;\n                 }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "558fc9b4f808d718b9b266071078752ba68d4203": {
      "type": "Ybodychange",
      "commitMessage": "improve method type parameter substitution\n",
      "commitDate": "2015-08-25, 3:22 a.m.",
      "commitName": "558fc9b4f808d718b9b266071078752ba68d4203",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 5:05 p.m.",
      "commitNameOld": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n            if (!isAssignableWithoutSubstitution) {\n                for (TypeParameter tp : method.getTypeParameters()) {\n                    expectedType \u003d replaceTypeParam(expectedType, tp);\n                }\n\n                if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "diff": "@@ -1,20 +1,23 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n-            for (TypeParameter tp : method.getTypeParameters()) {\n-                expectedType \u003d replaceTypeParam(expectedType, tp);\n-            }\n+            boolean isAssignableWithoutSubstitution \u003d expectedType.isAssignableBy(paramTypes.get(i), typeSolver);\n+            if (!isAssignableWithoutSubstitution) {\n+                for (TypeParameter tp : method.getTypeParameters()) {\n+                    expectedType \u003d replaceTypeParam(expectedType, tp);\n+                }\n \n-            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)){\n-                return false;\n+                if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)) {\n+                    return false;\n+                }\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
      "type": "Ybodychange",
      "commitMessage": "remove noise\n",
      "commitDate": "2015-08-24, 5:05 p.m.",
      "commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 4:42 p.m.",
      "commitNameOld": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp);\n            }\n\n            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)){\n                return false;\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "diff": "@@ -1,24 +1,20 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n             TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n             for (TypeParameter tp : method.getTypeParameters()) {\n                 expectedType \u003d replaceTypeParam(expectedType, tp);\n             }\n \n-            if (name.equals(\"cloneNodes\")) {\n-                System.out.println(\"foo\");\n-            }\n-\n             if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": {
      "type": "Ybodychange",
      "commitMessage": "considering method type parameters\n",
      "commitDate": "2015-08-24, 4:42 p.m.",
      "commitName": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 3:19 p.m.",
      "commitNameOld": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n            for (TypeParameter tp : method.getTypeParameters()) {\n                expectedType \u003d replaceTypeParam(expectedType, tp);\n            }\n\n            if (name.equals(\"cloneNodes\")) {\n                System.out.println(\"foo\");\n            }\n\n            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)){\n                return false;\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 19,
      "functionName": "isApplicable",
      "diff": "@@ -1,15 +1,24 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n-            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i), typeSolver)){\n+            TypeUsage expectedType \u003d method.getParam(i).getType(typeSolver);\n+            for (TypeParameter tp : method.getTypeParameters()) {\n+                expectedType \u003d replaceTypeParam(expectedType, tp);\n+            }\n+\n+            if (name.equals(\"cloneNodes\")) {\n+                System.out.println(\"foo\");\n+            }\n+\n+            if (!expectedType.isAssignableBy(paramTypes.get(i), typeSolver)){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a7fa0c3db19bd74be9affdd624447251963b68af": {
      "type": "Ybodychange",
      "commitMessage": "add tests for ClassOrInterfaceDeclarationContext.solveMethodAsUsage\n",
      "commitDate": "2015-08-19, 5:17 a.m.",
      "commitName": "a7fa0c3db19bd74be9affdd624447251963b68af",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-17, 3:28 p.m.",
      "commitNameOld": "b7eaf3c62cf45b94426b96eaf4ccab268bb5eaac",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i), typeSolver)){\n                return false;\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 16,
      "functionName": "isApplicable",
      "diff": "@@ -1,15 +1,15 @@\n     public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n-            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))){\n+            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i), typeSolver)){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80f951258992f75441239c79e0f31eda7d47e107": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-04, 9:54 a.m.",
      "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "wip\n",
          "commitDate": "2015-08-04, 9:54 a.m.",
          "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-03, 2:37 a.m.",
          "commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.3,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))){\n                return false;\n            }\n        }\n        return true;\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
          "functionStartLine": 14,
          "functionName": "isApplicable",
          "diff": "@@ -1,15 +1,15 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes) {\n+    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n-            if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))){\n+            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e]",
            "newValue": "[method-MethodDeclaration, name-String, paramTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "wip\n",
          "commitDate": "2015-08-04, 9:54 a.m.",
          "commitName": "80f951258992f75441239c79e0f31eda7d47e107",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2015-08-03, 2:37 a.m.",
          "commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.3,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))){\n                return false;\n            }\n        }\n        return true;\n    }",
          "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
          "functionStartLine": 14,
          "functionName": "isApplicable",
          "diff": "@@ -1,15 +1,15 @@\n-    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes) {\n+    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes, TypeSolver typeSolver) {\n         if (!method.getName().equals(name)) {\n             return false;\n         }\n         // TODO Consider varargs\n         if (method.getNoParams() !\u003d paramTypes.size()) {\n             return false;\n         }\n         for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n-            if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))){\n+            if (!method.getParam(i).getType(typeSolver).isAssignableBy(paramTypes.get(i))){\n                 return false;\n             }\n         }\n         return true;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd": {
      "type": "Yintroduced",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-02, 11:54 a.m.",
      "commitName": "d420a496cd03b7e9b5c4cce5074d8a74da69f3cd",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,15 @@\n+    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes) {\n+        if (!method.getName().equals(name)) {\n+            return false;\n+        }\n+        // TODO Consider varargs\n+        if (method.getNoParams() !\u003d paramTypes.size()) {\n+            return false;\n+        }\n+        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n+            if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))){\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public static boolean isApplicable(MethodDeclaration method, String name, List\u003cTypeUsage\u003e paramTypes) {\n        if (!method.getName().equals(name)) {\n            return false;\n        }\n        // TODO Consider varargs\n        if (method.getNoParams() !\u003d paramTypes.size()) {\n            return false;\n        }\n        for (int i\u003d0; i\u003cmethod.getNoParams(); i++) {\n            if (!method.getParam(i).getType().isAssignableBy(paramTypes.get(i))){\n                return false;\n            }\n        }\n        return true;\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/MethodResolutionLogic.java",
      "functionStartLine": 12,
      "functionName": "isApplicable"
    }
  }
}