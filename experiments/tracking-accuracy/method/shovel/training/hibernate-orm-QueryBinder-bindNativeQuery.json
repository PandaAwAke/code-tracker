{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "H:\\Projects\\hibernate\\hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "QueryBinder.java",
  "functionName": "bindNativeQuery",
  "functionId": "bindNativeQuery___queryAnn-NamedNativeQuery__context-MetadataBuildingContext__isDefault-boolean",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
  "functionStartLine": 86,
  "functionEndLine": 140,
  "numCommitsSeen": 53,
  "timeTaken": 3222,
  "changeHistory": [
    "9caca0ce37d5a2763d476c6fa2471addcca710ca",
    "a03d44f290deb8ccddc0827834e49e03fc8da275",
    "31f43e3321f5c286a7eae492a9885f4185767278",
    "6cda7dc5777307cd5c66c8f4231923bdafbb3bf1",
    "3edb72db4844c10aa8490472c4b1af05d75076ab",
    "129c0f13482b99e2705f0e234b6bc0572a95c271",
    "814b51493375bb781713a992353b6babba12dd31",
    "ad17f89c4c29f0327c843cf5265e156d65743ab1",
    "8c806d361d63764e8523006944dde52aff70532c",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
    "7419fc298dab9afe82fbdbb8b64854fa37f60817",
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
    "02451f12fbc3957ef3bc09ac0af79ffef1259bfb",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e",
    "7337743c93574823424ed6c399cfcf6bd75614f8"
  ],
  "changeHistoryShort": {
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": "Ymultichange(Yparameterchange,Ybodychange)",
    "a03d44f290deb8ccddc0827834e49e03fc8da275": "Ybodychange",
    "31f43e3321f5c286a7eae492a9885f4185767278": "Ybodychange",
    "6cda7dc5777307cd5c66c8f4231923bdafbb3bf1": "Ybodychange",
    "3edb72db4844c10aa8490472c4b1af05d75076ab": "Ybodychange",
    "129c0f13482b99e2705f0e234b6bc0572a95c271": "Ybodychange",
    "814b51493375bb781713a992353b6babba12dd31": "Ybodychange",
    "ad17f89c4c29f0327c843cf5265e156d65743ab1": "Ybodychange",
    "8c806d361d63764e8523006944dde52aff70532c": "Ybodychange",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": "Ybodychange",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": "Yfilerename",
    "7419fc298dab9afe82fbdbb8b64854fa37f60817": "Ybodychange",
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f": "Yparameterchange",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": "Yfilerename",
    "02451f12fbc3957ef3bc09ac0af79ffef1259bfb": "Ybodychange",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": "Yfilerename",
    "7337743c93574823424ed6c399cfcf6bd75614f8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
      "commitDate": "2015-03-10, 5:53 p.m.",
      "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "commitAuthor": "Steve Ebersole",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
          "commitDate": "2015-03-10, 5:53 p.m.",
          "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2013-11-24, 10:44 a.m.",
          "commitNameOld": "cd590470c0059981537e558a5ff6d114fd24df61",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 471.26,
          "commitsBetweenForRepo": 399,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery queryAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHintDefinition hints \u003d new QueryHintDefinition( queryAnn.hints() );\n\t\tString queryName \u003d queryAnn.query();\n\t\t\n\t\tNamedSQLQueryDefinitionBuilder builder \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n\t\t\t\t.setQuery( queryName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getBoolean( queryName, QueryHints.CACHEABLE ) )\n\t\t\t\t.setCacheRegion( hints.getString( queryName, QueryHints.CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout( queryName ) )\n\t\t\t\t.setFetchSize( hints.getInteger( queryName, QueryHints.FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode( queryName ) )\n\t\t\t\t.setCacheMode( hints.getCacheMode( queryName ) )\n\t\t\t\t.setReadOnly( hints.getBoolean( queryName, QueryHints.READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( queryName, QueryHints.COMMENT ) )\n\t\t\t\t.setParameterTypes( null )\n\t\t\t\t.setCallable( hints.getBoolean( queryName, QueryHints.CALLABLE ) );\n\t\t\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tbuilder.setResultSetRef( resultSetMapping )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} );\n\t\t}\n\t\telse {\n\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[0] );\n\t\t}\n\t\t\n\t\tNamedSQLQueryDefinition query \u003d builder.createNamedQueryDefinition();\n\t\t\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( query );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( query );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t\t}\n\t}",
          "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
          "functionStartLine": 103,
          "functionName": "bindNativeQuery",
          "diff": "@@ -1,52 +1,55 @@\n-\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n+\tpublic static void bindNativeQuery(\n+\t\t\tNamedNativeQuery queryAnn,\n+\t\t\tMetadataBuildingContext context,\n+\t\t\tboolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHintDefinition hints \u003d new QueryHintDefinition( queryAnn.hints() );\n \t\tString queryName \u003d queryAnn.query();\n \t\t\n \t\tNamedSQLQueryDefinitionBuilder builder \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n \t\t\t\t.setQuery( queryName )\n \t\t\t\t.setQuerySpaces( null )\n \t\t\t\t.setCacheable( hints.getBoolean( queryName, QueryHints.CACHEABLE ) )\n \t\t\t\t.setCacheRegion( hints.getString( queryName, QueryHints.CACHE_REGION ) )\n \t\t\t\t.setTimeout( hints.getTimeout( queryName ) )\n \t\t\t\t.setFetchSize( hints.getInteger( queryName, QueryHints.FETCH_SIZE ) )\n \t\t\t\t.setFlushMode( hints.getFlushMode( queryName ) )\n \t\t\t\t.setCacheMode( hints.getCacheMode( queryName ) )\n \t\t\t\t.setReadOnly( hints.getBoolean( queryName, QueryHints.READ_ONLY ) )\n \t\t\t\t.setComment( hints.getString( queryName, QueryHints.COMMENT ) )\n \t\t\t\t.setParameterTypes( null )\n \t\t\t\t.setCallable( hints.getBoolean( queryName, QueryHints.CALLABLE ) );\n \t\t\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tbuilder.setResultSetRef( resultSetMapping )\n \t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} );\n \t\t}\n \t\telse {\n \t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[0] );\n \t\t}\n \t\t\n \t\tNamedSQLQueryDefinition query \u003d builder.createNamedQueryDefinition();\n \t\t\n \t\tif ( isDefault ) {\n-\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n+\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( query );\n \t\t}\n \t\telse {\n-\t\t\tmappings.addSQLQuery( query.getName(), query );\n+\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( query );\n \t\t}\n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[queryAnn-NamedNativeQuery, mappings-Mappings, isDefault-boolean]",
            "newValue": "[queryAnn-NamedNativeQuery, context-MetadataBuildingContext, isDefault-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
          "commitDate": "2015-03-10, 5:53 p.m.",
          "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2013-11-24, 10:44 a.m.",
          "commitNameOld": "cd590470c0059981537e558a5ff6d114fd24df61",
          "commitAuthorOld": "Steve Ebersole",
          "daysBetweenCommits": 471.26,
          "commitsBetweenForRepo": 399,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery queryAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHintDefinition hints \u003d new QueryHintDefinition( queryAnn.hints() );\n\t\tString queryName \u003d queryAnn.query();\n\t\t\n\t\tNamedSQLQueryDefinitionBuilder builder \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n\t\t\t\t.setQuery( queryName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getBoolean( queryName, QueryHints.CACHEABLE ) )\n\t\t\t\t.setCacheRegion( hints.getString( queryName, QueryHints.CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout( queryName ) )\n\t\t\t\t.setFetchSize( hints.getInteger( queryName, QueryHints.FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode( queryName ) )\n\t\t\t\t.setCacheMode( hints.getCacheMode( queryName ) )\n\t\t\t\t.setReadOnly( hints.getBoolean( queryName, QueryHints.READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( queryName, QueryHints.COMMENT ) )\n\t\t\t\t.setParameterTypes( null )\n\t\t\t\t.setCallable( hints.getBoolean( queryName, QueryHints.CALLABLE ) );\n\t\t\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tbuilder.setResultSetRef( resultSetMapping )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} );\n\t\t}\n\t\telse {\n\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[0] );\n\t\t}\n\t\t\n\t\tNamedSQLQueryDefinition query \u003d builder.createNamedQueryDefinition();\n\t\t\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( query );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( query );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t\t}\n\t}",
          "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
          "functionStartLine": 103,
          "functionName": "bindNativeQuery",
          "diff": "@@ -1,52 +1,55 @@\n-\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n+\tpublic static void bindNativeQuery(\n+\t\t\tNamedNativeQuery queryAnn,\n+\t\t\tMetadataBuildingContext context,\n+\t\t\tboolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHintDefinition hints \u003d new QueryHintDefinition( queryAnn.hints() );\n \t\tString queryName \u003d queryAnn.query();\n \t\t\n \t\tNamedSQLQueryDefinitionBuilder builder \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n \t\t\t\t.setQuery( queryName )\n \t\t\t\t.setQuerySpaces( null )\n \t\t\t\t.setCacheable( hints.getBoolean( queryName, QueryHints.CACHEABLE ) )\n \t\t\t\t.setCacheRegion( hints.getString( queryName, QueryHints.CACHE_REGION ) )\n \t\t\t\t.setTimeout( hints.getTimeout( queryName ) )\n \t\t\t\t.setFetchSize( hints.getInteger( queryName, QueryHints.FETCH_SIZE ) )\n \t\t\t\t.setFlushMode( hints.getFlushMode( queryName ) )\n \t\t\t\t.setCacheMode( hints.getCacheMode( queryName ) )\n \t\t\t\t.setReadOnly( hints.getBoolean( queryName, QueryHints.READ_ONLY ) )\n \t\t\t\t.setComment( hints.getString( queryName, QueryHints.COMMENT ) )\n \t\t\t\t.setParameterTypes( null )\n \t\t\t\t.setCallable( hints.getBoolean( queryName, QueryHints.CALLABLE ) );\n \t\t\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tbuilder.setResultSetRef( resultSetMapping )\n \t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} );\n \t\t}\n \t\telse {\n \t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[0] );\n \t\t}\n \t\t\n \t\tNamedSQLQueryDefinition query \u003d builder.createNamedQueryDefinition();\n \t\t\n \t\tif ( isDefault ) {\n-\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n+\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( query );\n \t\t}\n \t\telse {\n-\t\t\tmappings.addSQLQuery( query.getName(), query );\n+\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( query );\n \t\t}\n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a03d44f290deb8ccddc0827834e49e03fc8da275": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8246 Implement XML binding of NamedStoredProcedureQuery\n",
      "commitDate": "2013-05-20, 11:37 p.m.",
      "commitName": "a03d44f290deb8ccddc0827834e49e03fc8da275",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2013-05-09, 3:47 p.m.",
      "commitNameOld": "8c95a6077a523c47482fbae14ab54b763fa73a23",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 11.33,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHintDefinition hints \u003d new QueryHintDefinition( queryAnn.hints() );\n\t\tString queryName \u003d queryAnn.query();\n\t\t\n\t\tNamedSQLQueryDefinitionBuilder builder \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n\t\t\t\t.setQuery( queryName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getBoolean( queryName, QueryHints.CACHEABLE ) )\n\t\t\t\t.setCacheRegion( hints.getString( queryName, QueryHints.CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout( queryName ) )\n\t\t\t\t.setFetchSize( hints.getInteger( queryName, QueryHints.FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode( queryName ) )\n\t\t\t\t.setCacheMode( hints.getCacheMode( queryName ) )\n\t\t\t\t.setReadOnly( hints.getBoolean( queryName, QueryHints.READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( queryName, QueryHints.COMMENT ) )\n\t\t\t\t.setParameterTypes( null )\n\t\t\t\t.setCallable( hints.getBoolean( queryName, QueryHints.CALLABLE ) );\n\t\t\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tbuilder.setResultSetRef( resultSetMapping )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} );\n\t\t}\n\t\telse {\n\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[0] );\n\t\t}\n\t\t\n\t\tNamedSQLQueryDefinition query \u003d builder.createNamedQueryDefinition();\n\t\t\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( query.getName(), query );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t\t}\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 98,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,52 +1,52 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n-\t\tQueryHint[] hints \u003d queryAnn.hints();\n+\t\tQueryHintDefinition hints \u003d new QueryHintDefinition( queryAnn.hints() );\n \t\tString queryName \u003d queryAnn.query();\n \t\t\n \t\tNamedSQLQueryDefinitionBuilder builder \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n \t\t\t\t.setQuery( queryName )\n \t\t\t\t.setQuerySpaces( null )\n-\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n-\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n-\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n-\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n-\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n-\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n-\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n-\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n+\t\t\t\t.setCacheable( hints.getBoolean( queryName, QueryHints.CACHEABLE ) )\n+\t\t\t\t.setCacheRegion( hints.getString( queryName, QueryHints.CACHE_REGION ) )\n+\t\t\t\t.setTimeout( hints.getTimeout( queryName ) )\n+\t\t\t\t.setFetchSize( hints.getInteger( queryName, QueryHints.FETCH_SIZE ) )\n+\t\t\t\t.setFlushMode( hints.getFlushMode( queryName ) )\n+\t\t\t\t.setCacheMode( hints.getCacheMode( queryName ) )\n+\t\t\t\t.setReadOnly( hints.getBoolean( queryName, QueryHints.READ_ONLY ) )\n+\t\t\t\t.setComment( hints.getString( queryName, QueryHints.COMMENT ) )\n \t\t\t\t.setParameterTypes( null )\n-\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) );\n+\t\t\t\t.setCallable( hints.getBoolean( queryName, QueryHints.CALLABLE ) );\n \t\t\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tbuilder.setResultSetRef( resultSetMapping )\n \t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} );\n \t\t}\n \t\telse {\n \t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[0] );\n \t\t}\n \t\t\n \t\tNamedSQLQueryDefinition query \u003d builder.createNamedQueryDefinition();\n \t\t\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( query.getName(), query );\n \t\t}\n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "31f43e3321f5c286a7eae492a9885f4185767278": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4412 Cleanup and copyrights",
      "commitDate": "2013-03-06, 9:31 a.m.",
      "commitName": "31f43e3321f5c286a7eae492a9885f4185767278",
      "commitAuthor": "Brett Meyer",
      "commitDateOld": "2013-03-06, 8:49 a.m.",
      "commitNameOld": "6cda7dc5777307cd5c66c8f4231923bdafbb3bf1",
      "commitAuthorOld": "Janario Oliveira",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\t\n\t\tNamedSQLQueryDefinitionBuilder builder \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n\t\t\t\t.setQuery( queryName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n\t\t\t\t.setParameterTypes( null )\n\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) );\n\t\t\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tbuilder.setResultSetRef( resultSetMapping )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} );\n\t\t}\n\t\telse {\n\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[0] );\n\t\t}\n\t\t\n\t\tNamedSQLQueryDefinition query \u003d builder.createNamedQueryDefinition();\n\t\t\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( query.getName(), query );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t\t}\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 111,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,72 +1,52 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n-\t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n+\t\t\n+\t\tNamedSQLQueryDefinitionBuilder builder \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n+\t\t\t\t.setQuery( queryName )\n+\t\t\t\t.setQuerySpaces( null )\n+\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n+\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n+\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n+\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n+\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n+\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n+\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n+\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n+\t\t\t\t.setParameterTypes( null )\n+\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) );\n+\t\t\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n-\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n-\t\t\t\t\t.setQuery( queryName )\n-\t\t\t\t\t.setResultSetRef( resultSetMapping )\n-\t\t\t\t\t.setQuerySpaces( null )\n-\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n-\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n-\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n-\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n-\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n-\t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n-\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n-\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n-\t\t\t\t\t.setParameterTypes( null )\n-\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n+\t\t\tbuilder.setResultSetRef( resultSetMapping )\n \t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n-\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n-\t\t\t\t\t.setQuery( queryName )\n-\t\t\t\t\t.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} )\n-\t\t\t\t\t.setQuerySpaces( null )\n-\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n-\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n-\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n-\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n-\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n-\t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n-\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n-\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n-\t\t\t\t\t.setParameterTypes( null )\n-\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n-\t\t\t\t\t.createNamedQueryDefinition();\n+\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} );\n \t\t}\n \t\telse {\n-\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() ).setQuery( queryName )\n-\t\t\t\t\t.setQueryReturns( new NativeSQLQueryReturn[0] ).setQuerySpaces( null )\n-\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n-\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n-\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n-\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n-\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) ).setCacheMode( getCacheMode( queryName, hints ) )\n-\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n-\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) ).setParameterTypes( null )\n-\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n-\t\t\t\t\t.createNamedQueryDefinition();\n+\t\t\tbuilder.setQueryReturns( new NativeSQLQueryReturn[0] );\n \t\t}\n+\t\t\n+\t\tNamedSQLQueryDefinition query \u003d builder.createNamedQueryDefinition();\n+\t\t\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( query.getName(), query );\n \t\t}\n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6cda7dc5777307cd5c66c8f4231923bdafbb3bf1": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4412 - Created native query to insert, delete, update\n",
      "commitDate": "2013-03-06, 8:49 a.m.",
      "commitName": "6cda7dc5777307cd5c66c8f4231923bdafbb3bf1",
      "commitAuthor": "Janario Oliveira",
      "commitDateOld": "2012-07-18, 5:52 p.m.",
      "commitNameOld": "3edb72db4844c10aa8490472c4b1af05d75076ab",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 230.66,
      "commitsBetweenForRepo": 433,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n\t\t\t\t\t.setQuery( queryName )\n\t\t\t\t\t.setResultSetRef( resultSetMapping )\n\t\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n\t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n\t\t\t\t\t.setParameterTypes( null )\n\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n\t\t\t\t\t.setQuery( queryName )\n\t\t\t\t\t.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} )\n\t\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n\t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n\t\t\t\t\t.setParameterTypes( null )\n\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\telse {\n\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() ).setQuery( queryName )\n\t\t\t\t\t.setQueryReturns( new NativeSQLQueryReturn[0] ).setQuerySpaces( null )\n\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) ).setCacheMode( getCacheMode( queryName, hints ) )\n\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) ).setParameterTypes( null )\n\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( query.getName(), query );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t\t}\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 111,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,62 +1,72 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n \t\t\t\t\t.setQuery( queryName )\n \t\t\t\t\t.setResultSetRef( resultSetMapping )\n \t\t\t\t\t.setQuerySpaces( null )\n \t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n \t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n \t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n \t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n \t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n \t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n \t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n \t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n \t\t\t\t\t.setParameterTypes( null )\n \t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n \t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n \t\t\t\t\t.setQuery( queryName )\n \t\t\t\t\t.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} )\n \t\t\t\t\t.setQuerySpaces( null )\n \t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n \t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n \t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n \t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n \t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n \t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n \t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n \t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n \t\t\t\t\t.setParameterTypes( null )\n \t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n \t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\telse {\n-\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n+\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() ).setQuery( queryName )\n+\t\t\t\t\t.setQueryReturns( new NativeSQLQueryReturn[0] ).setQuerySpaces( null )\n+\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n+\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n+\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n+\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n+\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) ).setCacheMode( getCacheMode( queryName, hints ) )\n+\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n+\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) ).setParameterTypes( null )\n+\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n+\t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( query.getName(), query );\n \t\t}\n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3edb72db4844c10aa8490472c4b1af05d75076ab": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7387 - Integrate Draft 6 of the JPA 2.1 spec : addNamedQuery support\n",
      "commitDate": "2012-07-18, 5:52 p.m.",
      "commitName": "3edb72db4844c10aa8490472c4b1af05d75076ab",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012-05-30, 11:25 a.m.",
      "commitNameOld": "0c1569c4f4ade941398d749401f03fdf04306e35",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 49.27,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n\t\t\t\t\t.setQuery( queryName )\n\t\t\t\t\t.setResultSetRef( resultSetMapping )\n\t\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n\t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n\t\t\t\t\t.setParameterTypes( null )\n\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n\t\t\t\t\t.setQuery( queryName )\n\t\t\t\t\t.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} )\n\t\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n\t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n\t\t\t\t\t.setParameterTypes( null )\n\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n\t\t\t\t\t.createNamedQueryDefinition();\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( query.getName(), query );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t\t}\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 111,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,64 +1,62 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n-\t\t\tquery \u003d new NamedSQLQueryDefinition(\n-\t\t\t\t\tqueryAnn.name(),\n-\t\t\t\t\tqueryName,\n-\t\t\t\t\tresultSetMapping,\n-\t\t\t\t\tnull,\n-\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n-\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n-\t\t\t\t\tgetTimeout( queryName, hints ),\n-\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n-\t\t\t\t\tgetFlushMode( queryName, hints ),\n-\t\t\t\t\tgetCacheMode( queryName, hints ),\n-\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n-\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n-\t\t\t\t\tnull,\n-\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n-\t\t\t);\n+\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n+\t\t\t\t\t.setQuery( queryName )\n+\t\t\t\t\t.setResultSetRef( resultSetMapping )\n+\t\t\t\t\t.setQuerySpaces( null )\n+\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n+\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n+\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n+\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n+\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n+\t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n+\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n+\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n+\t\t\t\t\t.setParameterTypes( null )\n+\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n+\t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n-\t\t\tquery \u003d new NamedSQLQueryDefinition(\n-\t\t\t\t\tqueryAnn.name(),\n-\t\t\t\t\tqueryName,\n-\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n-\t\t\t\t\tnull,\n-\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n-\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n-\t\t\t\t\tgetTimeout( queryName, hints ),\n-\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n-\t\t\t\t\tgetFlushMode( queryName, hints ),\n-\t\t\t\t\tgetCacheMode( queryName, hints ),\n-\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n-\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n-\t\t\t\t\tnull,\n-\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n-\t\t\t);\n+\t\t\tquery \u003d new NamedSQLQueryDefinitionBuilder( queryAnn.name() )\n+\t\t\t\t\t.setQuery( queryName )\n+\t\t\t\t\t.setQueryReturns( new NativeSQLQueryReturn[] {entityQueryReturn} )\n+\t\t\t\t\t.setQuerySpaces( null )\n+\t\t\t\t\t.setCacheable( getBoolean( queryName, \"org.hibernate.cacheable\", hints ) )\n+\t\t\t\t\t.setCacheRegion( getString( queryName, \"org.hibernate.cacheRegion\", hints ) )\n+\t\t\t\t\t.setTimeout( getTimeout( queryName, hints ) )\n+\t\t\t\t\t.setFetchSize( getInteger( queryName, \"org.hibernate.fetchSize\", hints ) )\n+\t\t\t\t\t.setFlushMode( getFlushMode( queryName, hints ) )\n+\t\t\t\t\t.setCacheMode( getCacheMode( queryName, hints ) )\n+\t\t\t\t\t.setReadOnly( getBoolean( queryName, \"org.hibernate.readOnly\", hints ) )\n+\t\t\t\t\t.setComment( getString( queryName, \"org.hibernate.comment\", hints ) )\n+\t\t\t\t\t.setParameterTypes( null )\n+\t\t\t\t\t.setCallable( getBoolean( queryName, \"org.hibernate.callable\", hints ) )\n+\t\t\t\t\t.createNamedQueryDefinition();\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( query.getName(), query );\n \t\t}\n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "129c0f13482b99e2705f0e234b6bc0572a95c271": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6732 more logging trace statements are missing guards against unneeded string creation\n",
      "commitDate": "2011-10-26, 6:24 p.m.",
      "commitName": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "commitAuthor": "Sanne Grinovero",
      "commitDateOld": "2011-10-24, 4:26 a.m.",
      "commitNameOld": "bdba5898c90ef7667e7c5df35e72d2e993e32556",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryAnn.name(),\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryAnn.name(),\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( query.getName(), query );\n\t\t}\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t\t}\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 93,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,61 +1,64 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n-        if (BinderHelper.isEmptyAnnotationValue(queryAnn.name())) throw new AnnotationException(\n-                                                                                                \"A named query must have a name when used in class or package level\");\n+\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n+\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n+\t\t}\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryAnn.name(),\n \t\t\t\t\tqueryName,\n \t\t\t\t\tresultSetMapping,\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryAnn.name(),\n \t\t\t\t\tqueryName,\n \t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( query.getName(), query );\n \t\t}\n-        LOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n+\t\tif ( LOG.isDebugEnabled() ) {\n+\t\t\tLOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n+\t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "814b51493375bb781713a992353b6babba12dd31": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6110 : Integrate new metamodel into persisters\n",
      "commitDate": "2011-06-07, 5:41 a.m.",
      "commitName": "814b51493375bb781713a992353b6babba12dd31",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2011-05-04, 6:15 p.m.",
      "commitNameOld": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 33.48,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n        if (BinderHelper.isEmptyAnnotationValue(queryAnn.name())) throw new AnnotationException(\n                                                                                                \"A named query must have a name when used in class or package level\");\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryAnn.name(),\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryAnn.name(),\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( query.getName(), query );\n\t\t}\n        LOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 89,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,59 +1,61 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n         if (BinderHelper.isEmptyAnnotationValue(queryAnn.name())) throw new AnnotationException(\n                                                                                                 \"A named query must have a name when used in class or package level\");\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n+\t\t\t\t\tqueryAnn.name(),\n \t\t\t\t\tqueryName,\n \t\t\t\t\tresultSetMapping,\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n+\t\t\t\t\tqueryAnn.name(),\n \t\t\t\t\tqueryName,\n \t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n-\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n+\t\t\tmappings.addDefaultSQLQuery( query.getName(), query );\n \t\t}\n \t\telse {\n-\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n+\t\t\tmappings.addSQLQuery( query.getName(), query );\n \t\t}\n         LOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad17f89c4c29f0327c843cf5265e156d65743ab1": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6097 - Review log levels, especially related to i18n messages\n",
      "commitDate": "2011-04-12, 10:07 a.m.",
      "commitName": "ad17f89c4c29f0327c843cf5265e156d65743ab1",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011-04-08, 10:44 a.m.",
      "commitNameOld": "6504cb6d78740d2a4695096463f40baf18c9af11",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 3.97,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n        if (BinderHelper.isEmptyAnnotationValue(queryAnn.name())) throw new AnnotationException(\n                                                                                                \"A named query must have a name when used in class or package level\");\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n        LOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 88,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,59 +1,59 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n         if (BinderHelper.isEmptyAnnotationValue(queryAnn.name())) throw new AnnotationException(\n                                                                                                 \"A named query must have a name when used in class or package level\");\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tresultSetMapping,\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n \t\t}\n-        LOG.bindingNamedNativeQuery( queryAnn.name(), queryAnn.query() );\n+        LOG.debugf( \"Binding named native query: %s \u003d\u003e %s\", queryAnn.name(), queryAnn.query() );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c806d361d63764e8523006944dde52aff70532c": {
      "type": "Ybodychange",
      "commitMessage": "Changes from requests at Hibernate meeting: message codes, use XXXf methods for debug and trace, use @Cause\n",
      "commitDate": "2011-02-08, 2:55 p.m.",
      "commitName": "8c806d361d63764e8523006944dde52aff70532c",
      "commitAuthor": "JPAV",
      "commitDateOld": "2011-01-18, 5:00 p.m.",
      "commitNameOld": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 20.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n        if (BinderHelper.isEmptyAnnotationValue(queryAnn.name())) throw new AnnotationException(\n                                                                                                \"A named query must have a name when used in class or package level\");\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n        LOG.bindingNamedNativeQuery(queryAnn.name(), queryAnn.query());\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 87,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,60 +1,59 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n-\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n-\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n-\t\t}\n+        if (BinderHelper.isEmptyAnnotationValue(queryAnn.name())) throw new AnnotationException(\n+                                                                                                \"A named query must have a name when used in class or package level\");\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tresultSetMapping,\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n \t\t}\n         LOG.bindingNamedNativeQuery(queryAnn.name(), queryAnn.query());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": {
      "type": "Ybodychange",
      "commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n\u0027d where it was clear how to do so.\n",
      "commitDate": "2011-01-18, 4:35 p.m.",
      "commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthor": "JPAV",
      "commitDateOld": "2010-10-11, 3:41 p.m.",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 99.08,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n        LOG.bindingNamedNativeQuery(queryAnn.name(), queryAnn.query());\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 93,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,60 +1,60 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tresultSetMapping,\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n \t\t}\n-\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n+        LOG.bindingNamedNativeQuery(queryAnn.name(), queryAnn.query());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
      "commitDate": "2010-10-11, 3:41 p.m.",
      "commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-10-11, 2:51 p.m.",
      "commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 90,
      "functionName": "bindNativeQuery",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java"
      }
    },
    "7419fc298dab9afe82fbdbb8b64854fa37f60817": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5205 - Renamed BinderHelper.isDefault() to BinderHelper.isEmptyAnnotationValue() , because this describes better what the function does. Also renamed VersionTest to OptimisitcLockAnnotationTest to better describe what gets tested.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20741 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-09-28, 12:32 p.m.",
      "commitName": "7419fc298dab9afe82fbdbb8b64854fa37f60817",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010-08-12, 3:13 p.m.",
      "commitNameOld": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 46.89,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 90,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,60 +1,60 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n-\t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n+\t\tif ( BinderHelper.isEmptyAnnotationValue( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n-\t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n+\t\tif ( !BinderHelper.isEmptyAnnotationValue( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tresultSetMapping,\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f": {
      "type": "Yparameterchange",
      "commitMessage": "HHH-5474 - Clean up usages of now deprecated ExtendedMappings\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20136 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-08-12, 3:13 p.m.",
      "commitName": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-07-08, 7:56 p.m.",
      "commitNameOld": "df184979ed2f19887bbea46603148dd59d3bfd1f",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 34.8,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 90,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,60 +1,60 @@\n-\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, ExtendedMappings mappings, boolean isDefault) {\n+\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, Mappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tresultSetMapping,\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n \t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[queryAnn-NamedNativeQuery, mappings-ExtendedMappings, isDefault-boolean]",
        "newValue": "[queryAnn-NamedNativeQuery, mappings-Mappings, isDefault-boolean]"
      }
    },
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5367 - Move annotations module sources into core module\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19921 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-07-08, 7:41 p.m.",
      "commitName": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-07-08, 1:32 p.m.",
      "commitNameOld": "cc3b41a09c983913594b16d6c909be0bfd41bd7a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, ExtendedMappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 90,
      "functionName": "bindNativeQuery",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
        "newPath": "core/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java"
      }
    },
    "02451f12fbc3957ef3bc09ac0af79ffef1259bfb": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4662 Implement javax.persistence.query.timeout\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18852 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-02-22, 6:27 p.m.",
      "commitName": "02451f12fbc3957ef3bc09ac0af79ffef1259bfb",
      "commitAuthor": "Scott Marlow",
      "commitDateOld": "2008-10-28, 5:41 p.m.",
      "commitNameOld": "513c71de5c5c6fb65bbc2a191ab7a9e565e304d5",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 482.07,
      "commitsBetweenForRepo": 917,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, ExtendedMappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetTimeout( queryName, hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 90,
      "functionName": "bindNativeQuery",
      "diff": "@@ -1,60 +1,60 @@\n \tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, ExtendedMappings mappings, boolean isDefault) {\n \t\tif ( queryAnn \u003d\u003d null ) return;\n \t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n \t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n \t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n \t\t}\n \t\tNamedSQLQueryDefinition query;\n \t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n \t\tQueryHint[] hints \u003d queryAnn.hints();\n \t\tString queryName \u003d queryAnn.query();\n \t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n \t\t\t//sql result set usage\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tresultSetMapping,\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n-\t\t\t\t\tgetInteger( queryName, \"org.hibernate.timeout\", hints ),\n+\t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n \t\t\t//class mapping usage\n \t\t\t//FIXME should be done in a second pass due to entity name?\n \t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n \t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n \t\t\tquery \u003d new NamedSQLQueryDefinition(\n \t\t\t\t\tqueryName,\n \t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n-\t\t\t\t\tgetInteger( queryName, \"org.hibernate.timeout\", hints ),\n+\t\t\t\t\tgetTimeout( queryName, hints ),\n \t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n \t\t\t\t\tgetFlushMode( queryName, hints ),\n \t\t\t\t\tgetCacheMode( queryName, hints ),\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n \t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n \t\t\t\t\tnull,\n \t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n \t\t}\n \t\tif ( isDefault ) {\n \t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n \t\t}\n \t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": {
      "type": "Yfilerename",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15418 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-28, 2:53 p.m.",
      "commitName": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2008-10-28, 2:52 p.m.",
      "commitNameOld": "c457f2b3258fc48ef4010a9e58cd2fc3baaca6cc",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, ExtendedMappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.timeout\", hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.timeout\", hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 68,
      "functionName": "bindNativeQuery",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/java/org/hibernate/cfg/annotations/QueryBinder.java",
        "newPath": "annotations/src/main/java/org/hibernate/cfg/annotations/QueryBinder.java"
      }
    },
    "7337743c93574823424ed6c399cfcf6bd75614f8": {
      "type": "Yintroduced",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15415 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-28, 2:41 p.m.",
      "commitName": "7337743c93574823424ed6c399cfcf6bd75614f8",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,60 @@\n+\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, ExtendedMappings mappings, boolean isDefault) {\n+\t\tif ( queryAnn \u003d\u003d null ) return;\n+\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n+\t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n+\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n+\t\t}\n+\t\tNamedSQLQueryDefinition query;\n+\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n+\t\tQueryHint[] hints \u003d queryAnn.hints();\n+\t\tString queryName \u003d queryAnn.query();\n+\t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n+\t\t\t//sql result set usage\n+\t\t\tquery \u003d new NamedSQLQueryDefinition(\n+\t\t\t\t\tqueryName,\n+\t\t\t\t\tresultSetMapping,\n+\t\t\t\t\tnull,\n+\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n+\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n+\t\t\t\t\tgetInteger( queryName, \"org.hibernate.timeout\", hints ),\n+\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n+\t\t\t\t\tgetFlushMode( queryName, hints ),\n+\t\t\t\t\tgetCacheMode( queryName, hints ),\n+\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n+\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n+\t\t\t\t\tnull,\n+\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n+\t\t\t);\n+\t\t}\n+\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n+\t\t\t//class mapping usage\n+\t\t\t//FIXME should be done in a second pass due to entity name?\n+\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n+\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n+\t\t\tquery \u003d new NamedSQLQueryDefinition(\n+\t\t\t\t\tqueryName,\n+\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n+\t\t\t\t\tnull,\n+\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n+\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n+\t\t\t\t\tgetInteger( queryName, \"org.hibernate.timeout\", hints ),\n+\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n+\t\t\t\t\tgetFlushMode( queryName, hints ),\n+\t\t\t\t\tgetCacheMode( queryName, hints ),\n+\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n+\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n+\t\t\t\t\tnull,\n+\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n+\t\t\t);\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n+\t\t}\n+\t\tif ( isDefault ) {\n+\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n+\t\t}\n+\t\telse {\n+\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n+\t\t}\n+\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic static void bindNativeQuery(NamedNativeQuery queryAnn, ExtendedMappings mappings, boolean isDefault) {\n\t\tif ( queryAnn \u003d\u003d null ) return;\n\t\t//ResultSetMappingDefinition mappingDefinition \u003d mappings.getResultSetMapping( queryAnn.resultSetMapping() );\n\t\tif ( BinderHelper.isDefault( queryAnn.name() ) ) {\n\t\t\tthrow new AnnotationException( \"A named query must have a name when used in class or package level\" );\n\t\t}\n\t\tNamedSQLQueryDefinition query;\n\t\tString resultSetMapping \u003d queryAnn.resultSetMapping();\n\t\tQueryHint[] hints \u003d queryAnn.hints();\n\t\tString queryName \u003d queryAnn.query();\n\t\tif ( !BinderHelper.isDefault( resultSetMapping ) ) {\n\t\t\t//sql result set usage\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tresultSetMapping,\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.timeout\", hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse if ( !void.class.equals( queryAnn.resultClass() ) ) {\n\t\t\t//class mapping usage\n\t\t\t//FIXME should be done in a second pass due to entity name?\n\t\t\tfinal NativeSQLQueryRootReturn entityQueryReturn \u003d\n\t\t\t\t\tnew NativeSQLQueryRootReturn( \"alias1\", queryAnn.resultClass().getName(), new HashMap(), LockMode.READ );\n\t\t\tquery \u003d new NamedSQLQueryDefinition(\n\t\t\t\t\tqueryName,\n\t\t\t\t\tnew NativeSQLQueryReturn[] { entityQueryReturn },\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.cacheable\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.cacheRegion\", hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.timeout\", hints ),\n\t\t\t\t\tgetInteger( queryName, \"org.hibernate.fetchSize\", hints ),\n\t\t\t\t\tgetFlushMode( queryName, hints ),\n\t\t\t\t\tgetCacheMode( queryName, hints ),\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.readOnly\", hints ),\n\t\t\t\t\tgetString( queryName, \"org.hibernate.comment\", hints ),\n\t\t\t\t\tnull,\n\t\t\t\t\tgetBoolean( queryName, \"org.hibernate.callable\", hints )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotYetImplementedException( \"Pure native scalar queries are not yet supported\" );\n\t\t}\n\t\tif ( isDefault ) {\n\t\t\tmappings.addDefaultSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSQLQuery( queryAnn.name(), query );\n\t\t}\n\t\tlog.info( \"Binding named native query: {} \u003d\u003e {}\", queryAnn.name(), queryAnn.query() );\n\t}",
      "path": "annotations/src/java/org/hibernate/cfg/annotations/QueryBinder.java",
      "functionStartLine": 68,
      "functionName": "bindNativeQuery"
    }
  }
}