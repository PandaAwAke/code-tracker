{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "H:\\Projects\\spring-projects\\spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "ResponseBodyResultHandler.java",
  "functionName": "handleResult",
  "functionId": "handleResult___exchange-ServerWebExchange__result-HandlerResult",
  "sourceFilePath": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
  "functionStartLine": 83,
  "functionEndLine": 87,
  "numCommitsSeen": 99,
  "timeTaken": 2191,
  "changeHistory": [
    "db69a082d9449ecb13f615316a382c100cab1f23",
    "fafd2d20e177d56b5d08dfa630b920d7095877da",
    "101220bad1ac3b4082a08aff4e9c8254e71febaf",
    "8c7658144284f2f47124c6ac8131f53320091551",
    "dffd6d674ab9415caed1b82755634f52383cd7ba",
    "9aa6f5caacac316c74e374550a387f222e7e1921",
    "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1",
    "318b15c321963ad772ae9e4762c25b205047a463",
    "2263954ad7d760c145eeaf4b02c2e9a68f118ad1",
    "37404d081e807c1f4926590a78f1d4da266fb5c3",
    "2292e46b04c65d4f3f8193b0eab249a8058e59a8",
    "91d063899bd816cc57815ac0b2317b3ab674868e",
    "804f69c8b6e8156462449a310a1e0865eb329b61",
    "6b7360fed1741bd9f7208f993f1df0036e2137d6",
    "341f23e0e666ce0a00090fe1cad91caa7cb5e97c",
    "7f786ce4d7a8b51a02133d7db404d9f038d5a927",
    "4197f002d87c1c02455cc640e20f89b28b10d271",
    "e92174c772c0d787be7721ae00c7189f16b05fb5",
    "381855aaf315adfd44e22797bbf14f07d08155d9",
    "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a",
    "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
    "8ef7e2ff77f913773e30b1463d4657368db700e5",
    "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
    "a0018d13e19f7fe7ef7a98979476d9cd2851a10c",
    "da98becf72fbeef836dba366431be2a652e5e001",
    "911d3769224d009fb9fe08c6cb5489686bbc5713",
    "81867fa4237643ca3eae24a8f085bc4b5f9443b3",
    "54ce20a5e04275835b40f2cd1453db778264191e",
    "c6713c23e327961d021706e5b1e4d5ebe8e2f458",
    "5d4201d50079fc36fee21617ece1bfbbcf194120",
    "2de127ad4ad8dcb81521039749308de58ac81420",
    "bdc5b38cb12d26605a968845338bef5bad22816d",
    "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b",
    "c0dff3d2bb2277429f4e387d18deb75b0797a375",
    "45a88974bc9545eff6c7de07d054a2836dcbdfca",
    "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
    "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
    "cf2c1514af43bc955571ede20876d6cda1779f11",
    "8ca04b84259f1840db7e1037828f7120427eb7b1",
    "464ff1d9606a3189a41bae80e504929dec091d33",
    "f816cc6a516c324875fa409a33d288447c6996f7",
    "110d9d7cd906c524af5053329a65ef4e1bd9f7eb",
    "881db0688b5448768e1b3196fe5365a3d41d9342",
    "202825554c022e4262fe3bd20a34faf01ab9d620"
  ],
  "changeHistoryShort": {
    "db69a082d9449ecb13f615316a382c100cab1f23": "Ybodychange",
    "fafd2d20e177d56b5d08dfa630b920d7095877da": "Yfilerename",
    "101220bad1ac3b4082a08aff4e9c8254e71febaf": "Ybodychange",
    "8c7658144284f2f47124c6ac8131f53320091551": "Ybodychange",
    "dffd6d674ab9415caed1b82755634f52383cd7ba": "Ybodychange",
    "9aa6f5caacac316c74e374550a387f222e7e1921": "Ybodychange",
    "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1": "Ybodychange",
    "318b15c321963ad772ae9e4762c25b205047a463": "Ybodychange",
    "2263954ad7d760c145eeaf4b02c2e9a68f118ad1": "Ybodychange",
    "37404d081e807c1f4926590a78f1d4da266fb5c3": "Ybodychange",
    "2292e46b04c65d4f3f8193b0eab249a8058e59a8": "Ybodychange",
    "91d063899bd816cc57815ac0b2317b3ab674868e": "Ybodychange",
    "804f69c8b6e8156462449a310a1e0865eb329b61": "Ybodychange",
    "6b7360fed1741bd9f7208f993f1df0036e2137d6": "Ybodychange",
    "341f23e0e666ce0a00090fe1cad91caa7cb5e97c": "Yfilerename",
    "7f786ce4d7a8b51a02133d7db404d9f038d5a927": "Ybodychange",
    "4197f002d87c1c02455cc640e20f89b28b10d271": "Ybodychange",
    "e92174c772c0d787be7721ae00c7189f16b05fb5": "Ybodychange",
    "381855aaf315adfd44e22797bbf14f07d08155d9": "Yparameterchange",
    "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a": "Ybodychange",
    "4f614fa0fd74ce29c5822e70f4815cc40745a2be": "Ymultichange(Yparameterchange,Ybodychange)",
    "8ef7e2ff77f913773e30b1463d4657368db700e5": "Ymultichange(Yreturntypechange,Ybodychange)",
    "9789db23d2973d8f0156d2b6c6027d9fb67ab844": "Ybodychange",
    "a0018d13e19f7fe7ef7a98979476d9cd2851a10c": "Ybodychange",
    "da98becf72fbeef836dba366431be2a652e5e001": "Yparameterchange",
    "911d3769224d009fb9fe08c6cb5489686bbc5713": "Ybodychange",
    "81867fa4237643ca3eae24a8f085bc4b5f9443b3": "Yfilerename",
    "54ce20a5e04275835b40f2cd1453db778264191e": "Ybodychange",
    "c6713c23e327961d021706e5b1e4d5ebe8e2f458": "Ybodychange",
    "5d4201d50079fc36fee21617ece1bfbbcf194120": "Ybodychange",
    "2de127ad4ad8dcb81521039749308de58ac81420": "Ybodychange",
    "bdc5b38cb12d26605a968845338bef5bad22816d": "Ybodychange",
    "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b": "Ybodychange",
    "c0dff3d2bb2277429f4e387d18deb75b0797a375": "Ybodychange",
    "45a88974bc9545eff6c7de07d054a2836dcbdfca": "Ybodychange",
    "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033": "Ymultichange(Yparameterchange,Ybodychange)",
    "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa": "Ybodychange",
    "cf2c1514af43bc955571ede20876d6cda1779f11": "Ybodychange",
    "8ca04b84259f1840db7e1037828f7120427eb7b1": "Ybodychange",
    "464ff1d9606a3189a41bae80e504929dec091d33": "Ybodychange",
    "f816cc6a516c324875fa409a33d288447c6996f7": "Ybodychange",
    "110d9d7cd906c524af5053329a65ef4e1bd9f7eb": "Ybodychange",
    "881db0688b5448768e1b3196fe5365a3d41d9342": "Ybodychange",
    "202825554c022e4262fe3bd20a34faf01ab9d620": "Yintroduced"
  },
  "changeHistoryDetails": {
    "db69a082d9449ecb13f615316a382c100cab1f23": {
      "type": "Ybodychange",
      "commitMessage": "Avoid java.util.Optional signatures for simple field access\n\nIssue: SPR-15576\n",
      "commitDate": "2017-05-23, 4:05 p.m.",
      "commitName": "db69a082d9449ecb13f615316a382c100cab1f23",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-03-24, 5:48 p.m.",
      "commitNameOld": "5414cd0cf8228d4cd1a3873ae18b4fcb91b6e556",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 59.93,
      "commitsBetweenForRepo": 333,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tObject body \u003d result.getReturnValue();\n\t\tMethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n\t\treturn writeBody(body, bodyTypeParameter, exchange);\n\t}",
      "path": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 85,
      "functionName": "handleResult",
      "diff": "@@ -1,5 +1,5 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n-\t\tObject body \u003d result.getReturnValue().orElse(null);\n+\t\tObject body \u003d result.getReturnValue();\n \t\tMethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n \t\treturn writeBody(body, bodyTypeParameter, exchange);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fafd2d20e177d56b5d08dfa630b920d7095877da": {
      "type": "Yfilerename",
      "commitMessage": "Rename spring-web-reactive to spring-webflux\n\nIssue: SPR-15190\n",
      "commitDate": "2017-02-01, 5:02 p.m.",
      "commitName": "fafd2d20e177d56b5d08dfa630b920d7095877da",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2017-02-01, 3:29 p.m.",
      "commitNameOld": "81d121797645c65cbfc5a85b73b3540e1ab0ea92",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tObject body \u003d result.getReturnValue().orElse(null);\n\t\tMethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n\t\treturn writeBody(body, bodyTypeParameter, exchange);\n\t}",
      "path": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 117,
      "functionName": "handleResult",
      "diff": "",
      "extendedDetails": {
        "oldPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
        "newPath": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java"
      }
    },
    "101220bad1ac3b4082a08aff4e9c8254e71febaf": {
      "type": "Ybodychange",
      "commitMessage": "Add ReactiveAdapterRegistry\n\nIssue: SPR-14159\n",
      "commitDate": "2016-07-22, 12:21 p.m.",
      "commitName": "101220bad1ac3b4082a08aff4e9c8254e71febaf",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-07-18, 10:16 p.m.",
      "commitNameOld": "4b92bf2af121075eae7ee55399841aff91984294",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 3.59,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tObject body \u003d result.getReturnValue().orElse(null);\n\t\tMethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n\t\treturn writeBody(body, bodyTypeParameter, exchange);\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 115,
      "functionName": "handleResult",
      "diff": "@@ -1,6 +1,5 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \t\tObject body \u003d result.getReturnValue().orElse(null);\n-\t\tResolvableType bodyType \u003d result.getReturnType();\n \t\tMethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n-\t\treturn writeBody(exchange, body, bodyType, bodyTypeParameter);\n+\t\treturn writeBody(body, bodyTypeParameter, exchange);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c7658144284f2f47124c6ac8131f53320091551": {
      "type": "Ybodychange",
      "commitMessage": "Provide rich type information to ConversionService\n\nWhen using the ConversionService to check and bridge to and from\nreactive types we now generallly provide the full type information\navailable from method signatures. However that full type information\nis not always necessary such as when we perform additional checks on\nthe generics of the reactive type (e.g. Mono\u003cResponseEntity\u003e).\n\nThis allows us to switch to use DefaultFormattingConversionService\ninstead of GenericConversionService while also ensuring that the\nCollectionToObjectConverter doesn\u0027t think it can convert List\u003c?\u003e to\nany reactive type.\n\nThe ObjectToObjectConverter can also interfere because it is smart\nenough to find the \"from(Publisher\u003c?\u003e)\" method on Flux and Mono.\nTo make up for that on the response side we now check if a type\nis assignable to Publisher first in which case it is a simple cast.\n\nIn turn that means we don\u0027t need a PublisherToFluxConverter which can\nbe problematic in its own right because it can convert from Mono to\nFlux which technically doesn\u0027t lose data but switches stream semantics.\n\nIssue: #124, #128\n",
      "commitDate": "2016-07-03, 9:55 p.m.",
      "commitName": "8c7658144284f2f47124c6ac8131f53320091551",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-07-03, 9:54 p.m.",
      "commitNameOld": "fb2e79604859a5b6fbc9b1c491caee8c3a9dbdcc",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tObject body \u003d result.getReturnValue().orElse(null);\n\t\tResolvableType bodyType \u003d result.getReturnType();\n\t\tMethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n\t\treturn writeBody(exchange, body, bodyType, bodyTypeParameter);\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 114,
      "functionName": "handleResult",
      "diff": "@@ -1,5 +1,6 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \t\tObject body \u003d result.getReturnValue().orElse(null);\n \t\tResolvableType bodyType \u003d result.getReturnType();\n-\t\treturn writeBody(exchange, body, bodyType);\n+\t\tMethodParameter bodyTypeParameter \u003d result.getReturnTypeSource();\n+\t\treturn writeBody(exchange, body, bodyType, bodyTypeParameter);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dffd6d674ab9415caed1b82755634f52383cd7ba": {
      "type": "Ybodychange",
      "commitMessage": "Shorten returnValueType name in HandlerResult\n",
      "commitDate": "2016-07-01, 6:00 p.m.",
      "commitName": "dffd6d674ab9415caed1b82755634f52383cd7ba",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-06-27, 9:00 a.m.",
      "commitNameOld": "699b0571267e5a27897f6d6d6304d18006ceed85",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.37,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tObject body \u003d result.getReturnValue().orElse(null);\n\t\tResolvableType bodyType \u003d result.getReturnType();\n\t\treturn writeBody(exchange, body, bodyType);\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 119,
      "functionName": "handleResult",
      "diff": "@@ -1,5 +1,5 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \t\tObject body \u003d result.getReturnValue().orElse(null);\n-\t\tResolvableType bodyType \u003d result.getReturnValueType();\n+\t\tResolvableType bodyType \u003d result.getReturnType();\n \t\treturn writeBody(exchange, body, bodyType);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9aa6f5caacac316c74e374550a387f222e7e1921": {
      "type": "Ybodychange",
      "commitMessage": "Add support for ResponseEntity result handling\n",
      "commitDate": "2016-06-21, 5:27 p.m.",
      "commitName": "9aa6f5caacac316c74e374550a387f222e7e1921",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-06-06, 5:43 p.m.",
      "commitNameOld": "0a88d5983aedfaa7165d332d415df5e0341c4128",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 14.99,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\t\tObject body \u003d result.getReturnValue().orElse(null);\n\t\tResolvableType bodyType \u003d result.getReturnValueType();\n\t\treturn writeBody(exchange, body, bodyType);\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 99,
      "functionName": "handleResult",
      "diff": "@@ -1,38 +1,5 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n-\n-\t\tPublisher\u003c?\u003e publisher;\n-\t\tResolvableType elementType;\n-\t\tResolvableType returnType \u003d result.getReturnValueType();\n-\n-\t\tif (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n-\t\t\tif (optionalValue.isPresent()) {\n-\t\t\t\tpublisher \u003d getConversionService().convert(optionalValue.get(), Publisher.class);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tpublisher \u003d Mono.empty();\n-\t\t\t}\n-\t\t\telementType \u003d returnType.getGeneric(0);\n-\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n-\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n-\t\t\t}\n-\t\t}\n-\t\telse {\n-\t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n-\t\t\telementType \u003d returnType;\n-\t\t}\n-\n-\t\tList\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(elementType);\n-\t\tMediaType bestMediaType \u003d selectMediaType(exchange, producibleTypes);\n-\n-\t\tif (bestMediaType !\u003d null) {\n-\t\t\tfor (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n-\t\t\t\tif (converter.canWrite(elementType, bestMediaType)) {\n-\t\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n-\t\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn Mono.error(new NotAcceptableStatusException(producibleTypes));\n+\t\tObject body \u003d result.getReturnValue().orElse(null);\n+\t\tResolvableType bodyType \u003d result.getReturnValueType();\n+\t\treturn writeBody(exchange, body, bodyType);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1": {
      "type": "Ybodychange",
      "commitMessage": "Introduce base class for ResponseBodyResultHandler\n\nThe ContentNegotiatingResultHandlerSupport base class encapsulates the\nlogic for content negotiation needed for both @ResponseBody and view\nresolution result handling.\n",
      "commitDate": "2016-05-31, 4:33 p.m.",
      "commitName": "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-05-26, 5:48 p.m.",
      "commitNameOld": "793638e610fa01cfffa53e1edcab56c98b2d5751",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\n\t\tif (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n\t\t\tif (optionalValue.isPresent()) {\n\t\t\t\tpublisher \u003d getConversionService().convert(optionalValue.get(), Publisher.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Mono.empty();\n\t\t\t}\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(elementType);\n\t\tMediaType bestMediaType \u003d selectMediaType(exchange, producibleTypes);\n\n\t\tif (bestMediaType !\u003d null) {\n\t\t\tfor (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n\t\t\t\tif (converter.canWrite(elementType, bestMediaType)) {\n\t\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(producibleTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 114,
      "functionName": "handleResult",
      "diff": "@@ -1,45 +1,38 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \n-\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+\t\tif (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n \t\t\tif (optionalValue.isPresent()) {\n-\t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n+\t\t\t\tpublisher \u003d getConversionService().convert(optionalValue.get(), Publisher.class);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher \u003d Mono.empty();\n \t\t\t}\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n-\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n-\t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tif (result.getReturnValue().isPresent()) {\n-\t\t\t\tList\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n-\t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n-\t\t\t}\n-\t\t\treturn Mono.empty();\n-\t\t}\n+\t\tList\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(elementType);\n+\t\tMediaType bestMediaType \u003d selectMediaType(exchange, producibleTypes);\n \n-\t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType !\u003d null) {\n \t\t\tfor (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n \t\t\t\tif (converter.canWrite(elementType, bestMediaType)) {\n \t\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n+\t\treturn Mono.error(new NotAcceptableStatusException(producibleTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "318b15c321963ad772ae9e4762c25b205047a463": {
      "type": "Ybodychange",
      "commitMessage": "Polish\n",
      "commitDate": "2016-05-26, 1:39 p.m.",
      "commitName": "318b15c321963ad772ae9e4762c25b205047a463",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-05-26, 1:34 p.m.",
      "commitNameOld": "2263954ad7d760c145eeaf4b02c2e9a68f118ad1",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n\t\t\tif (optionalValue.isPresent()) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Mono.empty();\n\t\t\t}\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\tif (result.getReturnValue().isPresent()) {\n\t\t\t\tList\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n\t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n\t\tif (bestMediaType !\u003d null) {\n\t\t\tfor (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n\t\t\t\tif (converter.canWrite(elementType, bestMediaType)) {\n\t\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 150,
      "functionName": "handleResult",
      "diff": "@@ -1,44 +1,45 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n \t\t\tif (optionalValue.isPresent()) {\n \t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher \u003d Mono.empty();\n \t\t\t}\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (result.getReturnValue().isPresent()) {\n \t\t\t\tList\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n \t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n \t\t\t}\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType !\u003d null) {\n-\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n-\t\t\tif (converter !\u003d null) {\n-\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n-\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n+\t\t\tfor (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n+\t\t\t\tif (converter.canWrite(elementType, bestMediaType)) {\n+\t\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n+\t\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2263954ad7d760c145eeaf4b02c2e9a68f118ad1": {
      "type": "Ybodychange",
      "commitMessage": "Respect produces condition in @ResponseBody algorithm\n",
      "commitDate": "2016-05-26, 1:34 p.m.",
      "commitName": "2263954ad7d760c145eeaf4b02c2e9a68f118ad1",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-05-26, 11:05 a.m.",
      "commitNameOld": "a017e2848a792038b10eec635ab10e4809a2883b",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n\t\t\tif (optionalValue.isPresent()) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Mono.empty();\n\t\t\t}\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\tif (result.getReturnValue().isPresent()) {\n\t\t\t\tList\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n\t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n\t\tif (bestMediaType !\u003d null) {\n\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n\t\t\tif (converter !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 150,
      "functionName": "handleResult",
      "diff": "@@ -1,45 +1,44 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n \t\t\tif (optionalValue.isPresent()) {\n \t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher \u003d Mono.empty();\n \t\t\t}\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n-\t\tServerHttpRequest request \u003d exchange.getRequest();\n \t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (result.getReturnValue().isPresent()) {\n-\t\t\t\tList\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(elementType);\n+\t\t\t\tList\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(exchange, elementType);\n \t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n \t\t\t}\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType !\u003d null) {\n \t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n \t\t\tif (converter !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "37404d081e807c1f4926590a78f1d4da266fb5c3": {
      "type": "Ybodychange",
      "commitMessage": "Use ContentTypeResolver for content negotiation\n",
      "commitDate": "2016-05-26, 10:52 a.m.",
      "commitName": "37404d081e807c1f4926590a78f1d4da266fb5c3",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-05-25, 5:35 p.m.",
      "commitNameOld": "2292e46b04c65d4f3f8193b0eab249a8058e59a8",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n\t\t\tif (optionalValue.isPresent()) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Mono.empty();\n\t\t\t}\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tServerHttpRequest request \u003d exchange.getRequest();\n\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\tif (result.getReturnValue().isPresent()) {\n\t\t\t\tList\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(elementType);\n\t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n\t\tif (bestMediaType !\u003d null) {\n\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n\t\t\tif (converter !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 150,
      "functionName": "handleResult",
      "diff": "@@ -1,42 +1,45 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n \t\t\tif (optionalValue.isPresent()) {\n \t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher \u003d Mono.empty();\n \t\t\t}\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tServerHttpRequest request \u003d exchange.getRequest();\n-\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n+\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(exchange, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tList\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n-\t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n+\t\t\tif (result.getReturnValue().isPresent()) {\n+\t\t\t\tList\u003cMediaType\u003e mediaTypes \u003d getProducibleMediaTypes(elementType);\n+\t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n+\t\t\t}\n+\t\t\treturn Mono.empty();\n \t\t}\n \n \t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType !\u003d null) {\n \t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n \t\t\tif (converter !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2292e46b04c65d4f3f8193b0eab249a8058e59a8": {
      "type": "Ybodychange",
      "commitMessage": "Update empty return value ResponseBody handling\n\nWhen a null is returned from an @ResponseBody method, rather than\nreturning Mono.empty() immediately, convert it to Mono.empty() and\napply the same processing.\n\nCurrently that doesn\u0027t make a practical difference but it\u0027s more\naccurate to do it this way. Eventually it may mean the possibility\nto turn empty values into something through an extension point\nas we do with ResponseBodyAdvice in Spring MVC today.\n",
      "commitDate": "2016-05-25, 5:35 p.m.",
      "commitName": "2292e46b04c65d4f3f8193b0eab249a8058e59a8",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-05-25, 5:34 p.m.",
      "commitNameOld": "91d063899bd816cc57815ac0b2317b3ab674868e",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n\t\t\tif (optionalValue.isPresent()) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Mono.empty();\n\t\t\t}\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tServerHttpRequest request \u003d exchange.getRequest();\n\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\tList\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n\t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n\t\t}\n\n\t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n\t\tif (bestMediaType !\u003d null) {\n\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n\t\t\tif (converter !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 127,
      "functionName": "handleResult",
      "diff": "@@ -1,40 +1,42 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n-\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n-\t\tif (!value.isPresent()) {\n-\t\t\treturn Mono.empty();\n-\t\t}\n-\n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n+\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n+\t\t\tOptional\u003cObject\u003e optionalValue \u003d result.getReturnValue();\n+\t\t\tif (optionalValue.isPresent()) {\n+\t\t\t\tpublisher \u003d this.conversionService.convert(optionalValue.get(), Publisher.class);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tpublisher \u003d Mono.empty();\n+\t\t\t}\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tpublisher \u003d Mono.just(value.get());\n+\t\t\tpublisher \u003d Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tServerHttpRequest request \u003d exchange.getRequest();\n \t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tList\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n \t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n \t\t}\n \n \t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType !\u003d null) {\n \t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n \t\t\tif (converter !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "91d063899bd816cc57815ac0b2317b3ab674868e": {
      "type": "Ybodychange",
      "commitMessage": "Polish ResponseBody result handling\n",
      "commitDate": "2016-05-25, 5:34 p.m.",
      "commitName": "91d063899bd816cc57815ac0b2317b3ab674868e",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-04-20, 10:27 a.m.",
      "commitNameOld": "804f69c8b6e8156462449a310a1e0865eb329b61",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 35.3,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value.get());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tServerHttpRequest request \u003d exchange.getRequest();\n\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\tList\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n\t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n\t\t}\n\n\t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n\t\tif (bestMediaType !\u003d null) {\n\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n\t\t\tif (converter !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 127,
      "functionName": "handleResult",
      "diff": "@@ -1,44 +1,40 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value.get());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n-\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d\n-\t\t\t\tgetCompatibleMediaTypes(exchange.getRequest(), elementType);\n+\t\tServerHttpRequest request \u003d exchange.getRequest();\n+\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d getCompatibleMediaTypes(request, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Mono.error(new NotAcceptableStatusException(\n-\t\t\t\t\tgetProducibleMediaTypes(elementType)));\n+\t\t\tList\u003cMediaType\u003e supported \u003d getProducibleMediaTypes(elementType);\n+\t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n \t\t}\n \n-\t\tOptional\u003cMediaType\u003e selectedMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n-\n-\t\tif (selectedMediaType.isPresent()) {\n-\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d\n-\t\t\t\t\tresolveEncoder(elementType, selectedMediaType.get());\n+\t\tMediaType bestMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n+\t\tif (bestMediaType !\u003d null) {\n+\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d resolveEncoder(elementType, bestMediaType);\n \t\t\tif (converter !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n-\t\t\t\treturn converter.write((Publisher) publisher, elementType,\n-\t\t\t\t\t\tselectedMediaType.get(),\n-\t\t\t\t\t\t\t\tresponse);\n+\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t}\n \t\t}\n \n-\t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n+\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "804f69c8b6e8156462449a310a1e0865eb329b61": {
      "type": "Ybodychange",
      "commitMessage": "Wrapping up zero-copy support\n\nThis commit wraps up the previous commits:\n\n - It uses HttpMessageConverter in the web.reactive.server package instead of Encoder/Decoder.\n - It introduces tests for the Resource @ResponseBodies.\n",
      "commitDate": "2016-04-20, 10:27 a.m.",
      "commitName": "804f69c8b6e8156462449a310a1e0865eb329b61",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2016-04-19, 4:02 p.m.",
      "commitNameOld": "6b7360fed1741bd9f7208f993f1df0036e2137d6",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value.get());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d\n\t\t\t\tgetCompatibleMediaTypes(exchange.getRequest(), elementType);\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new NotAcceptableStatusException(\n\t\t\t\t\tgetProducibleMediaTypes(elementType)));\n\t\t}\n\n\t\tOptional\u003cMediaType\u003e selectedMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n\n\t\tif (selectedMediaType.isPresent()) {\n\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d\n\t\t\t\t\tresolveEncoder(elementType, selectedMediaType.get());\n\t\t\tif (converter !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\treturn converter.write((Publisher) publisher, elementType,\n\t\t\t\t\t\tselectedMediaType.get(),\n\t\t\t\t\t\t\t\tresponse);\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 125,
      "functionName": "handleResult",
      "diff": "@@ -1,70 +1,44 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value.get());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n-\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n-\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n-\n-\t\tif (producibleMediaTypes.isEmpty()) {\n-\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n-\t\t}\n-\n-\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n-\t\tfor (MediaType requestedType : requestedMediaTypes) {\n-\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n-\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n-\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\tList\u003cMediaType\u003e compatibleMediaTypes \u003d\n+\t\t\t\tgetCompatibleMediaTypes(exchange.getRequest(), elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Mono.error(new NotAcceptableStatusException(producibleMediaTypes));\n+\t\t\treturn Mono.error(new NotAcceptableStatusException(\n+\t\t\t\t\tgetProducibleMediaTypes(elementType)));\n \t\t}\n \n-\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n-\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n+\t\tOptional\u003cMediaType\u003e selectedMediaType \u003d selectBestMediaType(compatibleMediaTypes);\n \n-\t\tMediaType selectedMediaType \u003d null;\n-\t\tfor (MediaType mediaType : mediaTypes) {\n-\t\t\tif (mediaType.isConcrete()) {\n-\t\t\t\tselectedMediaType \u003d mediaType;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n-\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (selectedMediaType !\u003d null) {\n-\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n-\t\t\tif (encoder !\u003d null) {\n+\t\tif (selectedMediaType.isPresent()) {\n+\t\t\tHttpMessageConverter\u003c?\u003e converter \u003d\n+\t\t\t\t\tresolveEncoder(elementType, selectedMediaType.get());\n+\t\t\tif (converter !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n-\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n-\t\t\t\tDataBufferAllocator allocator \u003d response.allocator();\n-\t\t\t\treturn response.setBody(\n-\t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n-\t\t\t\t\t\t\t\tselectedMediaType));\n+\t\t\t\treturn converter.write((Publisher) publisher, elementType,\n+\t\t\t\t\t\tselectedMediaType.get(),\n+\t\t\t\t\t\t\t\tresponse);\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b7360fed1741bd9f7208f993f1df0036e2137d6": {
      "type": "Ybodychange",
      "commitMessage": "Apply new ResponseStatusException hierarchy\n\nThis commit replaces use of the existing ServletException-based\nexceptions with the new ones from ~.web.server.\n",
      "commitDate": "2016-04-19, 4:02 p.m.",
      "commitName": "6b7360fed1741bd9f7208f993f1df0036e2137d6",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-04-14, 4:15 p.m.",
      "commitNameOld": "341f23e0e666ce0a00090fe1cad91caa7cb5e97c",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value.get());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new NotAcceptableStatusException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\tDataBufferAllocator allocator \u003d response.allocator();\n\t\t\t\treturn response.setBody(\n\t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n\t\t\t\t\t\t\t\tselectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 135,
      "functionName": "handleResult",
      "diff": "@@ -1,70 +1,70 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value.get());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+\t\t\treturn Mono.error(new NotAcceptableStatusException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\tDataBufferAllocator allocator \u003d response.allocator();\n \t\t\t\treturn response.setBody(\n \t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n \t\t\t\t\t\t\t\tselectedMediaType));\n \t\t\t}\n \t\t}\n \n-\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+\t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341f23e0e666ce0a00090fe1cad91caa7cb5e97c": {
      "type": "Yfilerename",
      "commitMessage": "Add \"result\" package under ~.web.reactive\n\nThe new package is parallel to the \"mvc\" package under spring-webmvc\nand a place to hold the various programming model styles.\n",
      "commitDate": "2016-04-14, 4:15 p.m.",
      "commitName": "341f23e0e666ce0a00090fe1cad91caa7cb5e97c",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-04-14, 3:17 p.m.",
      "commitNameOld": "3460e577ad86c6d660bab066e751911b16182f73",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value.get());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\tDataBufferAllocator allocator \u003d response.allocator();\n\t\t\t\treturn response.setBody(\n\t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n\t\t\t\t\t\t\t\tselectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 135,
      "functionName": "handleResult",
      "diff": "",
      "extendedDetails": {
        "oldPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
        "newPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java"
      }
    },
    "7f786ce4d7a8b51a02133d7db404d9f038d5a927": {
      "type": "Ybodychange",
      "commitMessage": "Added DataBufferAllocator property to ReactiveHttpOutputMessage, and use that to pass on to Encoder.encode().\n",
      "commitDate": "2016-03-18, 11:14 a.m.",
      "commitName": "7f786ce4d7a8b51a02133d7db404d9f038d5a927",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2016-02-28, 6:49 a.m.",
      "commitNameOld": "4197f002d87c1c02455cc640e20f89b28b10d271",
      "commitAuthorOld": "Stephane Maldini",
      "daysBetweenCommits": 19.14,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value.get());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\tDataBufferAllocator allocator \u003d response.allocator();\n\t\t\t\treturn response.setBody(\n\t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n\t\t\t\t\t\t\t\tselectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 135,
      "functionName": "handleResult",
      "diff": "@@ -1,67 +1,70 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value.get());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n-\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n+\t\t\t\tDataBufferAllocator allocator \u003d response.allocator();\n+\t\t\t\treturn response.setBody(\n+\t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n+\t\t\t\t\t\t\t\tselectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4197f002d87c1c02455cc640e20f89b28b10d271": {
      "type": "Ybodychange",
      "commitMessage": "Arrange WriteWithOperator to save some allocation cost with the same technique used by RSC and Reactor\n",
      "commitDate": "2016-02-28, 6:49 a.m.",
      "commitName": "4197f002d87c1c02455cc640e20f89b28b10d271",
      "commitAuthor": "Stephane Maldini",
      "commitDateOld": "2016-02-08, 6:13 p.m.",
      "commitNameOld": "29db80c3e8f1d61ef97129ff9e139b24d9de93ba",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 19.52,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value.get());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 134,
      "functionName": "handleResult",
      "diff": "@@ -1,67 +1,67 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n-\t\t\t\treturn (Mono\u003cVoid\u003e)Mono.from(publisher);\n+\t\t\t\treturn Mono.from((Publisher\u003cVoid\u003e)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value.get());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e92174c772c0d787be7721ae00c7189f16b05fb5": {
      "type": "Ybodychange",
      "commitMessage": "Update HandlerResult\n\nRename result to returnValue and resultType to returnValueType to\nreflect what they represent.\n\nThe returnValue getter is also wrapped as Optional since the value\nreturned from a handler may be null (e.g. void method, null value).\n",
      "commitDate": "2016-02-07, 9:50 p.m.",
      "commitName": "e92174c772c0d787be7721ae00c7189f16b05fb5",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-01-27, 5:05 p.m.",
      "commitNameOld": "381855aaf315adfd44e22797bbf14f07d08155d9",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 11.2,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n\t\tif (!value.isPresent()) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getReturnValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn (Mono\u003cVoid\u003e)Mono.from(publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value.get());\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 134,
      "functionName": "handleResult",
      "diff": "@@ -1,67 +1,67 @@\n \tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n-\t\tObject value \u003d result.getResult();\n-\t\tif (value \u003d\u003d null) {\n+\t\tOptional\u003cObject\u003e value \u003d result.getReturnValue();\n+\t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n-\t\tResolvableType returnType \u003d result.getResultType();\n+\t\tResolvableType returnType \u003d result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n+\t\t\tpublisher \u003d this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn (Mono\u003cVoid\u003e)Mono.from(publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tpublisher \u003d Mono.just(value);\n+\t\t\tpublisher \u003d Mono.just(value.get());\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "381855aaf315adfd44e22797bbf14f07d08155d9": {
      "type": "Yparameterchange",
      "commitMessage": "Refine names in web.server and polish Javadoc\n\nWebServerExchange -\u003e ServerWebExchange\n\nFollows the same convention as in the http package also better allowing\nthe possibility for a client equivalent in the future.\n\nWebToHttpHandlerBuilder -\u003e WebHttpHandlerBuilder\nWebToHttpHandlerAdapter -\u003e WebHttpHandlerAdapter\n\nMore consistent with Spring conventions.\n",
      "commitDate": "2016-01-27, 5:05 p.m.",
      "commitName": "381855aaf315adfd44e22797bbf14f07d08155d9",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2016-01-19, 3:18 p.m.",
      "commitNameOld": "198e31641247061d0e02f8103b6d5b4583b1c619",
      "commitAuthorOld": "Stephane Maldini",
      "daysBetweenCommits": 8.07,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n\n\t\tObject value \u003d result.getResult();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getResultType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn (Mono\u003cVoid\u003e)Mono.from(publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 133,
      "functionName": "handleResult",
      "diff": "@@ -1,67 +1,67 @@\n-\tpublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n+\tpublic Mono\u003cVoid\u003e handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tObject value \u003d result.getResult();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn (Mono\u003cVoid\u003e)Mono.from(publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value);\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[exchange-WebServerExchange, result-HandlerResult]",
        "newValue": "[exchange-ServerWebExchange, result-HandlerResult]"
      }
    },
    "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a": {
      "type": "Ybodychange",
      "commitMessage": "Polish @RestController support\n",
      "commitDate": "2016-01-14, 5:06 a.m.",
      "commitName": "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2016-01-13, 6:12 p.m.",
      "commitNameOld": "da90f03f4c7e192a23aaf64680cccf1c51c2b0f5",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n\n\t\tObject value \u003d result.getResult();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getResultType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n\t\t\t\treturn (Mono\u003cVoid\u003e)Mono.from(publisher);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 135,
      "functionName": "handleResult",
      "diff": "@@ -1,64 +1,67 @@\n \tpublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n \n \t\tObject value \u003d result.getResult();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n+\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n+\t\t\t\treturn (Mono\u003cVoid\u003e)Mono.from(publisher);\n+\t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value);\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f614fa0fd74ce29c5822e70f4815cc40745a2be": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
      "commitDate": "2016-01-08, 12:30 p.m.",
      "commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
      "commitAuthor": "Rossen Stoyanchev",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
          "commitDate": "2016-01-08, 12:30 p.m.",
          "commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016-01-07, 5:14 a.m.",
          "commitNameOld": "8ef7e2ff77f913773e30b1463d4657368db700e5",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 1.3,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n\n\t\tObject value \u003d result.getResult();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getResultType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 131,
          "functionName": "handleResult",
          "diff": "@@ -1,64 +1,64 @@\n-\tpublic Mono\u003cVoid\u003e handleResult(ServerHttpRequest request,\n-\t\t\tServerHttpResponse response, HandlerResult result) {\n+\tpublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n \n \t\tObject value \u003d result.getResult();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value);\n \t\t\telementType \u003d returnType;\n \t\t}\n \n-\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n+\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]",
            "newValue": "[exchange-WebServerExchange, result-HandlerResult]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
          "commitDate": "2016-01-08, 12:30 p.m.",
          "commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016-01-07, 5:14 a.m.",
          "commitNameOld": "8ef7e2ff77f913773e30b1463d4657368db700e5",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 1.3,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n\n\t\tObject value \u003d result.getResult();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getResultType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 131,
          "functionName": "handleResult",
          "diff": "@@ -1,64 +1,64 @@\n-\tpublic Mono\u003cVoid\u003e handleResult(ServerHttpRequest request,\n-\t\t\tServerHttpResponse response, HandlerResult result) {\n+\tpublic Mono\u003cVoid\u003e handleResult(WebServerExchange exchange, HandlerResult result) {\n \n \t\tObject value \u003d result.getResult();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Mono.just(value);\n \t\t\telementType \u003d returnType;\n \t\t}\n \n-\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(exchange.getRequest());\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n+\t\t\t\tServerHttpResponse response \u003d exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "8ef7e2ff77f913773e30b1463d4657368db700e5": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux\u003cT\u003e for multiple values Publisher (issue #48)\n- Mono\u003cT\u003e for single value Publisher (issue #50)\n- Mono\u003cVoid\u003e for Publisher with no value (issue #49)\n",
      "commitDate": "2016-01-07, 5:14 a.m.",
      "commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
      "commitAuthor": "Sebastien Deleuze",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux\u003cT\u003e for multiple values Publisher (issue #48)\n- Mono\u003cT\u003e for single value Publisher (issue #50)\n- Mono\u003cVoid\u003e for Publisher with no value (issue #49)\n",
          "commitDate": "2016-01-07, 5:14 a.m.",
          "commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
          "commitAuthor": "Sebastien Deleuze",
          "commitDateOld": "2015-12-29, 11:13 p.m.",
          "commitNameOld": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 8.25,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getResult();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getResultType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 130,
          "functionName": "handleResult",
          "diff": "@@ -1,64 +1,64 @@\n-\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request,\n+\tpublic Mono\u003cVoid\u003e handleResult(ServerHttpRequest request,\n \t\t\tServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getResult();\n \t\tif (value \u003d\u003d null) {\n-\t\t\treturn Publishers.empty();\n+\t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t}\n \t\telse {\n-\t\t\tpublisher \u003d Publishers.just(value);\n+\t\t\tpublisher \u003d Mono.just(value);\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n-\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Publisher\u003cVoid\u003e",
            "newValue": "Mono\u003cVoid\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux\u003cT\u003e for multiple values Publisher (issue #48)\n- Mono\u003cT\u003e for single value Publisher (issue #50)\n- Mono\u003cVoid\u003e for Publisher with no value (issue #49)\n",
          "commitDate": "2016-01-07, 5:14 a.m.",
          "commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
          "commitAuthor": "Sebastien Deleuze",
          "commitDateOld": "2015-12-29, 11:13 p.m.",
          "commitNameOld": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 8.25,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic Mono\u003cVoid\u003e handleResult(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getResult();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Mono.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getResultType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Mono.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
          "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 130,
          "functionName": "handleResult",
          "diff": "@@ -1,64 +1,64 @@\n-\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request,\n+\tpublic Mono\u003cVoid\u003e handleResult(ServerHttpRequest request,\n \t\t\tServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getResult();\n \t\tif (value \u003d\u003d null) {\n-\t\t\treturn Publishers.empty();\n+\t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t}\n \t\telse {\n-\t\t\tpublisher \u003d Publishers.just(value);\n+\t\t\tpublisher \u003d Mono.just(value);\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n-\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "9789db23d2973d8f0156d2b6c6027d9fb67ab844": {
      "type": "Ybodychange",
      "commitMessage": "Rename HandlerResult fields from value to result\n",
      "commitDate": "2015-12-29, 11:13 p.m.",
      "commitName": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-12-10, 4:35 p.m.",
      "commitNameOld": "a0018d13e19f7fe7ef7a98979476d9cd2851a10c",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 19.28,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getResult();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getResultType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Publishers.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 130,
      "functionName": "handleResult",
      "diff": "@@ -1,64 +1,64 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request,\n \t\t\tServerHttpResponse response, HandlerResult result) {\n \n-\t\tObject value \u003d result.getValue();\n+\t\tObject value \u003d result.getResult();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tPublisher\u003c?\u003e publisher;\n \t\tResolvableType elementType;\n-\t\tResolvableType returnType \u003d result.getValueType();\n+\t\tResolvableType returnType \u003d result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d returnType.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\tpublisher \u003d Publishers.just(value);\n \t\t\telementType \u003d returnType;\n \t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a0018d13e19f7fe7ef7a98979476d9cd2851a10c": {
      "type": "Ybodychange",
      "commitMessage": "Add DispatcherHandlerErrorTests\n\nThe tests demonstrate failures at various phases of request processing\nand the resulting error signals.\n",
      "commitDate": "2015-12-10, 4:35 p.m.",
      "commitName": "a0018d13e19f7fe7ef7a98979476d9cd2851a10c",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-12-02, 5:46 p.m.",
      "commitNameOld": "da98becf72fbeef836dba366431be2a652e5e001",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 7.95,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tPublisher\u003c?\u003e publisher;\n\t\tResolvableType elementType;\n\t\tResolvableType returnType \u003d result.getValueType();\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\tpublisher \u003d Publishers.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 130,
      "functionName": "handleResult",
      "diff": "@@ -1,64 +1,64 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request,\n \t\t\tServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n+\t\tPublisher\u003c?\u003e publisher;\n+\t\tResolvableType elementType;\n \t\tResolvableType returnType \u003d result.getValueType();\n+\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n+\t\t\telementType \u003d returnType.getGeneric(0);\n+\t\t}\n+\t\telse {\n+\t\t\tpublisher \u003d Publishers.just(value);\n+\t\t\telementType \u003d returnType;\n+\t\t}\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n-\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n+\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n-\t\t\tPublisher\u003c?\u003e publisher;\n-\t\t\tResolvableType elementType;\n-\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n-\t\t\t\telementType \u003d returnType.getGeneric(0);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tpublisher \u003d Publishers.just(value);\n-\t\t\t\telementType \u003d returnType;\n-\t\t\t}\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da98becf72fbeef836dba366431be2a652e5e001": {
      "type": "Yparameterchange",
      "commitMessage": "Move http.server to http.server.reactive\n",
      "commitDate": "2015-12-02, 5:46 p.m.",
      "commitName": "da98becf72fbeef836dba366431be2a652e5e001",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-11-22, 3:02 p.m.",
      "commitNameOld": "4a3c0bc3b615df84afd7deb18bc102f5d363076e",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 10.11,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request,\n\t\t\tServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType returnType \u003d result.getValueType();\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tPublisher\u003c?\u003e publisher;\n\t\t\tResolvableType elementType;\n\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Publishers.just(value);\n\t\t\t\telementType \u003d returnType;\n\t\t\t}\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 130,
      "functionName": "handleResult",
      "diff": "@@ -1,64 +1,64 @@\n-\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n-\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n+\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request,\n+\t\t\tServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType returnType \u003d result.getValueType();\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tPublisher\u003c?\u003e publisher;\n \t\t\tResolvableType elementType;\n \t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher \u003d Publishers.just(value);\n \t\t\t\telementType \u003d returnType;\n \t\t\t}\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[request-ReactiveServerHttpRequest, response-ReactiveServerHttpResponse, result-HandlerResult]",
        "newValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]"
      }
    },
    "911d3769224d009fb9fe08c6cb5489686bbc5713": {
      "type": "Ybodychange",
      "commitMessage": "Improve MimeType -\u003e MediaType handling\n\nThis change adds an Encoder-to-MediaType lookup in\nResponseBodyResultHandler to avoid MimeType to MediaType creation at\nruntime.\n",
      "commitDate": "2015-11-22, 2:41 p.m.",
      "commitName": "911d3769224d009fb9fe08c6cb5489686bbc5713",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-11-13, 5:49 p.m.",
      "commitNameOld": "81867fa4237643ca3eae24a8f085bc4b5f9443b3",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 8.87,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType returnType \u003d result.getValueType();\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tPublisher\u003c?\u003e publisher;\n\t\t\tResolvableType elementType;\n\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Publishers.just(value);\n\t\t\t\telementType \u003d returnType;\n\t\t\t}\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 130,
      "functionName": "handleResult",
      "diff": "@@ -1,65 +1,64 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType returnType \u003d result.getValueType();\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n-\t\t\tPublishers.error(new IllegalArgumentException(\n-\t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n+\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tPublisher\u003c?\u003e publisher;\n \t\t\tResolvableType elementType;\n \t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher \u003d Publishers.just(value);\n \t\t\t\telementType \u003d returnType;\n \t\t\t}\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n-\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n+\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "81867fa4237643ca3eae24a8f085bc4b5f9443b3": {
      "type": "Yfilerename",
      "commitMessage": "Refactor package structure for web\n\nThe web related code is now under org.springframework.web.reactive.\nThis is parallel to org.springframework.web (the top-level package of\nspring-webmvc).\n",
      "commitDate": "2015-11-13, 5:49 p.m.",
      "commitName": "81867fa4237643ca3eae24a8f085bc4b5f9443b3",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-11-13, 5:23 p.m.",
      "commitNameOld": "54ce20a5e04275835b40f2cd1453db778264191e",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType returnType \u003d result.getValueType();\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tPublishers.error(new IllegalArgumentException(\n\t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tPublisher\u003c?\u003e publisher;\n\t\t\tResolvableType elementType;\n\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Publishers.just(value);\n\t\t\t\telementType \u003d returnType;\n\t\t\t}\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 109,
      "functionName": "handleResult",
      "diff": "",
      "extendedDetails": {
        "oldPath": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
        "newPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java"
      }
    },
    "54ce20a5e04275835b40f2cd1453db778264191e": {
      "type": "Ybodychange",
      "commitMessage": "Rename field in HandlerResult\n",
      "commitDate": "2015-11-13, 5:23 p.m.",
      "commitName": "54ce20a5e04275835b40f2cd1453db778264191e",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-11-13, 5:09 p.m.",
      "commitNameOld": "c6713c23e327961d021706e5b1e4d5ebe8e2f458",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType returnType \u003d result.getValueType();\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tPublishers.error(new IllegalArgumentException(\n\t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tPublisher\u003c?\u003e publisher;\n\t\t\tResolvableType elementType;\n\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Publishers.just(value);\n\t\t\t\telementType \u003d returnType;\n\t\t\t}\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 109,
      "functionName": "handleResult",
      "diff": "@@ -1,65 +1,65 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n-\t\tResolvableType returnType \u003d result.getType();\n+\t\tResolvableType returnType \u003d result.getValueType();\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tPublishers.error(new IllegalArgumentException(\n \t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tPublisher\u003c?\u003e publisher;\n \t\t\tResolvableType elementType;\n \t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher \u003d Publishers.just(value);\n \t\t\t\telementType \u003d returnType;\n \t\t\t}\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6713c23e327961d021706e5b1e4d5ebe8e2f458": {
      "type": "Ybodychange",
      "commitMessage": "Add a ResolvableType field to HandlerResult\n\nThis change allows to be able to check generic type on the return value\nat HandlerAdapter and ResultHandler level. For example, it allows to do\na Publisher\u003cVoid\u003e check in SimpleHandlerResultHandler.\n",
      "commitDate": "2015-11-13, 5:09 p.m.",
      "commitName": "c6713c23e327961d021706e5b1e4d5ebe8e2f458",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015-11-13, 4:47 p.m.",
      "commitNameOld": "5d4201d50079fc36fee21617ece1bfbbcf194120",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType returnType \u003d result.getType();\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tPublishers.error(new IllegalArgumentException(\n\t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tPublisher\u003c?\u003e publisher;\n\t\t\tResolvableType elementType;\n\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Publishers.just(value);\n\t\t\t\telementType \u003d returnType;\n\t\t\t}\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 109,
      "functionName": "handleResult",
      "diff": "@@ -1,66 +1,65 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n-\t\tHandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n-\t\tResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n+\t\tResolvableType returnType \u003d result.getType();\n \n \t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n \t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tPublishers.error(new IllegalArgumentException(\n \t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n \t\t}\n \n \t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType \u003d null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType \u003d mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType !\u003d null) {\n \t\t\tPublisher\u003c?\u003e publisher;\n \t\t\tResolvableType elementType;\n \t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n \t\t\t\telementType \u003d returnType.getGeneric(0);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher \u003d Publishers.just(value);\n \t\t\t\telementType \u003d returnType;\n \t\t\t}\n \t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder !\u003d null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d4201d50079fc36fee21617ece1bfbbcf194120": {
      "type": "Ybodychange",
      "commitMessage": "Fix \"Content-Type\" and \"Accept\" header processing\n\n\"Content-Type\" is just a single MediaType.\n\nFor the response, the MediaType must be fully selected before\nselecting and encoder.\n\nThe ResponseBodyResultHandler now includes actual content negotiation\nwith a potential 406 response.\n",
      "commitDate": "2015-11-13, 4:47 p.m.",
      "commitName": "5d4201d50079fc36fee21617ece1bfbbcf194120",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-11-13, 3:55 p.m.",
      "commitNameOld": "2de127ad4ad8dcb81521039749308de58ac81420",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tHandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n\t\tResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n\n\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n\n\t\tif (producibleMediaTypes.isEmpty()) {\n\t\t\tPublishers.error(new IllegalArgumentException(\n\t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n\t\t}\n\n\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n\t\tfor (MediaType requestedType : requestedMediaTypes) {\n\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (compatibleMediaTypes.isEmpty()) {\n\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n\t\t}\n\n\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n\n\t\tMediaType selectedMediaType \u003d null;\n\t\tfor (MediaType mediaType : mediaTypes) {\n\t\t\tif (mediaType.isConcrete()) {\n\t\t\t\tselectedMediaType \u003d mediaType;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedMediaType !\u003d null) {\n\t\t\tPublisher\u003c?\u003e publisher;\n\t\t\tResolvableType elementType;\n\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpublisher \u003d Publishers.just(value);\n\t\t\t\telementType \u003d returnType;\n\t\t\t}\n\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n\t\t\tif (encoder !\u003d null) {\n\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n\t\t\t}\n\t\t}\n\n\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 109,
      "functionName": "handleResult",
      "diff": "@@ -1,45 +1,66 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tHandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n \t\tResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n \n-\t\tPublisher\u003c?\u003e elementStream;\n-\t\tResolvableType elementType;\n-\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\telementStream \u003d this.conversionService.convert(value, Publisher.class);\n-\t\t\telementType \u003d returnType.getGeneric(0);\n-\t\t}\n-\t\telse {\n-\t\t\telementStream \u003d Publishers.just(value);\n-\t\t\telementType \u003d returnType;\n+\t\tList\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+\t\tList\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType);\n+\n+\t\tif (producibleMediaTypes.isEmpty()) {\n+\t\t\tPublishers.error(new IllegalArgumentException(\n+\t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n \t\t}\n \n-\t\tMediaType mediaType \u003d resolveMediaType(request);\n-\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, mediaType);\n-\t\tif (encoder \u003d\u003d null) {\n-\t\t\treturn Publishers.error(new IllegalStateException(\n-\t\t\t\t\t\"Return value type \u0027\" + returnType +\n-\t\t\t\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n+\t\tSet\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n+\t\tfor (MediaType requestedType : requestedMediaTypes) {\n+\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n+\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n+\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (compatibleMediaTypes.isEmpty()) {\n+\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n-\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode((Publisher) elementStream, returnType, mediaType);\n-\t\tif (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n-\t\t\tList\u003cMimeType\u003e mimeTypes \u003d encoder.getSupportedMimeTypes();\n-\t\t\tif (!mimeTypes.isEmpty()) {\n-\t\t\t\tMimeType mimeType \u003d mimeTypes.get(0);\n-\t\t\t\tmediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+\t\tList\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n+\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n+\n+\t\tMediaType selectedMediaType \u003d null;\n+\t\tfor (MediaType mediaType : mediaTypes) {\n+\t\t\tif (mediaType.isConcrete()) {\n+\t\t\t\tselectedMediaType \u003d mediaType;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+\t\t\t\tselectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n-\t\tif (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n-\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\tif (selectedMediaType !\u003d null) {\n+\t\t\tPublisher\u003c?\u003e publisher;\n+\t\t\tResolvableType elementType;\n+\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+\t\t\t\tpublisher \u003d this.conversionService.convert(value, Publisher.class);\n+\t\t\t\telementType \u003d returnType.getGeneric(0);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tpublisher \u003d Publishers.just(value);\n+\t\t\t\telementType \u003d returnType;\n+\t\t\t}\n+\t\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, selectedMediaType);\n+\t\t\tif (encoder !\u003d null) {\n+\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n+\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n+\t\t\t}\n \t\t}\n \n-\t\treturn response.setBody(outputStream);\n+\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2de127ad4ad8dcb81521039749308de58ac81420": {
      "type": "Ybodychange",
      "commitMessage": "Polish\n",
      "commitDate": "2015-11-13, 3:55 p.m.",
      "commitName": "2de127ad4ad8dcb81521039749308de58ac81420",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-11-13, 3:01 p.m.",
      "commitNameOld": "bdc5b38cb12d26605a968845338bef5bad22816d",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tHandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n\t\tResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n\n\t\tPublisher\u003c?\u003e elementStream;\n\t\tResolvableType elementType;\n\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n\t\t\telementStream \u003d this.conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d returnType.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\telementStream \u003d Publishers.just(value);\n\t\t\telementType \u003d returnType;\n\t\t}\n\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, mediaType);\n\t\tif (encoder \u003d\u003d null) {\n\t\t\treturn Publishers.error(new IllegalStateException(\n\t\t\t\t\t\"Return value type \u0027\" + returnType +\n\t\t\t\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n\t\t}\n\n\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode((Publisher) elementStream, returnType, mediaType);\n\t\tif (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n\t\t\tList\u003cMimeType\u003e mimeTypes \u003d encoder.getSupportedMimeTypes();\n\t\t\tif (!mimeTypes.isEmpty()) {\n\t\t\t\tMimeType mimeType \u003d mimeTypes.get(0);\n\t\t\t\tmediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n\t\t\t}\n\t\t}\n\n\t\tif (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t}\n\n\t\treturn response.setBody(outputStream);\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 88,
      "functionName": "handleResult",
      "diff": "@@ -1,44 +1,45 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n-\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n-\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n-\n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n-\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n-\t\tMediaType mediaType \u003d resolveMediaType(request);\n+\t\tHandlerMethod hm \u003d (HandlerMethod) result.getHandler();\n+\t\tResolvableType returnType \u003d ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n+\n \t\tPublisher\u003c?\u003e elementStream;\n \t\tResolvableType elementType;\n-\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n-\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n-\t\t\telementType \u003d type.getGeneric(0);\n+\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+\t\t\telementStream \u003d this.conversionService.convert(value, Publisher.class);\n+\t\t\telementType \u003d returnType.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream \u003d Publishers.just(value);\n-\t\t\telementType \u003d type;\n+\t\t\telementType \u003d returnType;\n \t\t}\n \n-\t\tEncoder\u003c?\u003e serializer \u003d resolveSerializer(elementType, mediaType);\n-\n-\t\tif (serializer !\u003d null) {\n-\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode((Publisher)elementStream, type, mediaType);\n-\t\t\tif (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n-\t\t\t\tList\u003cMimeType\u003e mimeTypes \u003d serializer.getSupportedMimeTypes();\n-\t\t\t\tif (!mimeTypes.isEmpty()) {\n-\t\t\t\t\tMimeType mimeType \u003d mimeTypes.get(0);\n-\t\t\t\t\tmediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n-\t\t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\t}\n-\t\t\treturn response.setBody(outputStream);\n+\t\tMediaType mediaType \u003d resolveMediaType(request);\n+\t\tEncoder\u003c?\u003e encoder \u003d resolveEncoder(elementType, mediaType);\n+\t\tif (encoder \u003d\u003d null) {\n+\t\t\treturn Publishers.error(new IllegalStateException(\n+\t\t\t\t\t\"Return value type \u0027\" + returnType +\n+\t\t\t\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n \t\t}\n-\t\tString returnTypeName \u003d returnType.getParameterType().getName();\n-\t\treturn Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName +\n-\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n+\n+\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode((Publisher) elementStream, returnType, mediaType);\n+\t\tif (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n+\t\t\tList\u003cMimeType\u003e mimeTypes \u003d encoder.getSupportedMimeTypes();\n+\t\t\tif (!mimeTypes.isEmpty()) {\n+\t\t\t\tMimeType mimeType \u003d mimeTypes.get(0);\n+\t\t\t\tmediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n+\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\t}\n+\n+\t\treturn response.setBody(outputStream);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bdc5b38cb12d26605a968845338bef5bad22816d": {
      "type": "Ybodychange",
      "commitMessage": "Refactor codecs\n\nThis commit introduces the following changes:\n - MessageToByteEncoder/Decoder renamed to Encoder/Decoder\n - JsonObjectEncoder/Decoder are now used directly in\n   JacksonJsonEncoder/Decoder\n - Codec uses MimeType instead of MediaType since they\n   are not specific to HTTP\n - Default MimeType are now managed thanks to\n   Encoder/Decoder#getSupportedMimeTypes()\n - AbstractEncoder/Decoder takes care of generic MimeType related behavior\n",
      "commitDate": "2015-11-13, 3:01 p.m.",
      "commitName": "bdc5b38cb12d26605a968845338bef5bad22816d",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015-10-30, 5:58 p.m.",
      "commitNameOld": "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 13.92,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tPublisher\u003c?\u003e elementStream;\n\t\tResolvableType elementType;\n\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d type.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\telementStream \u003d Publishers.just(value);\n\t\t\telementType \u003d type;\n\t\t}\n\n\t\tEncoder\u003c?\u003e serializer \u003d resolveSerializer(elementType, mediaType);\n\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode((Publisher)elementStream, type, mediaType);\n\t\t\tif (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n\t\t\t\tList\u003cMimeType\u003e mimeTypes \u003d serializer.getSupportedMimeTypes();\n\t\t\t\tif (!mimeTypes.isEmpty()) {\n\t\t\t\t\tMimeType mimeType \u003d mimeTypes.get(0);\n\t\t\t\t\tmediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n\t\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\t}\n\t\t\treturn response.setBody(outputStream);\n\t\t}\n\t\tString returnTypeName \u003d returnType.getParameterType().getName();\n\t\treturn Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName +\n\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 88,
      "functionName": "handleResult",
      "diff": "@@ -1,43 +1,44 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType \u003d resolveMediaType(request);\n-\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n-\t\thints.add(UTF_8);\n-\t\tPublisher\u003cObject\u003e elementStream;\n+\t\tPublisher\u003c?\u003e elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream \u003d Publishers.just(value);\n \t\t\telementType \u003d type;\n \t\t}\n \n-\t\tMessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(\n-\t\t\t\telementType, mediaType, hints.toArray());\n+\t\tEncoder\u003c?\u003e serializer \u003d resolveSerializer(elementType, mediaType);\n \n-\t\tif (encoder !\u003d null) {\n-\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n-\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(\n-\t\t\t\t\telementType, mediaType, hints.toArray());\n-\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n-\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n+\t\tif (serializer !\u003d null) {\n+\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode((Publisher)elementStream, type, mediaType);\n+\t\t\tif (mediaType \u003d\u003d null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n+\t\t\t\tList\u003cMimeType\u003e mimeTypes \u003d serializer.getSupportedMimeTypes();\n+\t\t\t\tif (!mimeTypes.isEmpty()) {\n+\t\t\t\t\tMimeType mimeType \u003d mimeTypes.get(0);\n+\t\t\t\t\tmediaType \u003d new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\t\tif (mediaType !\u003d null \u0026\u0026 !mediaType.equals(MediaType.ALL)) {\n+\t\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\t\t}\n \t\t\treturn response.setBody(outputStream);\n \t\t}\n \t\tString returnTypeName \u003d returnType.getParameterType().getName();\n \t\treturn Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName +\n \t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b": {
      "type": "Ybodychange",
      "commitMessage": "Replace DefaultConversionService in spring-reactive\n",
      "commitDate": "2015-10-30, 5:58 p.m.",
      "commitName": "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-10-30, 5:22 p.m.",
      "commitNameOld": "c0dff3d2bb2277429f4e387d18deb75b0797a375",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tPublisher\u003cObject\u003e elementStream;\n\t\tResolvableType elementType;\n\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d type.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\telementStream \u003d Publishers.just(value);\n\t\t\telementType \u003d type;\n\t\t}\n\n\t\tMessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(\n\t\t\t\telementType, mediaType, hints.toArray());\n\n\t\tif (encoder !\u003d null) {\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(\n\t\t\t\t\telementType, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.setBody(outputStream);\n\t\t}\n\t\tString returnTypeName \u003d returnType.getParameterType().getName();\n\t\treturn Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName +\n\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 100,
      "functionName": "handleResult",
      "diff": "@@ -1,43 +1,43 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tPublisher\u003cObject\u003e elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream \u003d Publishers.just(value);\n \t\t\telementType \u003d type;\n \t\t}\n \n \t\tMessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(\n-\t\t\t\trequest, elementType, mediaType, hints.toArray());\n+\t\t\t\telementType, mediaType, hints.toArray());\n \n \t\tif (encoder !\u003d null) {\n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n-\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request,\n+\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(\n \t\t\t\t\telementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.setBody(outputStream);\n \t\t}\n \t\tString returnTypeName \u003d returnType.getParameterType().getName();\n \t\treturn Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName +\n \t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c0dff3d2bb2277429f4e387d18deb75b0797a375": {
      "type": "Ybodychange",
      "commitMessage": "Comply with Spring Framework code style\n\nhttps://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Code-Style\n",
      "commitDate": "2015-10-30, 5:22 p.m.",
      "commitName": "c0dff3d2bb2277429f4e387d18deb75b0797a375",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015-10-30, 6:03 a.m.",
      "commitNameOld": "01ae961820768bfe9c1f948a74a37104dcdef992",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 0.47,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tPublisher\u003cObject\u003e elementStream;\n\t\tResolvableType elementType;\n\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d type.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\telementStream \u003d Publishers.just(value);\n\t\t\telementType \u003d type;\n\t\t}\n\n\t\tMessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(\n\t\t\t\trequest, elementType, mediaType, hints.toArray());\n\n\t\tif (encoder !\u003d null) {\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request,\n\t\t\t\t\telementType, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.setBody(outputStream);\n\t\t}\n\t\tString returnTypeName \u003d returnType.getParameterType().getName();\n\t\treturn Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName +\n\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 107,
      "functionName": "handleResult",
      "diff": "@@ -1,41 +1,43 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n-\t\t\tReactiveServerHttpResponse response,\n-\t\t\tHandlerResult result) {\n+\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tPublisher\u003cObject\u003e elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream \u003d Publishers.just(value);\n \t\t\telementType \u003d type;\n \t\t}\n \n-\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n-\t\tif (serializer !\u003d null) {\n-\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n-\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n+\t\tMessageToByteEncoder\u003cObject\u003e encoder \u003d (MessageToByteEncoder\u003cObject\u003e) resolveEncoder(\n+\t\t\t\trequest, elementType, mediaType, hints.toArray());\n+\n+\t\tif (encoder !\u003d null) {\n+\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d encoder.encode(elementStream, type, mediaType, hints.toArray());\n+\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request,\n+\t\t\t\t\telementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.setBody(outputStream);\n \t\t}\n-\t\treturn Publishers.error(new IllegalStateException(\n-\t\t\t\t\"Return value type \u0027\" + returnType.getParameterType().getName() +\n-\t\t\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n+\t\tString returnTypeName \u003d returnType.getParameterType().getName();\n+\t\treturn Publishers.error(new IllegalStateException(\"Return value type \u0027\" + returnTypeName +\n+\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45a88974bc9545eff6c7de07d054a2836dcbdfca": {
      "type": "Ybodychange",
      "commitMessage": "Changed addBody() to setBody()\n",
      "commitDate": "2015-10-29, 11:28 a.m.",
      "commitName": "45a88974bc9545eff6c7de07d054a2836dcbdfca",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2015-10-29, 10:45 a.m.",
      "commitNameOld": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tPublisher\u003cObject\u003e elementStream;\n\t\tResolvableType elementType;\n\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d type.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\telementStream \u003d Publishers.just(value);\n\t\t\telementType \u003d type;\n\t\t}\n\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.setBody(outputStream);\n\t\t}\n\t\treturn Publishers.error(new IllegalStateException(\n\t\t\t\t\"Return value type \u0027\" + returnType.getParameterType().getName() +\n\t\t\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 108,
      "functionName": "handleResult",
      "diff": "@@ -1,40 +1,41 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tPublisher\u003cObject\u003e elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream \u003d Publishers.just(value);\n \t\t\telementType \u003d type;\n \t\t}\n \n \t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.addBody(outputStream);\n+\t\t\treturn response.setBody(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n-\t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n+\t\t\t\t\"Return value type \u0027\" + returnType.getParameterType().getName() +\n+\t\t\t\t\t\t\"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
      "commitDate": "2015-10-29, 10:45 a.m.",
      "commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
      "commitAuthor": "Arjen Poutsma",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
          "commitDate": "2015-10-29, 10:45 a.m.",
          "commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2015-10-29, 5:50 a.m.",
          "commitNameOld": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 0.21,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tPublisher\u003cObject\u003e elementStream;\n\t\tResolvableType elementType;\n\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d type.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\telementStream \u003d Publishers.just(value);\n\t\t\telementType \u003d type;\n\t\t}\n\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.addBody(outputStream);\n\t\t}\n\t\treturn Publishers.error(new IllegalStateException(\n\t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n\t}",
          "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 108,
          "functionName": "handleResult",
          "diff": "@@ -1,39 +1,40 @@\n-\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n+\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n+\t\t\tReactiveServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tPublisher\u003cObject\u003e elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream \u003d Publishers.just(value);\n \t\t\telementType \u003d type;\n \t\t}\n \n \t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.writeWith(outputStream);\n+\t\t\treturn response.addBody(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n \t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]",
            "newValue": "[request-ReactiveServerHttpRequest, response-ReactiveServerHttpResponse, result-HandlerResult]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
          "commitDate": "2015-10-29, 10:45 a.m.",
          "commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2015-10-29, 5:50 a.m.",
          "commitNameOld": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 0.21,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n\t\t\tReactiveServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tPublisher\u003cObject\u003e elementStream;\n\t\tResolvableType elementType;\n\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d type.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\telementStream \u003d Publishers.just(value);\n\t\t\telementType \u003d type;\n\t\t}\n\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.addBody(outputStream);\n\t\t}\n\t\treturn Publishers.error(new IllegalStateException(\n\t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n\t}",
          "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
          "functionStartLine": 108,
          "functionName": "handleResult",
          "diff": "@@ -1,39 +1,40 @@\n-\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n+\tpublic Publisher\u003cVoid\u003e handleResult(ReactiveServerHttpRequest request,\n+\t\t\tReactiveServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tPublisher\u003cObject\u003e elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n \t\t\telementType \u003d type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream \u003d Publishers.just(value);\n \t\t\telementType \u003d type;\n \t\t}\n \n \t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.writeWith(outputStream);\n+\t\t\treturn response.addBody(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n \t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa": {
      "type": "Ybodychange",
      "commitMessage": "Add handler method parameter and result converters\n\nThis commit introduces the following changes:\n - Publisher -\u003e Observable/Stream/etc. conversion is now managed\n    in a dedicated ConversionService instead of directly in\n    RequestBodyArgumentResolver and ResponseBodyResultHandler\n - More isolated logic that decides if the stream should be\n    serialized as a JSON array or not\n - Publisher\u003cByteBuffer\u003e are now handled by regular\n   ByteBufferEncoder and ByteBufferDecoder\n - Handle Publisher\u003cVoid\u003e return value properly\n - Ensure that the headers are properly written even for response\n   without body\n - Improve JsonObjectEncoder to autodetect JSON arrays\n",
      "commitDate": "2015-10-29, 5:50 a.m.",
      "commitName": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015-10-19, 5:15 a.m.",
      "commitNameOld": "cf2c1514af43bc955571ede20876d6cda1779f11",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 10.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tPublisher\u003cObject\u003e elementStream;\n\t\tResolvableType elementType;\n\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n\t\t\telementType \u003d type.getGeneric(0);\n\t\t}\n\t\telse {\n\t\t\telementStream \u003d Publishers.just(value);\n\t\t\telementType \u003d type;\n\t\t}\n\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.writeWith(outputStream);\n\t\t}\n\t\treturn Publishers.error(new IllegalStateException(\n\t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 98,
      "functionName": "handleResult",
      "diff": "@@ -1,50 +1,39 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n-\t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n+\t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n-\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n+\t\tPublisher\u003cObject\u003e elementStream;\n+\t\tResolvableType elementType;\n+\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n+\t\t\telementStream \u003d conversionService.convert(value, Publisher.class);\n+\t\t\telementType \u003d type.getGeneric(0);\n+\t\t}\n+\t\telse {\n+\t\t\telementStream \u003d Publishers.just(value);\n+\t\t\telementType \u003d type;\n+\t\t}\n+\n+\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e) resolveSerializer(request, elementType, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n-\t\t\tPublisher\u003cObject\u003e elementStream;\n-\n-\t\t\t// TODO: Refactor type conversion\n-\t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream \u003d ((Promise)value).stream();\n-\t\t\t}\n-\t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream \u003d RxJava1Converter.from((Observable) value);\n-\t\t\t}\n-\t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream \u003d RxJava1SingleConverter.from((Single)value);\n-\t\t\t}\n-\t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream \u003d CompletableFutureConverter.from((CompletableFuture) value);\n-\t\t\t}\n-\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream \u003d (Publisher)value;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\telementStream \u003d Publishers.just(value);\n-\t\t\t}\n-\n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n-\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n+\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n-\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n+\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.writeWith(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n \t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cf2c1514af43bc955571ede20876d6cda1779f11": {
      "type": "Ybodychange",
      "commitMessage": "Use latest Reactor core capabilities\n\n No need for rxjava-reactive-streams dependency and\n CompletableFutureUtils anymore.\n",
      "commitDate": "2015-10-19, 5:15 a.m.",
      "commitName": "cf2c1514af43bc955571ede20876d6cda1779f11",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015-10-16, 3:13 a.m.",
      "commitNameOld": "8ca04b84259f1840db7e1037828f7120427eb7b1",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 3.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cObject\u003e elementStream;\n\n\t\t\t// TODO: Refactor type conversion\n\t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d ((Promise)value).stream();\n\t\t\t}\n\t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxJava1Converter.from((Observable) value);\n\t\t\t}\n\t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxJava1SingleConverter.from((Single)value);\n\t\t\t}\n\t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d CompletableFutureConverter.from((CompletableFuture) value);\n\t\t\t}\n\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d (Publisher)value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementStream \u003d Publishers.just(value);\n\t\t\t}\n\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.writeWith(outputStream);\n\t\t}\n\t\treturn Publishers.error(new IllegalStateException(\n\t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 98,
      "functionName": "handleResult",
      "diff": "@@ -1,50 +1,50 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n \t\t\tPublisher\u003cObject\u003e elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n \t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d ((Promise)value).stream();\n \t\t\t}\n \t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n+\t\t\t\telementStream \u003d RxJava1Converter.from((Observable) value);\n \t\t\t}\n \t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher(((Single)value).toObservable());\n+\t\t\t\telementStream \u003d RxJava1SingleConverter.from((Single)value);\n \t\t\t}\n \t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n+\t\t\t\telementStream \u003d CompletableFutureConverter.from((CompletableFuture) value);\n \t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d (Publisher)value;\n \t\t\t}\n \t\t\telse {\n \t\t\t\telementStream \u003d Publishers.just(value);\n \t\t\t}\n \n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.writeWith(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n \t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8ca04b84259f1840db7e1037828f7120427eb7b1": {
      "type": "Ybodychange",
      "commitMessage": "More accurate ResponseBodyResultHandler error message\n",
      "commitDate": "2015-10-16, 3:13 a.m.",
      "commitName": "8ca04b84259f1840db7e1037828f7120427eb7b1",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015-10-07, 7:24 a.m.",
      "commitNameOld": "464ff1d9606a3189a41bae80e504929dec091d33",
      "commitAuthorOld": "Stephane Maldini",
      "daysBetweenCommits": 8.83,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cObject\u003e elementStream;\n\n\t\t\t// TODO: Refactor type conversion\n\t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d ((Promise)value).stream();\n\t\t\t}\n\t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n\t\t\t}\n\t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher(((Single)value).toObservable());\n\t\t\t}\n\t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n\t\t\t}\n\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d (Publisher)value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementStream \u003d Publishers.just(value);\n\t\t\t}\n\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.writeWith(outputStream);\n\t\t}\n\t\treturn Publishers.error(new IllegalStateException(\n\t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 97,
      "functionName": "handleResult",
      "diff": "@@ -1,50 +1,50 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n \t\t\tPublisher\u003cObject\u003e elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n \t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d ((Promise)value).stream();\n \t\t\t}\n \t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n \t\t\t}\n \t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d RxReactiveStreams.toPublisher(((Single)value).toObservable());\n \t\t\t}\n \t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n \t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d (Publisher)value;\n \t\t\t}\n \t\t\telse {\n \t\t\t\telementStream \u003d Publishers.just(value);\n \t\t\t}\n \n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.writeWith(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n-\t\t  \"Return value type not supported: \" + returnType));\n+\t\t  \"Return value type \u0027\" + returnType.getParameterType().getName() + \"\u0027 with media type \u0027\" + mediaType + \"\u0027 not supported\"  ));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "464ff1d9606a3189a41bae80e504929dec091d33": {
      "type": "Ybodychange",
      "commitMessage": "Progress #24\nReplace Streams fail, empty and Stream map with Publishers.error, empty and map.\nReplace Streams calls by Publishers.flatMap, just and Publishers.from\nPrecise cancel and size to toReadQueue to simulate Promise\nUpdate build\n",
      "commitDate": "2015-10-07, 7:24 a.m.",
      "commitName": "464ff1d9606a3189a41bae80e504929dec091d33",
      "commitAuthor": "Stephane Maldini",
      "commitDateOld": "2015-10-02, 2:09 p.m.",
      "commitNameOld": "9516c9992f4ed53bbb0be801bed31b6280eaff8c",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 4.72,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cObject\u003e elementStream;\n\n\t\t\t// TODO: Refactor type conversion\n\t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d ((Promise)value).stream();\n\t\t\t}\n\t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n\t\t\t}\n\t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher(((Single)value).toObservable());\n\t\t\t}\n\t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n\t\t\t}\n\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d (Publisher)value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementStream \u003d Publishers.just(value);\n\t\t\t}\n\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.writeWith(outputStream);\n\t\t}\n\t\treturn Publishers.error(new IllegalStateException(\n\t\t  \"Return value type not supported: \" + returnType));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 97,
      "functionName": "handleResult",
      "diff": "@@ -1,50 +1,50 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n-\t\t\treturn Streams.empty();\n+\t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n \t\t\tPublisher\u003cObject\u003e elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n \t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d ((Promise)value).stream();\n \t\t\t}\n \t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n \t\t\t}\n \t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d RxReactiveStreams.toPublisher(((Single)value).toObservable());\n \t\t\t}\n \t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n \t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d (Publisher)value;\n \t\t\t}\n \t\t\telse {\n-\t\t\t\telementStream \u003d Streams.just(value);\n+\t\t\t\telementStream \u003d Publishers.just(value);\n \t\t\t}\n \n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.writeWith(Streams.wrap(outputStream));\n+\t\t\treturn response.writeWith(outputStream);\n \t\t}\n-\t\treturn Streams.fail(new IllegalStateException(\n-\t\t\t\t\"Return value type not supported: \" + returnType));\n+\t\treturn Publishers.error(new IllegalStateException(\n+\t\t  \"Return value type not supported: \" + returnType));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f816cc6a516c324875fa409a33d288447c6996f7": {
      "type": "Ybodychange",
      "commitMessage": "Add CompletableFuture/Single/Promise support\n",
      "commitDate": "2015-09-24, 5:02 p.m.",
      "commitName": "f816cc6a516c324875fa409a33d288447c6996f7",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015-09-22, 2:02 a.m.",
      "commitNameOld": "110d9d7cd906c524af5053329a65ef4e1bd9f7eb",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 2.62,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Streams.empty();\n\t\t}\n\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cObject\u003e elementStream;\n\n\t\t\t// TODO: Refactor type conversion\n\t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d ((Promise)value).stream();\n\t\t\t}\n\t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n\t\t\t}\n\t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher(((Single)value).toObservable());\n\t\t\t}\n\t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n\t\t\t}\n\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d (Publisher)value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementStream \u003d Streams.just(value);\n\t\t\t}\n\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.writeWith(Streams.wrap(outputStream));\n\t\t}\n\t\treturn Streams.fail(new IllegalStateException(\n\t\t\t\t\"Return value type not supported: \" + returnType));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 96,
      "functionName": "handleResult",
      "diff": "@@ -1,41 +1,50 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Streams.empty();\n \t\t}\n \n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n \t\t\tPublisher\u003cObject\u003e elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n-\t\t\tif (Observable.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream \u003d ((Promise)value).stream();\n+\t\t\t}\n+\t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n \t\t\t}\n+\t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher(((Single)value).toObservable());\n+\t\t\t}\n+\t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream \u003d CompletableFutureUtils.toPublisher((CompletableFuture) value);\n+\t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d (Publisher)value;\n \t\t\t}\n \t\t\telse {\n \t\t\t\telementStream \u003d Streams.just(value);\n \t\t\t}\n \n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.writeWith(Streams.wrap(outputStream));\n \t\t}\n \t\treturn Streams.fail(new IllegalStateException(\n \t\t\t\t\"Return value type not supported: \" + returnType));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "110d9d7cd906c524af5053329a65ef4e1bd9f7eb": {
      "type": "Ybodychange",
      "commitMessage": "Use ByteBuffer instead of byte[]\n",
      "commitDate": "2015-09-22, 2:02 a.m.",
      "commitName": "110d9d7cd906c524af5053329a65ef4e1bd9f7eb",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015-09-10, 7:47 a.m.",
      "commitNameOld": "881db0688b5448768e1b3196fe5365a3d41d9342",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 11.76,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Streams.empty();\n\t\t}\n\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cObject\u003e elementStream;\n\n\t\t\t// TODO: Refactor type conversion\n\t\t\tif (Observable.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n\t\t\t}\n\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d (Publisher)value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementStream \u003d Streams.just(value);\n\t\t\t}\n\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.writeWith(Streams.wrap(outputStream));\n\t\t}\n\t\treturn Streams.fail(new IllegalStateException(\n\t\t\t\t\"Return value type not supported: \" + returnType));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 91,
      "functionName": "handleResult",
      "diff": "@@ -1,41 +1,41 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Streams.empty();\n \t\t}\n \n \t\tMediaType mediaType \u003d resolveMediaType(request);\n \t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n \t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer !\u003d null) {\n \t\t\tPublisher\u003cObject\u003e elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n \t\t\tif (Observable.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n \t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream \u003d (Publisher)value;\n \t\t\t}\n \t\t\telse {\n \t\t\t\telementStream \u003d Streams.just(value);\n \t\t\t}\n \n \t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n \t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.writeWith(Streams.wrap(outputStream).map(buffer -\u003e new Buffer(buffer).asBytes()));\n+\t\t\treturn response.writeWith(Streams.wrap(outputStream));\n \t\t}\n \t\treturn Streams.fail(new IllegalStateException(\n \t\t\t\t\"Return value type not supported: \" + returnType));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "881db0688b5448768e1b3196fe5365a3d41d9342": {
      "type": "Ybodychange",
      "commitMessage": "Add Codec support\n\nThis commit adds support for Publisher based codecs that allows to convert\nbyte stream to object stream and vice \u0026 versa.\n\nJackson, JAXB2 and String codec implementations are provided.\n",
      "commitDate": "2015-09-10, 7:47 a.m.",
      "commitName": "881db0688b5448768e1b3196fe5365a3d41d9342",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015-08-25, 12:45 p.m.",
      "commitNameOld": "202825554c022e4262fe3bd20a34faf01ab9d620",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 15.79,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Streams.empty();\n\t\t}\n\n\t\tMediaType mediaType \u003d resolveMediaType(request);\n\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n\t\thints.add(UTF_8);\n\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n\t\tif (serializer !\u003d null) {\n\t\t\tPublisher\u003cObject\u003e elementStream;\n\n\t\t\t// TODO: Refactor type conversion\n\t\t\tif (Observable.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n\t\t\t}\n\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n\t\t\t\telementStream \u003d (Publisher)value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telementStream \u003d Streams.just(value);\n\t\t\t}\n\n\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n\t\t\t}\n\t\t\tresponse.getHeaders().setContentType(mediaType);\n\t\t\treturn response.writeWith(Streams.wrap(outputStream).map(buffer -\u003e new Buffer(buffer).asBytes()));\n\t\t}\n\t\treturn Streams.fail(new IllegalStateException(\n\t\t\t\t\"Return value type not supported: \" + returnType));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 92,
      "functionName": "handleResult",
      "diff": "@@ -1,26 +1,41 @@\n \tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value \u003d result.getValue();\n \t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n \n \t\tif (value \u003d\u003d null) {\n \t\t\treturn Streams.empty();\n \t\t}\n \n-\t\tif (value instanceof String) {\n-\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", UTF_8));\n-\t\t\treturn response.writeWith(Streams.just(((String) value).getBytes(UTF_8)));\n-\t\t}\n-\t\telse if (value instanceof Publisher) {\n-\t\t\tClass\u003c?\u003e type \u003d ResolvableType.forMethodParameter(returnType).resolveGeneric(0);\n-\t\t\tif (String.class.equals(type)) {\n-\t\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\t\tPublisher\u003cString\u003e content \u003d (Publisher\u003cString\u003e) value;\n-\t\t\t\treturn response.writeWith(Streams.wrap(content).map(value1 -\u003e value1.getBytes(UTF_8)));\n-\t\t\t}\n-\t\t}\n+\t\tMediaType mediaType \u003d resolveMediaType(request);\n+\t\tResolvableType type \u003d ResolvableType.forMethodParameter(returnType);\n+\t\tList\u003cObject\u003e hints \u003d new ArrayList\u003c\u003e();\n+\t\thints.add(UTF_8);\n+\t\tMessageToByteEncoder\u003cObject\u003e serializer \u003d (MessageToByteEncoder\u003cObject\u003e)resolveSerializer(request, type, mediaType, hints.toArray());\n+\t\tif (serializer !\u003d null) {\n+\t\t\tPublisher\u003cObject\u003e elementStream;\n \n-\t\treturn Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n+\t\t\t// TODO: Refactor type conversion\n+\t\t\tif (Observable.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream \u003d RxReactiveStreams.toPublisher((Observable) value);\n+\t\t\t}\n+\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream \u003d (Publisher)value;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\telementStream \u003d Streams.just(value);\n+\t\t\t}\n+\n+\t\t\tPublisher\u003cByteBuffer\u003e outputStream \u003d serializer.encode(elementStream, type, mediaType, hints.toArray());\n+\t\t\tList\u003cMessageToByteEncoder\u003cByteBuffer\u003e\u003e postProcessors \u003d resolvePostProcessors(request, type, mediaType, hints.toArray());\n+\t\t\tfor (MessageToByteEncoder\u003cByteBuffer\u003e postProcessor : postProcessors) {\n+\t\t\t\toutputStream \u003d postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n+\t\t\t}\n+\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\t\treturn response.writeWith(Streams.wrap(outputStream).map(buffer -\u003e new Buffer(buffer).asBytes()));\n+\t\t}\n+\t\treturn Streams.fail(new IllegalStateException(\n+\t\t\t\t\"Return value type not supported: \" + returnType));\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "202825554c022e4262fe3bd20a34faf01ab9d620": {
      "type": "Yintroduced",
      "commitMessage": "Add basic support for @RequestMapping\n\nJust enough for a test with an @ResponseBody method that accepts an\n@RequestParam String arg and returning Publisher\u003cString\u003e or String.\n\nSee RequestMappingIntegrationTests.\n",
      "commitDate": "2015-08-25, 12:45 p.m.",
      "commitName": "202825554c022e4262fe3bd20a34faf01ab9d620",
      "commitAuthor": "Rossen Stoyanchev",
      "diff": "@@ -0,0 +1,26 @@\n+\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n+\t\t\tHandlerResult result) {\n+\n+\t\tObject value \u003d result.getValue();\n+\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n+\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n+\n+\t\tif (value \u003d\u003d null) {\n+\t\t\treturn Streams.empty();\n+\t\t}\n+\n+\t\tif (value instanceof String) {\n+\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", UTF_8));\n+\t\t\treturn response.writeWith(Streams.just(((String) value).getBytes(UTF_8)));\n+\t\t}\n+\t\telse if (value instanceof Publisher) {\n+\t\t\tClass\u003c?\u003e type \u003d ResolvableType.forMethodParameter(returnType).resolveGeneric(0);\n+\t\t\tif (String.class.equals(type)) {\n+\t\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\t\tPublisher\u003cString\u003e content \u003d (Publisher\u003cString\u003e) value;\n+\t\t\t\treturn response.writeWith(Streams.wrap(content).map(value1 -\u003e value1.getBytes(UTF_8)));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic Publisher\u003cVoid\u003e handleResult(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tHandlerResult result) {\n\n\t\tObject value \u003d result.getValue();\n\t\tHandlerMethod handlerMethod \u003d (HandlerMethod) result.getHandler();\n\t\tMethodParameter returnType \u003d handlerMethod.getReturnValueType(value);\n\n\t\tif (value \u003d\u003d null) {\n\t\t\treturn Streams.empty();\n\t\t}\n\n\t\tif (value instanceof String) {\n\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", UTF_8));\n\t\t\treturn response.writeWith(Streams.just(((String) value).getBytes(UTF_8)));\n\t\t}\n\t\telse if (value instanceof Publisher) {\n\t\t\tClass\u003c?\u003e type \u003d ResolvableType.forMethodParameter(returnType).resolveGeneric(0);\n\t\t\tif (String.class.equals(type)) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tPublisher\u003cString\u003e content \u003d (Publisher\u003cString\u003e) value;\n\t\t\t\treturn response.writeWith(Streams.wrap(content).map(value1 -\u003e value1.getBytes(UTF_8)));\n\t\t\t}\n\t\t}\n\n\t\treturn Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n\t}",
      "path": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
      "functionStartLine": 72,
      "functionName": "handleResult"
    }
  }
}