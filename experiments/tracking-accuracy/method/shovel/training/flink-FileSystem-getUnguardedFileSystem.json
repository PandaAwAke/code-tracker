{
  "origin": "codeshovel",
  "repositoryName": "flink",
  "repositoryPath": "H:\\Projects\\apache\\flink/.git",
  "startCommitName": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd",
  "sourceFileName": "FileSystem.java",
  "functionName": "getUnguardedFileSystem",
  "functionId": "getUnguardedFileSystem___fsUri-URI(modifiers-final)",
  "sourceFilePath": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
  "functionStartLine": 322,
  "functionEndLine": 415,
  "numCommitsSeen": 143,
  "timeTaken": 14328,
  "changeHistory": [
    "d7c2c417213502130b1aeab1868313df178555cc",
    "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
    "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7",
    "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed",
    "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
    "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e",
    "1c8d866a83065e3d1bc9707dab81117f24c9f678",
    "2af658673f877a7e0fd73fdd2907f88824d793a5",
    "39fb7c945359465ce5241539559daac416e210b8",
    "f2909293cbb37cc4b4516e3bef4db66376159e52",
    "bbe54ac09154dd3e60870b0d26085e2e2ee564af",
    "4203bf99ddd009b72681ba0dc554cabd47e1c85c",
    "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a",
    "8563d511da8ab8ac0e1362775f11aef7b67375be",
    "24eb47ac86299920aa137d5b6394a248ff58d19e",
    "d784bf9467bbaf8ffb37621c13fa30dfbb98e4d8",
    "0038c9d0773e90676b1ee2a8a94dcf764f023e22",
    "3a6344356a185be43f9be4b33702f97827f9ff96",
    "fc6b5168684ca298d8b025c839d9a4e48e470790",
    "33cb2ca9898809d2fc90765996ea56bbea458e59",
    "88d7305a5267aac598949519275123208195daf7",
    "d0c21f4c470812d699ec141210ad5119b3450de3",
    "b27a112add2f4c221f9bfd8e4e953a750e8d64b3",
    "75e67a701cbabe5577967037c0e865d1c2e9a25b"
  ],
  "changeHistoryShort": {
    "d7c2c417213502130b1aeab1868313df178555cc": "Ybodychange",
    "536675b03a5050fda9c3e1fd403818cb50dcc6ff": "Ymultichange(Yparameterchange,Ybodychange)",
    "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7": "Ybodychange",
    "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed": "Yrename",
    "a3d1a17406749e41185a77a64c23fc1cb3eabc76": "Ybodychange",
    "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e": "Ybodychange",
    "1c8d866a83065e3d1bc9707dab81117f24c9f678": "Ybodychange",
    "2af658673f877a7e0fd73fdd2907f88824d793a5": "Ybodychange",
    "39fb7c945359465ce5241539559daac416e210b8": "Ybodychange",
    "f2909293cbb37cc4b4516e3bef4db66376159e52": "Ybodychange",
    "bbe54ac09154dd3e60870b0d26085e2e2ee564af": "Ybodychange",
    "4203bf99ddd009b72681ba0dc554cabd47e1c85c": "Ybodychange",
    "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a": "Ybodychange",
    "8563d511da8ab8ac0e1362775f11aef7b67375be": "Yfilerename",
    "24eb47ac86299920aa137d5b6394a248ff58d19e": "Ymovefromfile",
    "d784bf9467bbaf8ffb37621c13fa30dfbb98e4d8": "Ybodychange",
    "0038c9d0773e90676b1ee2a8a94dcf764f023e22": "Ymultichange(Ybodychange,Yparametermetachange)",
    "3a6344356a185be43f9be4b33702f97827f9ff96": "Ybodychange",
    "fc6b5168684ca298d8b025c839d9a4e48e470790": "Yfilerename",
    "33cb2ca9898809d2fc90765996ea56bbea458e59": "Yfilerename",
    "88d7305a5267aac598949519275123208195daf7": "Ybodychange",
    "d0c21f4c470812d699ec141210ad5119b3450de3": "Ybodychange",
    "b27a112add2f4c221f9bfd8e4e953a750e8d64b3": "Yparametermetachange",
    "75e67a701cbabe5577967037c0e865d1c2e9a25b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d7c2c417213502130b1aeab1868313df178555cc": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-8125] [core] Introduce limiting of outgoing file system connections\n",
      "commitDate": "2017-11-24, 5:41 a.m.",
      "commitName": "d7c2c417213502130b1aeab1868313df178555cc",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2017-11-24, 5:41 a.m.",
      "commitNameOld": "f04b32b02900181db82c6c518ffbd6430a0a369a",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n\t\tcheckNotNull(fsUri, \"file system URI\");\n\n\t\tLOCK.lock();\n\t\ttry {\n\t\t\tfinal URI uri;\n\n\t\t\tif (fsUri.getScheme() !\u003d null) {\n\t\t\t\turi \u003d fsUri;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Apply the default fs scheme\n\t\t\t\tfinal URI defaultUri \u003d getDefaultFsUri();\n\t\t\t\tURI rewrittenUri \u003d null;\n\n\t\t\t\ttry {\n\t\t\t\t\trewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n\t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n\t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trewrittenUri \u003d new URI(\n\t\t\t\t\t\t\t\t\t\"file\", null,\n\t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n\t\t\t\t\t\t\t\t\tnull);\n\t\t\t\t\t\t} catch (URISyntaxException ignored) {\n\t\t\t\t\t\t\t// could not help it...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rewrittenUri !\u003d null) {\n\t\t\t\t\turi \u003d rewrittenUri;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IOException(\"The file system URI \u0027\" + fsUri +\n\t\t\t\t\t\t\t\"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\"\n\t\t\t\t\t\t\t+ defaultUri + \").\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users)\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\t{\n\t\t\t\tFileSystem cached \u003d CACHE.get(key);\n\t\t\t\tif (cached !\u003d null) {\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// this \"default\" initialization makes sure that the FileSystem class works\n\t\t\t// even when not configured with an explicit Flink configuration, like on\n\t\t\t// JobManager or TaskManager setup\n\t\t\tif (FS_FACTORIES.isEmpty()) {\n\t\t\t\tinitialize(new Configuration());\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tfinal FileSystem fs;\n\t\t\tfinal FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n\n\t\t\tif (factory !\u003d null) {\n\t\t\t\tfs \u003d factory.create(uri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tfs \u003d FALLBACK_FACTORY.create(uri);\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n\t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n\t\t\t\t\t\t\t\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() +\n\t\t\t\t\t\t\t\t\t\"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" +\n\t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCACHE.put(key, fs);\n\t\t\treturn fs;\n\t\t}\n\t\tfinally {\n\t\t\tLOCK.unlock();\n\t\t}\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 322,
      "functionName": "getUnguardedFileSystem",
      "diff": "@@ -1,87 +1,94 @@\n \tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n \t\tcheckNotNull(fsUri, \"file system URI\");\n \n \t\tLOCK.lock();\n \t\ttry {\n \t\t\tfinal URI uri;\n \n \t\t\tif (fsUri.getScheme() !\u003d null) {\n \t\t\t\turi \u003d fsUri;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// Apply the default fs scheme\n \t\t\t\tfinal URI defaultUri \u003d getDefaultFsUri();\n \t\t\t\tURI rewrittenUri \u003d null;\n \n \t\t\t\ttry {\n \t\t\t\t\trewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n \t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n \t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\trewrittenUri \u003d new URI(\n \t\t\t\t\t\t\t\t\t\"file\", null,\n \t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n \t\t\t\t\t\t\t\t\tnull);\n \t\t\t\t\t\t} catch (URISyntaxException ignored) {\n \t\t\t\t\t\t\t// could not help it...\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (rewrittenUri !\u003d null) {\n \t\t\t\t\turi \u003d rewrittenUri;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IOException(\"The file system URI \u0027\" + fsUri +\n \t\t\t\t\t\t\t\"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\"\n \t\t\t\t\t\t\t+ defaultUri + \").\");\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users)\n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\t{\n \t\t\t\tFileSystem cached \u003d CACHE.get(key);\n \t\t\t\tif (cached !\u003d null) {\n \t\t\t\t\treturn cached;\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\t// this \"default\" initialization makes sure that the FileSystem class works\n+\t\t\t// even when not configured with an explicit Flink configuration, like on\n+\t\t\t// JobManager or TaskManager setup\n+\t\t\tif (FS_FACTORIES.isEmpty()) {\n+\t\t\t\tinitialize(new Configuration());\n+\t\t\t}\n+\n \t\t\t// Try to create a new file system\n \t\t\tfinal FileSystem fs;\n \t\t\tfinal FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n \n \t\t\tif (factory !\u003d null) {\n \t\t\t\tfs \u003d factory.create(uri);\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttry {\n \t\t\t\t\tfs \u003d FALLBACK_FACTORY.create(uri);\n \t\t\t\t}\n \t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n \t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n \t\t\t\t\t\t\t\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() +\n \t\t\t\t\t\t\t\t\t\"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" +\n \t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tCACHE.put(key, fs);\n \t\t\treturn fs;\n \t\t}\n \t\tfinally {\n \t\t\tLOCK.unlock();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "536675b03a5050fda9c3e1fd403818cb50dcc6ff": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
      "commitDate": "2017-10-06, 5:16 a.m.",
      "commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
      "commitAuthor": "Stephan Ewen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
          "commitDate": "2017-10-06, 5:16 a.m.",
          "commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
          "commitAuthor": "Stephan Ewen",
          "commitDateOld": "2017-10-05, 1:14 p.m.",
          "commitNameOld": "a5ef09bb601cdd77fcb94e9ce633fdf979031aaf",
          "commitAuthorOld": "Stephan Ewen",
          "daysBetweenCommits": 0.67,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n\t\tcheckNotNull(fsUri, \"file system URI\");\n\n\t\tLOCK.lock();\n\t\ttry {\n\t\t\tfinal URI uri;\n\n\t\t\tif (fsUri.getScheme() !\u003d null) {\n\t\t\t\turi \u003d fsUri;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Apply the default fs scheme\n\t\t\t\tfinal URI defaultUri \u003d getDefaultFsUri();\n\t\t\t\tURI rewrittenUri \u003d null;\n\n\t\t\t\ttry {\n\t\t\t\t\trewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n\t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n\t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trewrittenUri \u003d new URI(\n\t\t\t\t\t\t\t\t\t\"file\", null,\n\t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n\t\t\t\t\t\t\t\t\tnull);\n\t\t\t\t\t\t} catch (URISyntaxException ignored) {\n\t\t\t\t\t\t\t// could not help it...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rewrittenUri !\u003d null) {\n\t\t\t\t\turi \u003d rewrittenUri;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IOException(\"The file system URI \u0027\" + fsUri +\n\t\t\t\t\t\t\t\"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\"\n\t\t\t\t\t\t\t+ defaultUri + \").\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users) \n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\t{\n\t\t\t\tFileSystem cached \u003d CACHE.get(key);\n\t\t\t\tif (cached !\u003d null) {\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tfinal FileSystem fs;\n\t\t\tfinal FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n\n\t\t\tif (factory !\u003d null) {\n\t\t\t\tfs \u003d factory.create(uri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tfs \u003d FALLBACK_FACTORY.create(uri);\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n\t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n\t\t\t\t\t\t\t\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \n\t\t\t\t\t\t\t\t\t\"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" +\n\t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCACHE.put(key, fs);\n\t\t\treturn fs;\n\t\t}\n\t\tfinally {\n\t\t\tLOCK.unlock();\n\t\t}\n\t}",
          "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
          "functionStartLine": 309,
          "functionName": "getUnguardedFileSystem",
          "diff": "@@ -1,93 +1,87 @@\n-\tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-\t\tfinal URI asked \u003d uri;\n+\tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n+\t\tcheckNotNull(fsUri, \"file system URI\");\n \n \t\tLOCK.lock();\n \t\ttry {\n+\t\t\tfinal URI uri;\n \n-\t\t\tif (uri.getScheme() \u003d\u003d null) {\n+\t\t\tif (fsUri.getScheme() !\u003d null) {\n+\t\t\t\turi \u003d fsUri;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// Apply the default fs scheme\n+\t\t\t\tfinal URI defaultUri \u003d getDefaultFsUri();\n+\t\t\t\tURI rewrittenUri \u003d null;\n+\n \t\t\t\ttry {\n-\t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n-\t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n-\t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n-\n-\t\t\t\t} catch (URISyntaxException e) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n-\t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n-\t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\trewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n+\t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n+\t\t\t\t}\n+\t\t\t\tcatch (URISyntaxException e) {\n+\t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n+\t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\trewrittenUri \u003d new URI(\n+\t\t\t\t\t\t\t\t\t\"file\", null,\n+\t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n+\t\t\t\t\t\t\t\t\tnull);\n+\t\t\t\t\t\t} catch (URISyntaxException ignored) {\n+\t\t\t\t\t\t\t// could not help it...\n \t\t\t\t\t\t}\n-\t\t\t\t\t} catch (URISyntaxException ex) {\n-\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n+\n+\t\t\t\tif (rewrittenUri !\u003d null) {\n+\t\t\t\t\turi \u003d rewrittenUri;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new IOException(\"The file system URI \u0027\" + fsUri +\n+\t\t\t\t\t\t\t\"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\"\n+\t\t\t\t\t\t\t+ defaultUri + \").\");\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\tif(uri.getScheme() \u003d\u003d null) {\n-\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n-\t\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n-\t\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n-\t\t\t}\n-\n+\t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users) \n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n-\t\t\tif (CACHE.containsKey(key)) {\n-\t\t\t\treturn CACHE.get(key);\n+\t\t\t{\n+\t\t\t\tFileSystem cached \u003d CACHE.get(key);\n+\t\t\t\tif (cached !\u003d null) {\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tfinal FileSystem fs;\n+\t\t\tfinal FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n \n-\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n-\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n-\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n-\t\t\t\tif (wrapperClass !\u003d null) {\n-\t\t\t\t\t// hadoop has support for the FileSystem\n-\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n-\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n-\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n-\t\t\t\t\t}\n-\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n-\n-\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n-\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n-\t\t\t\t\tfs.initialize(uri);\n-\t\t\t\t\tCACHE.put(wrappedKey, fs);\n-\n-\t\t\t\t} else {\n-\t\t\t\t\t// we can not read from this file system.\n-\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n+\t\t\tif (factory !\u003d null) {\n+\t\t\t\tfs \u003d factory.create(uri);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttry {\n+\t\t\t\t\tfs \u003d FALLBACK_FACTORY.create(uri);\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// we end up here if we have a file system with build-in flink support.\n-\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n-\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n-\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n-\t\t\t\t} else {\n-\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n+\t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n+\t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n+\t\t\t\t\t\t\t\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \n+\t\t\t\t\t\t\t\t\t\"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" +\n+\t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n \t\t\t\t}\n-\t\t\t\t// Initialize new file system object\n-\t\t\t\tfs.initialize(uri);\n-\n-\t\t\t\t// Add new file system object to cache\n-\t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \n+\t\t\tCACHE.put(key, fs);\n \t\t\treturn fs;\n \t\t}\n \t\tfinally {\n \t\t\tLOCK.unlock();\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI]",
            "newValue": "[fsUri-URI(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
          "commitDate": "2017-10-06, 5:16 a.m.",
          "commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
          "commitAuthor": "Stephan Ewen",
          "commitDateOld": "2017-10-05, 1:14 p.m.",
          "commitNameOld": "a5ef09bb601cdd77fcb94e9ce633fdf979031aaf",
          "commitAuthorOld": "Stephan Ewen",
          "daysBetweenCommits": 0.67,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n\t\tcheckNotNull(fsUri, \"file system URI\");\n\n\t\tLOCK.lock();\n\t\ttry {\n\t\t\tfinal URI uri;\n\n\t\t\tif (fsUri.getScheme() !\u003d null) {\n\t\t\t\turi \u003d fsUri;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Apply the default fs scheme\n\t\t\t\tfinal URI defaultUri \u003d getDefaultFsUri();\n\t\t\t\tURI rewrittenUri \u003d null;\n\n\t\t\t\ttry {\n\t\t\t\t\trewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n\t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n\t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trewrittenUri \u003d new URI(\n\t\t\t\t\t\t\t\t\t\"file\", null,\n\t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n\t\t\t\t\t\t\t\t\tnull);\n\t\t\t\t\t\t} catch (URISyntaxException ignored) {\n\t\t\t\t\t\t\t// could not help it...\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rewrittenUri !\u003d null) {\n\t\t\t\t\turi \u003d rewrittenUri;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IOException(\"The file system URI \u0027\" + fsUri +\n\t\t\t\t\t\t\t\"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\"\n\t\t\t\t\t\t\t+ defaultUri + \").\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users) \n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\t{\n\t\t\t\tFileSystem cached \u003d CACHE.get(key);\n\t\t\t\tif (cached !\u003d null) {\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tfinal FileSystem fs;\n\t\t\tfinal FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n\n\t\t\tif (factory !\u003d null) {\n\t\t\t\tfs \u003d factory.create(uri);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tfs \u003d FALLBACK_FACTORY.create(uri);\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n\t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n\t\t\t\t\t\t\t\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \n\t\t\t\t\t\t\t\t\t\"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" +\n\t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCACHE.put(key, fs);\n\t\t\treturn fs;\n\t\t}\n\t\tfinally {\n\t\t\tLOCK.unlock();\n\t\t}\n\t}",
          "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
          "functionStartLine": 309,
          "functionName": "getUnguardedFileSystem",
          "diff": "@@ -1,93 +1,87 @@\n-\tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-\t\tfinal URI asked \u003d uri;\n+\tpublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n+\t\tcheckNotNull(fsUri, \"file system URI\");\n \n \t\tLOCK.lock();\n \t\ttry {\n+\t\t\tfinal URI uri;\n \n-\t\t\tif (uri.getScheme() \u003d\u003d null) {\n+\t\t\tif (fsUri.getScheme() !\u003d null) {\n+\t\t\t\turi \u003d fsUri;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// Apply the default fs scheme\n+\t\t\t\tfinal URI defaultUri \u003d getDefaultFsUri();\n+\t\t\t\tURI rewrittenUri \u003d null;\n+\n \t\t\t\ttry {\n-\t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n-\t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n-\t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n-\n-\t\t\t\t} catch (URISyntaxException e) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n-\t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n-\t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\trewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(),\n+\t\t\t\t\t\t\tdefaultUri.getPort(), fsUri.getPath(), null, null);\n+\t\t\t\t}\n+\t\t\t\tcatch (URISyntaxException e) {\n+\t\t\t\t\t// for local URIs, we make one more try to repair the path by making it absolute\n+\t\t\t\t\tif (defaultUri.getScheme().equals(\"file\")) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\trewrittenUri \u003d new URI(\n+\t\t\t\t\t\t\t\t\t\"file\", null,\n+\t\t\t\t\t\t\t\t\tnew Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(),\n+\t\t\t\t\t\t\t\t\tnull);\n+\t\t\t\t\t\t} catch (URISyntaxException ignored) {\n+\t\t\t\t\t\t\t// could not help it...\n \t\t\t\t\t\t}\n-\t\t\t\t\t} catch (URISyntaxException ex) {\n-\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n+\n+\t\t\t\tif (rewrittenUri !\u003d null) {\n+\t\t\t\t\turi \u003d rewrittenUri;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new IOException(\"The file system URI \u0027\" + fsUri +\n+\t\t\t\t\t\t\t\"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\"\n+\t\t\t\t\t\t\t+ defaultUri + \").\");\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\tif(uri.getScheme() \u003d\u003d null) {\n-\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n-\t\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n-\t\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n-\t\t\t}\n-\n+\t\t\t// print a helpful pointer for malformed local URIs (happens a lot to new users) \n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n-\t\t\tif (CACHE.containsKey(key)) {\n-\t\t\t\treturn CACHE.get(key);\n+\t\t\t{\n+\t\t\t\tFileSystem cached \u003d CACHE.get(key);\n+\t\t\t\tif (cached !\u003d null) {\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tfinal FileSystem fs;\n+\t\t\tfinal FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n \n-\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n-\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n-\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n-\t\t\t\tif (wrapperClass !\u003d null) {\n-\t\t\t\t\t// hadoop has support for the FileSystem\n-\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n-\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n-\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n-\t\t\t\t\t}\n-\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n-\n-\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n-\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n-\t\t\t\t\tfs.initialize(uri);\n-\t\t\t\t\tCACHE.put(wrappedKey, fs);\n-\n-\t\t\t\t} else {\n-\t\t\t\t\t// we can not read from this file system.\n-\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n+\t\t\tif (factory !\u003d null) {\n+\t\t\t\tfs \u003d factory.create(uri);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttry {\n+\t\t\t\t\tfs \u003d FALLBACK_FACTORY.create(uri);\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// we end up here if we have a file system with build-in flink support.\n-\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n-\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n-\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n-\t\t\t\t} else {\n-\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n+\t\t\t\tcatch (UnsupportedFileSystemSchemeException e) {\n+\t\t\t\t\tthrow new UnsupportedFileSystemSchemeException(\n+\t\t\t\t\t\t\t\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \n+\t\t\t\t\t\t\t\t\t\"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" +\n+\t\t\t\t\t\t\t\t\t\"system to support this scheme could be loaded.\", e);\n \t\t\t\t}\n-\t\t\t\t// Initialize new file system object\n-\t\t\t\tfs.initialize(uri);\n-\n-\t\t\t\t// Add new file system object to cache\n-\t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \n+\t\t\tCACHE.put(key, fs);\n \t\t\treturn fs;\n \t\t}\n \t\tfinally {\n \t\t\tLOCK.unlock();\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-7643] [core] Misc. cleanups in FileSystem\n\n  - Simplify access to local file system\n  - Use a fair lock for all FileSystem.get() operations\n  - Robust falback to local fs for default scheme (avoids URI parsing error on Windows)\n  - Deprecate \u0027getDefaultBlockSize()\u0027\n  - Deprecate create(...) with block sizes and replication factor, which is not applicable to many FS\n",
      "commitDate": "2017-10-05, 1:14 p.m.",
      "commitName": "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2017-02-19, 7:01 p.m.",
      "commitNameOld": "5902ea0e88c70f330c23b9ace94033ae34c84445",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 227.72,
      "commitsBetweenForRepo": 1498,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n\t\tfinal URI asked \u003d uri;\n\n\t\tLOCK.lock();\n\t\ttry {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n\t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n\t\t\t\t\t}\n\n\t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n\t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n\n\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n\t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n\t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n\t\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n\t\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n\t\t\t}\n\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tfinal FileSystem fs;\n\n\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n\t\t\t\tif (wrapperClass !\u003d null) {\n\t\t\t\t\t// hadoop has support for the FileSystem\n\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n\n\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n\t\t\t\t\tfs.initialize(uri);\n\t\t\t\t\tCACHE.put(wrappedKey, fs);\n\n\t\t\t\t} else {\n\t\t\t\t\t// we can not read from this file system.\n\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we end up here if we have a file system with build-in flink support.\n\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n\t\t\t\t} else {\n\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n\t\t\t\t}\n\t\t\t\t// Initialize new file system object\n\t\t\t\tfs.initialize(uri);\n\n\t\t\t\t// Add new file system object to cache\n\t\t\t\tCACHE.put(key, fs);\n\t\t\t}\n\n\t\t\treturn fs;\n\t\t}\n\t\tfinally {\n\t\t\tLOCK.unlock();\n\t\t}\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 300,
      "functionName": "getUnguardedFileSystem",
      "diff": "@@ -1,89 +1,93 @@\n \tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-\t\tFileSystem fs;\n+\t\tfinal URI asked \u003d uri;\n \n-\t\tURI asked \u003d uri;\n-\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n+\t\tLOCK.lock();\n+\t\ttry {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n \t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n \t\t\t\t\t}\n \n \t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n \t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n \n \t\t\t\t} catch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n \t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n \t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t\t}\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif(uri.getScheme() \u003d\u003d null) {\n \t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n \t\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n \t\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n \t\t\t}\n \n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n+\t\t\tfinal FileSystem fs;\n \n \t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n \t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass !\u003d null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n-\t\t}\n \n-\t\treturn fs;\n+\t\t\treturn fs;\n+\t\t}\n+\t\tfinally {\n+\t\t\tLOCK.unlock();\n+\t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed": {
      "type": "Yrename",
      "commitMessage": "[FLINK-4910] Introduce safety net for closing file system streams\n\nThis closes #2691.\n",
      "commitDate": "2016-11-22, 5:16 p.m.",
      "commitName": "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2016-07-05, 4:39 a.m.",
      "commitNameOld": "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
      "commitAuthorOld": "Josh",
      "daysBetweenCommits": 140.57,
      "commitsBetweenForRepo": 710,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n\t\tFileSystem fs;\n\n\t\tURI asked \u003d uri;\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n\t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n\t\t\t\t\t}\n\n\t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n\t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n\n\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n\t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n\t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n\t\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n\t\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n\t\t\t}\n\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\n\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n\t\t\t\tif (wrapperClass !\u003d null) {\n\t\t\t\t\t// hadoop has support for the FileSystem\n\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n\n\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n\t\t\t\t\tfs.initialize(uri);\n\t\t\t\t\tCACHE.put(wrappedKey, fs);\n\n\t\t\t\t} else {\n\t\t\t\t\t// we can not read from this file system.\n\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we end up here if we have a file system with build-in flink support.\n\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n\t\t\t\t} else {\n\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n\t\t\t\t}\n\t\t\t\t// Initialize new file system object\n\t\t\t\tfs.initialize(uri);\n\n\t\t\t\t// Add new file system object to cache\n\t\t\t\tCACHE.put(key, fs);\n\t\t\t}\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 255,
      "functionName": "getUnguardedFileSystem",
      "diff": "@@ -1,89 +1,89 @@\n-\tpublic static FileSystem get(URI uri) throws IOException {\n+\tpublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n \t\tFileSystem fs;\n \n \t\tURI asked \u003d uri;\n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n \t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n \t\t\t\t\t}\n \n \t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n-\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n+\t\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n \n \t\t\t\t} catch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n \t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n-\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t\t}\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif(uri.getScheme() \u003d\u003d null) {\n \t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n-\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n-\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n+\t\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n+\t\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n \t\t\t}\n \n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n \t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass !\u003d null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n+\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "get",
        "newValue": "getUnguardedFileSystem"
      }
    },
    "a3d1a17406749e41185a77a64c23fc1cb3eabc76": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4115] Skip filesystem checks for filesystems with no built-in support\n",
      "commitDate": "2016-07-05, 4:39 a.m.",
      "commitName": "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
      "commitAuthor": "Josh",
      "commitDateOld": "2016-02-16, 9:23 a.m.",
      "commitNameOld": "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e",
      "commitAuthorOld": "Kostas Kloudas",
      "daysBetweenCommits": 139.76,
      "commitsBetweenForRepo": 702,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\t\tFileSystem fs;\n\n\t\tURI asked \u003d uri;\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n\t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n\t\t\t\t\t}\n\n\t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n\n\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n\t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n\t\t\t}\n\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\n\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n\t\t\t\tif (wrapperClass !\u003d null) {\n\t\t\t\t\t// hadoop has support for the FileSystem\n\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n\n\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n\t\t\t\t\tfs.initialize(uri);\n\t\t\t\t\tCACHE.put(wrappedKey, fs);\n\n\t\t\t\t} else {\n\t\t\t\t\t// we can not read from this file system.\n\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we end up here if we have a file system with build-in flink support.\n\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n\t\t\t\t} else {\n\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n\t\t\t\t}\n\t\t\t\t// Initialize new file system object\n\t\t\t\tfs.initialize(uri);\n\n\t\t\t\t// Add new file system object to cache\n\t\t\t\tCACHE.put(key, fs);\n\t\t\t}\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 228,
      "functionName": "get",
      "diff": "@@ -1,89 +1,89 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \t\tFileSystem fs;\n \n \t\tURI asked \u003d uri;\n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n \t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n \t\t\t\t\t}\n \n \t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n \t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n \n \t\t\t\t} catch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n \t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n \t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t\t}\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif(uri.getScheme() \u003d\u003d null) {\n \t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n \t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n \t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n \t\t\t}\n \n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n-\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n+\t\t\tif (!isFlinkSupportedScheme(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n \t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass !\u003d null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e": {
      "type": "Ybodychange",
      "commitMessage": "FLINK-2380: allow the specification of a default filesystem scheme in the flink configuration file.\n\nThis closes #1524\n",
      "commitDate": "2016-02-16, 9:23 a.m.",
      "commitName": "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e",
      "commitAuthor": "Kostas Kloudas",
      "commitDateOld": "2016-01-07, 10:01 a.m.",
      "commitNameOld": "c674a6558e07f1d918961a21ddaad4a6148698a0",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 39.97,
      "commitsBetweenForRepo": 256,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\t\tFileSystem fs;\n\n\t\tURI asked \u003d uri;\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n\t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n\t\t\t\t\t}\n\n\t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n\n\t\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n\t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n\t\t\t}\n\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n\t\t\t\tif (wrapperClass !\u003d null) {\n\t\t\t\t\t// hadoop has support for the FileSystem\n\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n\n\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n\t\t\t\t\tfs.initialize(uri);\n\t\t\t\t\tCACHE.put(wrappedKey, fs);\n\n\t\t\t\t} else {\n\t\t\t\t\t// we can not read from this file system.\n\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we end up here if we have a file system with build-in flink support.\n\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n\t\t\t\t} else {\n\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n\t\t\t\t}\n\t\t\t\t// Initialize new file system object\n\t\t\t\tfs.initialize(uri);\n\n\t\t\t\t// Add new file system object to cache\n\t\t\t\tCACHE.put(key, fs);\n\t\t\t}\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 228,
      "functionName": "get",
      "diff": "@@ -1,74 +1,89 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \t\tFileSystem fs;\n \n+\t\tURI asked \u003d uri;\n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n-\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n-\t\t\t\t}\n-\t\t\t\tcatch (URISyntaxException e) {\n+\t\t\t\t\tif (defaultScheme \u003d\u003d null) {\n+\t\t\t\t\t\tdefaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\turi \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(),\n+\t\t\t\t\t\tdefaultScheme.getPort(), uri.getPath(), null, null);\n+\n+\t\t\t\t} catch (URISyntaxException e) {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\t\tif (defaultScheme.getScheme().equals(\"file\")) {\n+\t\t\t\t\t\t\turi \u003d new URI(\"file\", null,\n+\t\t\t\t\t\t\t\tnew Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\t\t}\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n+\t\t\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\n+\n+\t\t\tif(uri.getScheme() \u003d\u003d null) {\n+\t\t\t\tthrow new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" +\n+\t\t\t\t\t\"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked +\n+\t\t\t\t\t\", and the final URI \u003d \" + uri + \".\");\n+\t\t\t}\n+\n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n-\t\t\t\t\n+\n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n \t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass !\u003d null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n+\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c8d866a83065e3d1bc9707dab81117f24c9f678": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1968] [runtime] Clean up and improve the distributed cache.\n\n - Gives a proper exception when a non-cached file is accessed\n - Forwards I/O exceptions that happen during file transfer, rather than only returning null when transfer failed\n - Consistently keeps reference counts and copies only when needed\n - Properly removes all files when shutdown\n - Uses a shutdown hook to remove files when process is killed\n",
      "commitDate": "2015-05-11, 3:07 p.m.",
      "commitName": "1c8d866a83065e3d1bc9707dab81117f24c9f678",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2015-03-31, 1:54 p.m.",
      "commitNameOld": "d8c74d20970e6cf379165ffafe8550a5b98d7c4d",
      "commitAuthorOld": "hongsibao",
      "daysBetweenCommits": 41.05,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\t\tFileSystem fs;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\t\t\t\t\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n\t\t\t\tif (wrapperClass !\u003d null) {\n\t\t\t\t\t// hadoop has support for the FileSystem\n\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n\n\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n\t\t\t\t\tfs.initialize(uri);\n\t\t\t\t\tCACHE.put(wrappedKey, fs);\n\n\t\t\t\t} else {\n\t\t\t\t\t// we can not read from this file system.\n\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we end up here if we have a file system with build-in flink support.\n\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n\t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n\t\t\t\t} else {\n\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n\t\t\t\t}\n\t\t\t\t// Initialize new file system object\n\t\t\t\tfs.initialize(uri);\n\n\t\t\t\t// Add new file system object to cache\n\t\t\t\tCACHE.put(key, fs);\n\t\t\t}\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 193,
      "functionName": "get",
      "diff": "@@ -1,74 +1,74 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n-\t\tFileSystem fs \u003d null;\n+\t\tFileSystem fs;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n \t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif (wrapperClass !\u003d null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2af658673f877a7e0fd73fdd2907f88824d793a5": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1295][FLINK-883] Allow to deploy \u0027job only\u0027 YARN cluster. Add tests to YARN\n\n- users can now also deploy Flink on YARN for executing a single job.\n- The flink-yarn project has been moved out of the flink-addons module\n- the MiniYARNCluster is used for testing Flink on YARN\n- There is now a (undocumented) Java interface Flink\u0027s YARN client, allowing users to manually control the Yarn session.\n- ALL ports used by Flink when running on YARN are automatically determined. In the past users reported problems with blocked ports (YARN is telling the client the RPC address of the application master)\n- The checks before deployment have been improved to give better error messages if the user is requesting too many resources for a YARN session\n",
      "commitDate": "2015-01-23, 12:39 p.m.",
      "commitName": "2af658673f877a7e0fd73fdd2907f88824d793a5",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2015-01-08, 10:42 a.m.",
      "commitNameOld": "39fb7c945359465ce5241539559daac416e210b8",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 15.08,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\t\t\t\t\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n\t\t\t\tif(wrapperClass !\u003d null) {\n\t\t\t\t\t// hadoop has support for the FileSystem\n\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n\n\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n\t\t\t\t\tfs.initialize(uri);\n\t\t\t\t\tCACHE.put(wrappedKey, fs);\n\n\t\t\t\t} else {\n\t\t\t\t\t// we can not read from this file system.\n\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we end up here if we have a file system with build-in flink support.\n\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n\t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n\t\t\t\t} else {\n\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n\t\t\t\t}\n\t\t\t\t// Initialize new file system object\n\t\t\t\tfs.initialize(uri);\n\n\t\t\t\t// Add new file system object to cache\n\t\t\t\tCACHE.put(key, fs);\n\t\t\t}\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 196,
      "functionName": "get",
      "diff": "@@ -1,75 +1,74 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n \t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif(wrapperClass !\u003d null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n-\t\t\t\t\tSystem.out.println(\"Initializing new instance of wrapper for \"+wrapperClass);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n \t\t\t\t}\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39fb7c945359465ce5241539559daac416e210b8": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1266] More dependency exclusions \u0026 fixed image in web client\n\nThis closes #268\n",
      "commitDate": "2015-01-08, 10:42 a.m.",
      "commitName": "39fb7c945359465ce5241539559daac416e210b8",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2015-01-08, 10:35 a.m.",
      "commitNameOld": "0af4d3abf3afdeff89fee479a37413bc303d0ed0",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\t\t\t\t\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n\t\t\t\tif(wrapperClass !\u003d null) {\n\t\t\t\t\t// hadoop has support for the FileSystem\n\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n\n\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n\t\t\t\t\tfs.initialize(uri);\n\t\t\t\t\tSystem.out.println(\"Initializing new instance of wrapper for \"+wrapperClass);\n\t\t\t\t\tCACHE.put(wrappedKey, fs);\n\n\t\t\t\t} else {\n\t\t\t\t\t// we can not read from this file system.\n\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we end up here if we have a file system with build-in flink support.\n\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n\t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n\t\t\t\t} else {\n\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n\t\t\t\t}\n\t\t\t\t// Initialize new file system object\n\t\t\t\tfs.initialize(uri);\n\n\t\t\t\t// Add new file system object to cache\n\t\t\t\tCACHE.put(key, fs);\n\t\t\t}\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 196,
      "functionName": "get",
      "diff": "@@ -1,76 +1,75 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n \t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n \t\t\t\tif(wrapperClass !\u003d null) {\n \t\t\t\t\t// hadoop has support for the FileSystem\n \t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n \t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n \t\t\t\t\t\treturn CACHE.get(wrappedKey);\n \t\t\t\t\t}\n \t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n \n \t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n \t\t\t\t\tfs.initialize(uri);\n \t\t\t\t\tSystem.out.println(\"Initializing new instance of wrapper for \"+wrapperClass);\n \t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n \t\t\t\t} else {\n \t\t\t\t\t// we can not read from this file system.\n \t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// we end up here if we have a file system with build-in flink support.\n \t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n \t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n \t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n \t\t\t\t} else {\n \t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n \t\t\t\t}\n-\t\t\t\tSystem.out.println(\"Initializing new instance of native class for \"+fsClass);\n \t\t\t\t// Initialize new file system object\n \t\t\t\tfs.initialize(uri);\n \n \t\t\t\t// Add new file system object to cache\n \t\t\t\tCACHE.put(key, fs);\n \t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f2909293cbb37cc4b4516e3bef4db66376159e52": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1266] Generalize DistributedFileSystem implementation\nto HadoopFileSystem wrapper, which supports all subclasses of org.apache.hadoop.fs.FileSystem.\nThis allows us to let users use all file systems with support for HDFS.\nThe change has been tested with Tachyon, Google Cloud Storage Hadoop Adapter and HDFS.\n\nThe change also cleans up the Hadoop dependency exclusions.\n",
      "commitDate": "2015-01-08, 10:35 a.m.",
      "commitName": "f2909293cbb37cc4b4516e3bef4db66376159e52",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014-11-27, 12:18 p.m.",
      "commitNameOld": "bbe54ac09154dd3e60870b0d26085e2e2ee564af",
      "commitAuthorOld": "zentol",
      "daysBetweenCommits": 41.93,
      "commitsBetweenForRepo": 210,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\t\t\t\t\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n\t\t\t\tif(wrapperClass !\u003d null) {\n\t\t\t\t\t// hadoop has support for the FileSystem\n\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n\n\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n\t\t\t\t\tfs.initialize(uri);\n\t\t\t\t\tSystem.out.println(\"Initializing new instance of wrapper for \"+wrapperClass);\n\t\t\t\t\tCACHE.put(wrappedKey, fs);\n\n\t\t\t\t} else {\n\t\t\t\t\t// we can not read from this file system.\n\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we end up here if we have a file system with build-in flink support.\n\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n\t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n\t\t\t\t} else {\n\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"Initializing new instance of native class for \"+fsClass);\n\t\t\t\t// Initialize new file system object\n\t\t\t\tfs.initialize(uri);\n\n\t\t\t\t// Add new file system object to cache\n\t\t\t\tCACHE.put(key, fs);\n\t\t\t}\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 196,
      "functionName": "get",
      "diff": "@@ -1,66 +1,76 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n-\n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n \t\t\t\t\t} catch (URISyntaxException ex) {\n \t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n+\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n-\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n-\t\t\t}\n+\t\t\t\t// no build in support for this file system. Falling back to Hadoop\u0027s FileSystem impl.\n+\t\t\t\tClass\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n+\t\t\t\tif(wrapperClass !\u003d null) {\n+\t\t\t\t\t// hadoop has support for the FileSystem\n+\t\t\t\t\tFSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n+\t\t\t\t\tif (CACHE.containsKey(wrappedKey)) {\n+\t\t\t\t\t\treturn CACHE.get(wrappedKey);\n+\t\t\t\t\t}\n+\t\t\t\t\t// cache didn\u0027t contain the file system. instantiate it:\n \n-\t\t\tClass\u003c? extends FileSystem\u003e fsClass;\n-\t\t\ttry {\n-\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n-\t\t\t} catch (ClassNotFoundException e1) {\n-\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n-\t\t\t}\n+\t\t\t\t\t// by now we know that the HadoopFileSystem wrapper can wrap the file system.\n+\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n+\t\t\t\t\tfs.initialize(uri);\n+\t\t\t\t\tSystem.out.println(\"Initializing new instance of wrapper for \"+wrapperClass);\n+\t\t\t\t\tCACHE.put(wrappedKey, fs);\n \n-\t\t\ttry {\n-\t\t\t\tfs \u003d fsClass.newInstance();\n-\t\t\t}\n-\t\t\tcatch (InstantiationException e) {\n-\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n-\t\t\t}\n-\t\t\tcatch (IllegalAccessException e) {\n-\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n-\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// we can not read from this file system.\n+\t\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n+\t\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// we end up here if we have a file system with build-in flink support.\n+\t\t\t\tString fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n+\t\t\t\tif(fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n+\t\t\t\t\tfs \u003d instantiateHadoopFileSystemWrapper(null);\n+\t\t\t\t} else {\n+\t\t\t\t\tfs \u003d instantiateFileSystem(fsClass);\n+\t\t\t\t}\n+\t\t\t\tSystem.out.println(\"Initializing new instance of native class for \"+fsClass);\n+\t\t\t\t// Initialize new file system object\n+\t\t\t\tfs.initialize(uri);\n \n-\t\t\t// Initialize new file system object\n-\t\t\tfs.initialize(uri);\n-\n-\t\t\t// Add new file system object to cache\n-\t\t\tCACHE.put(key, fs);\n+\t\t\t\t// Add new file system object to cache\n+\t\t\t\tCACHE.put(key, fs);\n+\t\t\t}\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbe54ac09154dd3e60870b0d26085e2e2ee564af": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1270] [APIs] FS.get() supports relative paths\n\nThis closes #224\n",
      "commitDate": "2014-11-27, 12:18 p.m.",
      "commitName": "bbe54ac09154dd3e60870b0d26085e2e2ee564af",
      "commitAuthor": "zentol",
      "commitDateOld": "2014-11-20, 6:17 a.m.",
      "commitNameOld": "4203bf99ddd009b72681ba0dc554cabd47e1c85c",
      "commitAuthorOld": "Suneel Marthi",
      "daysBetweenCommits": 7.25,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\t\t\t\t\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 190,
      "functionName": "get",
      "diff": "@@ -1,63 +1,66 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n-\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \"\n-\t\t\t\t\t\t\t+ \" File URIs need to specify aboslute file paths.\");\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\turi \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+\t\t\t\t\t} catch (URISyntaxException ex) {\n+\t\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n+\t\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4203bf99ddd009b72681ba0dc554cabd47e1c85c": {
      "type": "Ybodychange",
      "commitMessage": "Minor code clean up\n\nThis closes #221.\n",
      "commitDate": "2014-11-20, 6:17 a.m.",
      "commitName": "4203bf99ddd009b72681ba0dc554cabd47e1c85c",
      "commitAuthor": "Suneel Marthi",
      "commitDateOld": "2014-11-10, 5:59 a.m.",
      "commitNameOld": "81c5b2adee778532634e52b7915ec682bb939a15",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 10.01,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \"\n\t\t\t\t\t\t\t+ \" File URIs need to specify aboslute file paths.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\t\t\t\t\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 189,
      "functionName": "get",
      "diff": "@@ -1,63 +1,63 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n \t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \"\n \t\t\t\t\t\t\t+ \" File URIs need to specify aboslute file paths.\");\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n \t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n \t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n \t\t\t\t\n \t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n \t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n \t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t}\n \n-\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n+\t\t\tClass\u003c? extends FileSystem\u003e fsClass;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a": {
      "type": "Ybodychange",
      "commitMessage": "Improve error messages in case of invalid file paths or URIs\n\nThis closes #170\n",
      "commitDate": "2014-11-03, 11:10 a.m.",
      "commitName": "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2014-09-23, 7:59 a.m.",
      "commitNameOld": "b904b0041cf97b2c6181b1985afc457ed01cf626",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 41.17,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \"\n\t\t\t\t\t\t\t+ \" File URIs need to specify aboslute file paths.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n\t\t\t\t\n\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 200,
      "functionName": "get",
      "diff": "@@ -1,56 +1,63 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \"\n-\t\t\t\t\t\t\t+ \"Failed for \" + uri.toString() + \".\");\n+\t\t\t\t\tthrow new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \"\n+\t\t\t\t\t\t\t+ \" File URIs need to specify aboslute file paths.\");\n \t\t\t\t}\n \t\t\t}\n+\t\t\t\n+\t\t\tif (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n+\t\t\t\tString supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n+\t\t\t\t\n+\t\t\t\tthrow new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\"\n+\t\t\t\t\t\t+ uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n+\t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n-\t\t\t\t+ \". Failed for \" + uri.toString() + \".\");\n+\t\t\t\t\t\t+ \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8563d511da8ab8ac0e1362775f11aef7b67375be": {
      "type": "Yfilerename",
      "commitMessage": "Rename POMs, scripts, quickstarts and other minor renames\n",
      "commitDate": "2014-07-10, 4:35 p.m.",
      "commitName": "8563d511da8ab8ac0e1362775f11aef7b67375be",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014-07-10, 10:46 a.m.",
      "commitNameOld": "5f011547378ad03c033770503c6dcfd6b64e9647",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \"\n\t\t\t\t\t\t\t+ \"Failed for \" + uri.toString() + \".\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t+ \". Failed for \" + uri.toString() + \".\");\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 191,
      "functionName": "get",
      "diff": "",
      "extendedDetails": {
        "oldPath": "stratosphere-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
        "newPath": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java"
      }
    },
    "24eb47ac86299920aa137d5b6394a248ff58d19e": {
      "type": "Ymovefromfile",
      "commitMessage": "Renaming part 2 (core and java api)\n",
      "commitDate": "2014-07-09, 1:14 p.m.",
      "commitName": "24eb47ac86299920aa137d5b6394a248ff58d19e",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2014-07-09, 10:08 a.m.",
      "commitNameOld": "6d9a40d83c3e339c4e820a6b3632fc85ebcbc3de",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \"\n\t\t\t\t\t\t\t+ \"Failed for \" + uri.toString() + \".\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t+ \". Failed for \" + uri.toString() + \".\");\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "stratosphere-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 191,
      "functionName": "get",
      "diff": "",
      "extendedDetails": {
        "oldPath": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
        "newPath": "stratosphere-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
        "oldMethodName": "get",
        "newMethodName": "get"
      }
    },
    "d784bf9467bbaf8ffb37621c13fa30dfbb98e4d8": {
      "type": "Ybodychange",
      "commitMessage": "FS.get(): Add URI causing exception to message.\n",
      "commitDate": "2014-06-12, 5:07 p.m.",
      "commitName": "d784bf9467bbaf8ffb37621c13fa30dfbb98e4d8",
      "commitAuthor": "zentol",
      "commitDateOld": "2014-03-23, 8:27 a.m.",
      "commitNameOld": "a65ee8f600d16596f6193af444265de515ec80c4",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 81.36,
      "commitsBetweenForRepo": 373,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \"\n\t\t\t\t\t\t\t+ \"Failed for \" + uri.toString() + \".\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n\t\t\t\t+ \". Failed for \" + uri.toString() + \".\");\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
      "functionStartLine": 191,
      "functionName": "get",
      "diff": "@@ -1,54 +1,56 @@\n \tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\ttry {\n \t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n \t\t\t\t}\n \t\t\t\tcatch (URISyntaxException e) {\n \t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n-\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n+\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \"\n+\t\t\t\t\t\t\t+ \"Failed for \" + uri.toString() + \".\");\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n-\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n+\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme()\n+\t\t\t\t+ \". Failed for \" + uri.toString() + \".\");\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0038c9d0773e90676b1ee2a8a94dcf764f023e22": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "Fix the external packaged program test after merge with the new java api\nRelax generic bound in tuple type infor to work around bug in Java 6 compiler type inference.\nLocal file system is used by default when URI is missing\nRemoved final declaration from Tuple classes to allow inheritance (Fabian Hueske)\nFix in TupleType comparator generation (Fabian Hueske)\nCogroup Implementation (Markus Holzemer)\nAdded missing Apache license header (Fabian Hueske)\nInitial commit for join operator for new Java API (Fabian Hueske)\nAdded cross operator to new Java API (Fabian Hueske)\nFirst part of CoGroup (Markus Holzemer)\nAdded join example prog and fix in join operator (Fabian Hueske)\nUnified operator translation (Fabian Hueske)\nAdd Cross Prog for API implementation (Fabian Hueske)\nImplement CsvInputFormat for new Java API, including tests.\nFix logging messages in data source and sink tasks.\nFix error in data source task with new InputFormat siignatures\nAdd group reduce to new java api.\nFinaliz Key Extractors for new Java API\nFix bug in intitialization of broadcast serializers.\nAdded first set of comparators.\nAdded generic type serialization via avro\nAdd first stab at KeyExtractor implementation (Aljoscha Krettek)\nAdd trivial parts of serialization (Aljoscha Krettek)\nConnected serializers to the typeutils.\nFix tests to run with the NEW-API changes (Aljoscha Krettek)\nScala Post pass got confused because of ReduceNode renaming. (Aljoscha Krettek)\nSome input format mishaps. (Aljoscha Krettek)\nFirst set of new simple type serializers.\nConnect first paths of new Java API to optimizer.\nAdd name() to Operator plus some other stuff (Aljoscha Krettek)\nClean up moved annotations\nAdd CoGroup, Cross, and Union operators (Aljoscha Krettek)\nMake reduce operators children of UdfOperator (Aljoscha Krettek)\nAdjust input formats to new signature\nAdjusted, extended, and tested parsers for new java api compatibility.\nFirst draft of new java api.\nRemoving dependency to Combinable annotation. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API. (Jesus Camacho Rodriguez)\nMoving all annotations from the core to the Java API package. Created SemanticProperties in the core to store properties inferred currently from Java annotations. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API (Jesus Camacho Rodriguez)\n",
      "commitDate": "2014-03-06, 5:45 p.m.",
      "commitName": "0038c9d0773e90676b1ee2a8a94dcf764f023e22",
      "commitAuthor": "StephanEwen",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fix the external packaged program test after merge with the new java api\nRelax generic bound in tuple type infor to work around bug in Java 6 compiler type inference.\nLocal file system is used by default when URI is missing\nRemoved final declaration from Tuple classes to allow inheritance (Fabian Hueske)\nFix in TupleType comparator generation (Fabian Hueske)\nCogroup Implementation (Markus Holzemer)\nAdded missing Apache license header (Fabian Hueske)\nInitial commit for join operator for new Java API (Fabian Hueske)\nAdded cross operator to new Java API (Fabian Hueske)\nFirst part of CoGroup (Markus Holzemer)\nAdded join example prog and fix in join operator (Fabian Hueske)\nUnified operator translation (Fabian Hueske)\nAdd Cross Prog for API implementation (Fabian Hueske)\nImplement CsvInputFormat for new Java API, including tests.\nFix logging messages in data source and sink tasks.\nFix error in data source task with new InputFormat siignatures\nAdd group reduce to new java api.\nFinaliz Key Extractors for new Java API\nFix bug in intitialization of broadcast serializers.\nAdded first set of comparators.\nAdded generic type serialization via avro\nAdd first stab at KeyExtractor implementation (Aljoscha Krettek)\nAdd trivial parts of serialization (Aljoscha Krettek)\nConnected serializers to the typeutils.\nFix tests to run with the NEW-API changes (Aljoscha Krettek)\nScala Post pass got confused because of ReduceNode renaming. (Aljoscha Krettek)\nSome input format mishaps. (Aljoscha Krettek)\nFirst set of new simple type serializers.\nConnect first paths of new Java API to optimizer.\nAdd name() to Operator plus some other stuff (Aljoscha Krettek)\nClean up moved annotations\nAdd CoGroup, Cross, and Union operators (Aljoscha Krettek)\nMake reduce operators children of UdfOperator (Aljoscha Krettek)\nAdjust input formats to new signature\nAdjusted, extended, and tested parsers for new java api compatibility.\nFirst draft of new java api.\nRemoving dependency to Combinable annotation. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API. (Jesus Camacho Rodriguez)\nMoving all annotations from the core to the Java API package. Created SemanticProperties in the core to store properties inferred currently from Java annotations. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API (Jesus Camacho Rodriguez)\n",
          "commitDate": "2014-03-06, 5:45 p.m.",
          "commitName": "0038c9d0773e90676b1ee2a8a94dcf764f023e22",
          "commitAuthor": "StephanEwen",
          "commitDateOld": "2014-03-02, 8:52 p.m.",
          "commitNameOld": "3a6344356a185be43f9be4b33702f97827f9ff96",
          "commitAuthorOld": "StephanEwen",
          "daysBetweenCommits": 3.87,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
          "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
          "functionStartLine": 191,
          "functionName": "get",
          "diff": "@@ -1,48 +1,54 @@\n-\tpublic static FileSystem get(final URI uri) throws IOException {\n+\tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n-\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n+\t\t\t\ttry {\n+\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n+\t\t\t\t}\n+\t\t\t\tcatch (URISyntaxException e) {\n+\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n+\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Fix the external packaged program test after merge with the new java api\nRelax generic bound in tuple type infor to work around bug in Java 6 compiler type inference.\nLocal file system is used by default when URI is missing\nRemoved final declaration from Tuple classes to allow inheritance (Fabian Hueske)\nFix in TupleType comparator generation (Fabian Hueske)\nCogroup Implementation (Markus Holzemer)\nAdded missing Apache license header (Fabian Hueske)\nInitial commit for join operator for new Java API (Fabian Hueske)\nAdded cross operator to new Java API (Fabian Hueske)\nFirst part of CoGroup (Markus Holzemer)\nAdded join example prog and fix in join operator (Fabian Hueske)\nUnified operator translation (Fabian Hueske)\nAdd Cross Prog for API implementation (Fabian Hueske)\nImplement CsvInputFormat for new Java API, including tests.\nFix logging messages in data source and sink tasks.\nFix error in data source task with new InputFormat siignatures\nAdd group reduce to new java api.\nFinaliz Key Extractors for new Java API\nFix bug in intitialization of broadcast serializers.\nAdded first set of comparators.\nAdded generic type serialization via avro\nAdd first stab at KeyExtractor implementation (Aljoscha Krettek)\nAdd trivial parts of serialization (Aljoscha Krettek)\nConnected serializers to the typeutils.\nFix tests to run with the NEW-API changes (Aljoscha Krettek)\nScala Post pass got confused because of ReduceNode renaming. (Aljoscha Krettek)\nSome input format mishaps. (Aljoscha Krettek)\nFirst set of new simple type serializers.\nConnect first paths of new Java API to optimizer.\nAdd name() to Operator plus some other stuff (Aljoscha Krettek)\nClean up moved annotations\nAdd CoGroup, Cross, and Union operators (Aljoscha Krettek)\nMake reduce operators children of UdfOperator (Aljoscha Krettek)\nAdjust input formats to new signature\nAdjusted, extended, and tested parsers for new java api compatibility.\nFirst draft of new java api.\nRemoving dependency to Combinable annotation. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API. (Jesus Camacho Rodriguez)\nMoving all annotations from the core to the Java API package. Created SemanticProperties in the core to store properties inferred currently from Java annotations. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API (Jesus Camacho Rodriguez)\n",
          "commitDate": "2014-03-06, 5:45 p.m.",
          "commitName": "0038c9d0773e90676b1ee2a8a94dcf764f023e22",
          "commitAuthor": "StephanEwen",
          "commitDateOld": "2014-03-02, 8:52 p.m.",
          "commitNameOld": "3a6344356a185be43f9be4b33702f97827f9ff96",
          "commitAuthorOld": "StephanEwen",
          "daysBetweenCommits": 3.87,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\ttry {\n\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException e) {\n\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
          "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
          "functionStartLine": 191,
          "functionName": "get",
          "diff": "@@ -1,48 +1,54 @@\n-\tpublic static FileSystem get(final URI uri) throws IOException {\n+\tpublic static FileSystem get(URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n-\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n+\t\t\t\ttry {\n+\t\t\t\t\turi \u003d new URI(\"file\", null, uri.getPath(), null);\n+\t\t\t\t}\n+\t\t\t\tcatch (URISyntaxException e) {\n+\t\t\t\t\t// we tried to repair it, but could not. report the scheme error\n+\t\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t}\n \t\t\tcatch (InstantiationException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI(modifiers-final)]",
            "newValue": "[uri-URI]"
          }
        }
      ]
    },
    "3a6344356a185be43f9be4b33702f97827f9ff96": {
      "type": "Ybodychange",
      "commitMessage": "Default mode for output formats is not to overwrite existing files.\nGlobally configurable default modes for overwrite / output directory behavior.\nConfigurable behavior for FileOutputFormat through regular parameters, rather than configuration.\n",
      "commitDate": "2014-03-02, 8:52 p.m.",
      "commitName": "3a6344356a185be43f9be4b33702f97827f9ff96",
      "commitAuthor": "StephanEwen",
      "commitDateOld": "2014-01-30, 4:34 a.m.",
      "commitNameOld": "31bae021b7639e2cba52c50df650cdd8f8677c08",
      "commitAuthorOld": "Fabian Hueske",
      "daysBetweenCommits": 31.68,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(final URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
      "functionStartLine": 191,
      "functionName": "get",
      "diff": "@@ -1,46 +1,48 @@\n \tpublic static FileSystem get(final URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n-\t\t\t} catch (InstantiationException e) {\n-\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n-\t\t\t} catch (IllegalAccessException e) {\n-\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n+\t\t\t}\n+\t\t\tcatch (InstantiationException e) {\n+\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n+\t\t\t}\n+\t\t\tcatch (IllegalAccessException e) {\n+\t\t\t\tthrow new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc6b5168684ca298d8b025c839d9a4e48e470790": {
      "type": "Yfilerename",
      "commitMessage": "Renamed packages in stratosphere-core.\n",
      "commitDate": "2013-12-13, 9:09 p.m.",
      "commitName": "fc6b5168684ca298d8b025c839d9a4e48e470790",
      "commitAuthor": "StephanEwen",
      "commitDateOld": "2013-12-13, 5:24 p.m.",
      "commitNameOld": "eb8c49ebdff229c711cbd1e6be549d69667961a5",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(final URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
      "functionStartLine": 185,
      "functionName": "get",
      "diff": "",
      "extendedDetails": {
        "oldPath": "stratosphere-core/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
        "newPath": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java"
      }
    },
    "33cb2ca9898809d2fc90765996ea56bbea458e59": {
      "type": "Yfilerename",
      "commitMessage": "Reorganized basic project structures. No renamings yet.\n",
      "commitDate": "2013-12-13, 2:52 p.m.",
      "commitName": "33cb2ca9898809d2fc90765996ea56bbea458e59",
      "commitAuthor": "StephanEwen",
      "commitDateOld": "2013-12-13, 12:11 p.m.",
      "commitNameOld": "0ad1dcc7dbd432d01d3cb4ed2db86b79534c68ad",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(final URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "stratosphere-core/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 188,
      "functionName": "get",
      "diff": "",
      "extendedDetails": {
        "oldPath": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
        "newPath": "stratosphere-core/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java"
      }
    },
    "88d7305a5267aac598949519275123208195daf7": {
      "type": "Ybodychange",
      "commitMessage": "added test case (without fix) for a pact compiler bug with ALL_GROUP-reducer.\n",
      "commitDate": "2013-08-16, 12:33 a.m.",
      "commitName": "88d7305a5267aac598949519275123208195daf7",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2012-02-26, 10:56 a.m.",
      "commitNameOld": "c1241753eb74b0fbb2b84ce76b6ae5be30477118",
      "commitAuthorOld": "Daniel Warneke",
      "daysBetweenCommits": 536.53,
      "commitsBetweenForRepo": 1129,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(final URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 186,
      "functionName": "get",
      "diff": "@@ -1,46 +1,46 @@\n \tpublic static FileSystem get(final URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n-\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null\");\n+\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t} catch (InstantiationException e) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n \t\t\t} catch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0c21f4c470812d699ec141210ad5119b3450de3": {
      "type": "Ybodychange",
      "commitMessage": "Improved code style\n",
      "commitDate": "2011-08-17, 10:26 a.m.",
      "commitName": "d0c21f4c470812d699ec141210ad5119b3450de3",
      "commitAuthor": "Daniel Warneke",
      "commitDateOld": "2011-06-16, 12:26 p.m.",
      "commitNameOld": "b27a112add2f4c221f9bfd8e4e953a750e8d64b3",
      "commitAuthorOld": "Daniel Warneke",
      "daysBetweenCommits": 61.92,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(final URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 186,
      "functionName": "get",
      "diff": "@@ -1,46 +1,46 @@\n \tpublic static FileSystem get(final URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n-\t\tsynchronized (synchronizationObject) {\n+\t\tsynchronized (SYNCHRONIZATION_OBJECT) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\tthrow new IOException(\"FileSystem: Scheme is null\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t} catch (InstantiationException e) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n \t\t\t} catch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b27a112add2f4c221f9bfd8e4e953a750e8d64b3": {
      "type": "Yparametermetachange",
      "commitMessage": "Implemented S3DataOutputStream featuring HTTP multi part upload\n",
      "commitDate": "2011-06-16, 12:26 p.m.",
      "commitName": "b27a112add2f4c221f9bfd8e4e953a750e8d64b3",
      "commitAuthor": "Daniel Warneke",
      "commitDateOld": "2011-06-13, 12:59 p.m.",
      "commitNameOld": "a4c9876ef72888f99de798314f64cfd2450e43b4",
      "commitAuthorOld": "Daniel Warneke",
      "daysBetweenCommits": 2.98,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic static FileSystem get(final URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (synchronizationObject) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 186,
      "functionName": "get",
      "diff": "@@ -1,46 +1,46 @@\n-\tpublic static FileSystem get(URI uri) throws IOException {\n+\tpublic static FileSystem get(final URI uri) throws IOException {\n \n \t\tFileSystem fs \u003d null;\n \n \t\tsynchronized (synchronizationObject) {\n \n \t\t\tif (uri.getScheme() \u003d\u003d null) {\n \t\t\t\tthrow new IOException(\"FileSystem: Scheme is null\");\n \t\t\t}\n \n \t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n \n \t\t\t// See if there is a file system object in the cache\n \t\t\tif (CACHE.containsKey(key)) {\n \t\t\t\treturn CACHE.get(key);\n \t\t\t}\n \n \t\t\t// Try to create a new file system\n \t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n \t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n \t\t\t}\n \n \t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n \t\t\ttry {\n \t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n \t\t\t} catch (ClassNotFoundException e1) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n \t\t\t}\n \n \t\t\ttry {\n \t\t\t\tfs \u003d fsClass.newInstance();\n \t\t\t} catch (InstantiationException e) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n \t\t\t} catch (IllegalAccessException e) {\n \t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n \t\t\t}\n \n \t\t\t// Initialize new file system object\n \t\t\tfs.initialize(uri);\n \n \t\t\t// Add new file system object to cache\n \t\t\tCACHE.put(key, fs);\n \t\t}\n \n \t\treturn fs;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[uri-URI]",
        "newValue": "[uri-URI(modifiers-final)]"
      }
    },
    "75e67a701cbabe5577967037c0e865d1c2e9a25b": {
      "type": "Yintroduced",
      "commitMessage": "Initial checkin.\n",
      "commitDate": "2010-12-16, 1:09 p.m.",
      "commitName": "75e67a701cbabe5577967037c0e865d1c2e9a25b",
      "commitAuthor": "sewen",
      "diff": "@@ -0,0 +1,46 @@\n+\tpublic static FileSystem get(URI uri) throws IOException {\n+\n+\t\tFileSystem fs \u003d null;\n+\n+\t\tsynchronized (synchronizationObject) {\n+\n+\t\t\tif (uri.getScheme() \u003d\u003d null) {\n+\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null\");\n+\t\t\t}\n+\n+\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n+\n+\t\t\t// See if there is a file system object in the cache\n+\t\t\tif (CACHE.containsKey(key)) {\n+\t\t\t\treturn CACHE.get(key);\n+\t\t\t}\n+\n+\t\t\t// Try to create a new file system\n+\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n+\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n+\t\t\t}\n+\n+\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n+\t\t\ttry {\n+\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n+\t\t\t} catch (ClassNotFoundException e1) {\n+\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tfs \u003d fsClass.newInstance();\n+\t\t\t} catch (InstantiationException e) {\n+\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n+\t\t\t}\n+\n+\t\t\t// Initialize new file system object\n+\t\t\tfs.initialize(uri);\n+\n+\t\t\t// Add new file system object to cache\n+\t\t\tCACHE.put(key, fs);\n+\t\t}\n+\n+\t\treturn fs;\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic static FileSystem get(URI uri) throws IOException {\n\n\t\tFileSystem fs \u003d null;\n\n\t\tsynchronized (synchronizationObject) {\n\n\t\t\tif (uri.getScheme() \u003d\u003d null) {\n\t\t\t\tthrow new IOException(\"FileSystem: Scheme is null\");\n\t\t\t}\n\n\t\t\tfinal FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n\n\t\t\t// See if there is a file system object in the cache\n\t\t\tif (CACHE.containsKey(key)) {\n\t\t\t\treturn CACHE.get(key);\n\t\t\t}\n\n\t\t\t// Try to create a new file system\n\t\t\tif (!FSDIRECTORY.containsKey(uri.getScheme())) {\n\t\t\t\tthrow new IOException(\"No file system found with scheme \" + uri.getScheme());\n\t\t\t}\n\n\t\t\tClass\u003c? extends FileSystem\u003e fsClass \u003d null;\n\t\t\ttry {\n\t\t\t\tfsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e1));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfs \u003d fsClass.newInstance();\n\t\t\t} catch (InstantiationException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IOException(StringUtils.stringifyException(e));\n\t\t\t}\n\n\t\t\t// Initialize new file system object\n\t\t\tfs.initialize(uri);\n\n\t\t\t// Add new file system object to cache\n\t\t\tCACHE.put(key, fs);\n\t\t}\n\n\t\treturn fs;\n\t}",
      "path": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 158,
      "functionName": "get"
    }
  }
}