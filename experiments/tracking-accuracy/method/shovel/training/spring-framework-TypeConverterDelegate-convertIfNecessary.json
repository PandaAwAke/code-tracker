{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "H:\\Projects\\spring-projects\\spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "TypeConverterDelegate.java",
  "functionName": "convertIfNecessary",
  "functionId": "convertIfNecessary___propertyName-String(annotations-@Nullable)__oldValue-Object(annotations-@Nullable)__newValue-Object(annotations-@Nullable)__requiredType-Class__T__(annotations-@Nullable)__typeDescriptor-TypeDescriptor(annotations-@Nullable)",
  "sourceFilePath": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
  "functionStartLine": 152,
  "functionEndLine": 313,
  "numCommitsSeen": 88,
  "timeTaken": 6737,
  "changeHistory": [
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "1f28825f9da63a13aaf8940aadedcf81358dc506",
    "87598f48e41d483745aba56cbf4e998c6f6d680c",
    "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
    "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37",
    "c4c941c43fc23f58503c7b687fd1469d4a27c777",
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
    "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
    "02da2e85ee0e58202b90d11c126e6050abe184b4",
    "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3",
    "0dc6082b01606c3c996b728541467ba5104b747f",
    "59002f245623d758765b72d598cd78c326c6f5fa",
    "c9aace4da215330c1aa552fa1dcdd79748249774",
    "ff7dcec5f7d2b54324476bd617af74de9cbd56ec",
    "6bce09831060430b00e6ed93785c7d40ac8529a8",
    "8e754e9065b5703f93909f480933488a2b180429",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79",
    "86bef9030fa4e026107db74cd9eef288beb1beca",
    "84be348cb0ac99896674170dc9f99021b43ba9ee",
    "f288060ad8f0d007f1541213130d006729b9ec40",
    "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
    "8c6890605a7080e2744be3f3994757cc72e394b0",
    "2127b160512911e5f65a4e304f0b57826710a91d",
    "c306afed63e439ee133872a49380d76064bd2638",
    "c84cccf06dad4e3f11cd529ab16a5655bf723820",
    "6f146737f475828b6d765784017773378c2c4922",
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
    "cbed1c1b4b5fd74c9cd201890f619a7079804d3f",
    "dc99df297274d8c1291cdaed5d9dd508910584d3",
    "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
    "5f9b4443194d3aa3948d76956897c0a1d918d546",
    "ac490114aee005a66eeb0fba6c3c853552fc6a94",
    "84447cdf9493a5f6ead3450627d8938af1b7ac5f",
    "45c542e51e9b01526a97a1644aebfe1e94a2342f",
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
    "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
    "a86a698e5b3394c9b6721a784c8fe251611ff16b",
    "9a48f3f3a896cad821e5847a93d91c997905e325",
    "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
    "fee838a65e87f5da4b65b04ea5101681d6308104",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
    "0297116542a3ce33d19a6a81b8240097081376c5",
    "bf7a947559d8f9918cc738780bf04caf8ea46962",
    "29657105da133995b0b2277b82c75d1df2931b64",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3"
  ],
  "changeHistoryShort": {
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ymultichange(Ybodychange,Yparametermetachange)",
    "1f28825f9da63a13aaf8940aadedcf81358dc506": "Yparametermetachange",
    "87598f48e41d483745aba56cbf4e998c6f6d680c": "Yparametermetachange",
    "dc080cb1be4c35398d1d995c3bb8025ccfde6dea": "Ybodychange",
    "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37": "Ybodychange",
    "c4c941c43fc23f58503c7b687fd1469d4a27c777": "Ybodychange",
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": "Ybodychange",
    "6418b54f81a9e56242fb78fda4bf95e7b3d4c572": "Ybodychange",
    "02da2e85ee0e58202b90d11c126e6050abe184b4": "Ybodychange",
    "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3": "Ybodychange",
    "0dc6082b01606c3c996b728541467ba5104b747f": "Ybodychange",
    "59002f245623d758765b72d598cd78c326c6f5fa": "Ybodychange",
    "c9aace4da215330c1aa552fa1dcdd79748249774": "Ybodychange",
    "ff7dcec5f7d2b54324476bd617af74de9cbd56ec": "Ybodychange",
    "6bce09831060430b00e6ed93785c7d40ac8529a8": "Ybodychange",
    "8e754e9065b5703f93909f480933488a2b180429": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79": "Ybodychange",
    "86bef9030fa4e026107db74cd9eef288beb1beca": "Ybodychange",
    "84be348cb0ac99896674170dc9f99021b43ba9ee": "Ybodychange",
    "f288060ad8f0d007f1541213130d006729b9ec40": "Ybodychange",
    "5e3a5202fbd17cd30607ca7bb5360c9db8197e75": "Ybodychange",
    "8c6890605a7080e2744be3f3994757cc72e394b0": "Ybodychange",
    "2127b160512911e5f65a4e304f0b57826710a91d": "Ybodychange",
    "c306afed63e439ee133872a49380d76064bd2638": "Ybodychange",
    "c84cccf06dad4e3f11cd529ab16a5655bf723820": "Ybodychange",
    "6f146737f475828b6d765784017773378c2c4922": "Ybodychange",
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": "Ybodychange",
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": "Ymodifierchange",
    "cbed1c1b4b5fd74c9cd201890f619a7079804d3f": "Ybodychange",
    "dc99df297274d8c1291cdaed5d9dd508910584d3": "Ybodychange",
    "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde": "Ybodychange",
    "5f9b4443194d3aa3948d76956897c0a1d918d546": "Ybodychange",
    "ac490114aee005a66eeb0fba6c3c853552fc6a94": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "84447cdf9493a5f6ead3450627d8938af1b7ac5f": "Ybodychange",
    "45c542e51e9b01526a97a1644aebfe1e94a2342f": "Ybodychange",
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d": "Ybodychange",
    "1480202aa37d7edaf7f070a2bf45cd3a1016eea7": "Ybodychange",
    "a86a698e5b3394c9b6721a784c8fe251611ff16b": "Ybodychange",
    "9a48f3f3a896cad821e5847a93d91c997905e325": "Ybodychange",
    "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f": "Ybodychange",
    "fee838a65e87f5da4b65b04ea5101681d6308104": "Ybodychange",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": "Ybodychange",
    "0297116542a3ce33d19a6a81b8240097081376c5": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "bf7a947559d8f9918cc738780bf04caf8ea46962": "Ybodychange",
    "29657105da133995b0b2277b82c75d1df2931b64": "Ybodychange",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": "Ybodychange",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017-06-07, 8:19 a.m.",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
          "commitDate": "2017-06-07, 8:19 a.m.",
          "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017-05-31, 3:42 p.m.",
          "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 6.69,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc !\u003d null) {\n\t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n\t\t\t\t\tconvertedValue \u003d Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
          "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 151,
          "functionName": "convertIfNecessary",
          "diff": "@@ -1,162 +1,162 @@\n-\tpublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue,\n-\t\t\t@Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+\tpublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n+\t\t\t@Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc !\u003d null) {\n \t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class \u003d\u003d requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n \t\t\t\t\tconvertedValue \u003d Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n-\t\t\t\telse if (conversionService !\u003d null) {\n+\t\t\t\telse if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn\u0027t produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
          "commitDate": "2017-06-07, 8:19 a.m.",
          "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017-05-31, 3:42 p.m.",
          "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 6.69,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n\t\t\t@Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc !\u003d null) {\n\t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n\t\t\t\t\tconvertedValue \u003d Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
          "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 151,
          "functionName": "convertIfNecessary",
          "diff": "@@ -1,162 +1,162 @@\n-\tpublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue,\n-\t\t\t@Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+\tpublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,\n+\t\t\t@Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc !\u003d null) {\n \t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class \u003d\u003d requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n \t\t\t\t\tconvertedValue \u003d Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n-\t\t\t\telse if (conversionService !\u003d null) {\n+\t\t\t\telse if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn\u0027t produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor]",
            "newValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object(annotations-@Nullable), requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor(annotations-@Nullable)]"
          }
        }
      ]
    },
    "1f28825f9da63a13aaf8940aadedcf81358dc506": {
      "type": "Yparametermetachange",
      "commitMessage": "Add more @Nullable parameters based on null usage\n\nIssue: SPR-15540\n",
      "commitDate": "2017-05-31, 3:42 p.m.",
      "commitName": "1f28825f9da63a13aaf8940aadedcf81358dc506",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2017-05-27, 2:57 a.m.",
      "commitNameOld": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 4.53,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue,\n\t\t\t@Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc !\u003d null) {\n\t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n\t\t\t\t\tconvertedValue \u003d Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 148,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,162 +1,162 @@\n-\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue,\n+\tpublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue,\n \t\t\t@Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc !\u003d null) {\n \t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class \u003d\u003d requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n \t\t\t\t\tconvertedValue \u003d Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService !\u003d null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn\u0027t produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[propertyName-String, oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor]",
        "newValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor]"
      }
    },
    "87598f48e41d483745aba56cbf4e998c6f6d680c": {
      "type": "Yparametermetachange",
      "commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
      "commitDate": "2017-05-27, 2:57 a.m.",
      "commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2016-10-28, 5:39 p.m.",
      "commitNameOld": "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 210.39,
      "commitsBetweenForRepo": 1205,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue,\n\t\t\t@Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc !\u003d null) {\n\t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n\t\t\t\t\tconvertedValue \u003d Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 148,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,162 +1,162 @@\n-\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n-\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue,\n+\t\t\t@Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc !\u003d null) {\n \t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class \u003d\u003d requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n \t\t\t\t\tconvertedValue \u003d Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService !\u003d null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn\u0027t produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class\u003cT\u003e, typeDescriptor-TypeDescriptor]",
        "newValue": "[propertyName-String, oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor]"
      }
    },
    "dc080cb1be4c35398d1d995c3bb8025ccfde6dea": {
      "type": "Ybodychange",
      "commitMessage": "Revised NoSuchBeanDefinitionException message and ResolvableType handling\n\nIncludes consistent quoting of qualified type names in related classes.\n\nIssue: SPR-14831\n",
      "commitDate": "2016-10-28, 5:39 p.m.",
      "commitName": "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-07-19, 1:21 p.m.",
      "commitNameOld": "aaac199e8bc1e037883f9fa8063828a82142d608",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 101.18,
      "commitsBetweenForRepo": 522,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc !\u003d null) {\n\t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n\t\t\t\t\tconvertedValue \u003d Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 147,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,162 +1,162 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc !\u003d null) {\n \t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class \u003d\u003d requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n \t\t\t\t\tconvertedValue \u003d Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService !\u003d null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn\u0027t produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n-\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n-\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n+\t\t\t\tmsg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n+\t\t\t\tmsg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n-\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n-\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n+\t\t\t\t\t\t\t\"] returned inappropriate value of type \u0027\").append(\n+\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37": {
      "type": "Ybodychange",
      "commitMessage": "Avoid defensive checks against Java 8 API (java.util.Optional etc)\n\nThis commit also fixes broken javadoc links and code references.\n\nIssue: SPR-13188\n",
      "commitDate": "2016-07-04, 8:09 p.m.",
      "commitName": "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-06-30, 8:02 a.m.",
      "commitNameOld": "c4c941c43fc23f58503c7b687fd1469d4a27c777",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 4.5,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc !\u003d null) {\n\t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n\t\t\t\t\tconvertedValue \u003d Optional.empty();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 146,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,162 +1,162 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementTypeDesc !\u003d null) {\n \t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n \t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class \u003d\u003d requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n-\t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n-\t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n+\t\t\t\tif (requiredType \u003d\u003d Optional.class) {\n+\t\t\t\t\tconvertedValue \u003d Optional.empty();\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService !\u003d null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn\u0027t produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c4c941c43fc23f58503c7b687fd1469d4a27c777": {
      "type": "Ybodychange",
      "commitMessage": "Convert comma-separated string into list of classes analogous to existing support for class array\n\nIssue: SPR-14415\n",
      "commitDate": "2016-06-30, 8:02 a.m.",
      "commitName": "c4c941c43fc23f58503c7b687fd1469d4a27c777",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-08-31, 11:20 a.m.",
      "commitNameOld": "d4a23b81e9e49a6e9cc871d8bb1accc70c6444df",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 303.86,
      "commitsBetweenForRepo": 1195,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementTypeDesc !\u003d null) {\n\t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n\t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n\t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 159,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,158 +1,162 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n-\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n-\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n-\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n-\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+\t\t\tif (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n+\t\t\t\t\tconvertedValue instanceof String) {\n+\t\t\t\tTypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n+\t\t\t\tif (elementTypeDesc !\u003d null) {\n+\t\t\t\t\tClass\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n+\t\t\t\t\tif (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n+\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class \u003d\u003d requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n \t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService !\u003d null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn\u0027t produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": {
      "type": "Ybodychange",
      "commitMessage": "Class identity comparisons wherever possible\n\nIssue: SPR-12926\n",
      "commitDate": "2015-05-20, 8:34 a.m.",
      "commitName": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-05-18, 5:53 p.m.",
      "commitNameOld": "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.61,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n\t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 159,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,158 +1,158 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n-\t\t\t\tif (Object.class.equals(requiredType)) {\n+\t\t\t\tif (Object.class \u003d\u003d requiredType) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n-\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+\t\t\t\tif (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n \t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\t\t\t// Original exception from former ConversionService call above...\n \t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n \t\t\t\telse if (conversionService !\u003d null) {\n \t\t\t\t\t// ConversionService not tried before, probably custom editor found\n \t\t\t\t\t// but editor couldn\u0027t produce the required type...\n \t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (conversionAttemptEx !\u003d null) {\n-\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n+\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n \t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6418b54f81a9e56242fb78fda4bf95e7b3d4c572": {
      "type": "Ybodychange",
      "commitMessage": "DataBinder tries ConversionService if PropertyEditor could not produce required type\n\nIssue: SPR-13042\n",
      "commitDate": "2015-05-18, 5:53 p.m.",
      "commitName": "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-05-12, 4:33 p.m.",
      "commitNameOld": "02da2e85ee0e58202b90d11c126e6050abe184b4",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException conversionAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tconversionAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class.equals(requiredType)) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n\t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\t\t\t// Original exception from former ConversionService call above...\n\t\t\t\t\tthrow conversionAttemptEx;\n\t\t\t\t}\n\t\t\t\telse if (conversionService !\u003d null) {\n\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conversionAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n\t\t\t\tthrow conversionAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 159,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,149 +1,158 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n-\t\tObject convertedValue \u003d newValue;\n-\n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n-\t\tConversionFailedException firstAttemptEx \u003d null;\n+\t\tConversionFailedException conversionAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n-\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n+\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n-\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\ttry {\n-\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n-\t\t\t\t\tfirstAttemptEx \u003d ex;\n+\t\t\t\t\tconversionAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\tObject convertedValue \u003d newValue;\n+\n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n-\t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n+\t\t\t\t\tif (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n \t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n \t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n \t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n-\t\t\t\tif (firstAttemptEx !\u003d null) {\n-\t\t\t\t\tthrow firstAttemptEx;\n+\t\t\t\tif (conversionAttemptEx !\u003d null) {\n+\t\t\t\t\t// Original exception from former ConversionService call above...\n+\t\t\t\t\tthrow conversionAttemptEx;\n \t\t\t\t}\n+\t\t\t\telse if (conversionService !\u003d null) {\n+\t\t\t\t\t// ConversionService not tried before, probably custom editor found\n+\t\t\t\t\t// but editor couldn\u0027t produce the required type...\n+\t\t\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n+\t\t\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+\t\t\t\t\t\treturn (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (firstAttemptEx !\u003d null) {\n+\t\tif (conversionAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n-\t\t\t\tthrow firstAttemptEx;\n+\t\t\t\tthrow conversionAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n-\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n+\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02da2e85ee0e58202b90d11c126e6050abe184b4": {
      "type": "Ybodychange",
      "commitMessage": "DataBinder allows for adding custom Formatters as alternative to PropertyEditors (including per-field formatters)\n\nIncludes a generic FormatterPropertyEditorAdapter plus Number conversion support in TypeConverterDelegate.\n\nIssue: SPR-7773\nIssue: SPR-6069\n",
      "commitDate": "2015-05-12, 4:33 p.m.",
      "commitName": "02da2e85ee0e58202b90d11c126e6050abe184b4",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-07-18, 11:21 a.m.",
      "commitNameOld": "9d6c38bd54fe8931ee73fbb7a076625deb934e28",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 298.22,
      "commitsBetweenForRepo": 1341,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class.equals(requiredType)) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n\t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 159,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,144 +1,149 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n-\t\t\t\tif (requiredType.isArray()) {\n+\t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n+\t\t\t\telse if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n+\t\t\t\t\tconvertedValue \u003d NumberUtils.convertNumberToTargetClass(\n+\t\t\t\t\t\t\t(Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n+\t\t\t\t\tstandardConversion \u003d true;\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// convertedValue \u003d\u003d null\n \t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n \t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3": {
      "type": "Ybodychange",
      "commitMessage": "Defensively check javaUtilOptionalEmpty\n\nIssue: SPR-11888\n",
      "commitDate": "2014-06-19, 3:14 p.m.",
      "commitName": "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-06-16, 2:16 p.m.",
      "commitNameOld": "0dc6082b01606c3c996b728541467ba5104b747f",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 3.04,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class.equals(requiredType)) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// convertedValue \u003d\u003d null\n\t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n\t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 158,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,141 +1,144 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n-\t\t\telse if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n-\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n+\t\t\telse {\n+\t\t\t\t// convertedValue \u003d\u003d null\n+\t\t\t\tif (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n+\t\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0dc6082b01606c3c996b728541467ba5104b747f": {
      "type": "Ybodychange",
      "commitMessage": "Support java.util.Optional for @MVC named value args\n\nAfter this change, java.util.Optional is supported with @RequestParam,\n@RequestHeader, and @MatrixVariable arguments in Java 8. When Optional\nis used the required flag is effectively ignored.\n\nIssue: SPR-11829\n",
      "commitDate": "2014-06-16, 2:16 p.m.",
      "commitName": "0dc6082b01606c3c996b728541467ba5104b747f",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014-04-27, 6:47 p.m.",
      "commitNameOld": "6cb45f714e8d4b6b38501ed6356ced59362d8df2",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 49.81,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class.equals(requiredType)) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 157,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,138 +1,141 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n+\t\t\telse if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n+\t\t\t\tconvertedValue \u003d javaUtilOptionalEmpty;\n+\t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59002f245623d758765b72d598cd78c326c6f5fa": {
      "type": "Ybodychange",
      "commitMessage": "Fix remaining compiler warnings\n\nFix remaining Java compiler warnings, mainly around missing\ngenerics or deprecated code.\n\nAlso add the `-Werror` compiler option to ensure that any future\nwarnings will fail the build.\n\nIssue: SPR-11064\n",
      "commitDate": "2013-11-25, 3:52 p.m.",
      "commitName": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-10-18, 8:19 p.m.",
      "commitNameOld": "c9aace4da215330c1aa552fa1dcdd79748249774",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 37.86,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class.equals(requiredType)) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,138 +1,138 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (Object.class.equals(requiredType)) {\n \t\t\t\t\treturn (T) convertedValue;\n \t\t\t\t}\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n-\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n+\t\t\t\t\t\t\t(Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n-\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n+\t\t\t\t\t\t\t(Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n-\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n+\t\t\t\t\t\t\tConstructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n+\t\t\t\t\t\t\treturn BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9aace4da215330c1aa552fa1dcdd79748249774": {
      "type": "Ybodychange",
      "commitMessage": "Skip convert to Object from TypeConverterDelegate\n\nUpdate TypeConverterDelegate to bypass conversion when the target type\nis Object.class. Prior to this commit converting a single element array\nto an Object would result in the element being returned, rather than\nthe array itself.\n\nIssue: SPR-10996\n",
      "commitDate": "2013-10-18, 8:19 p.m.",
      "commitName": "c9aace4da215330c1aa552fa1dcdd79748249774",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-05-03, 5:49 a.m.",
      "commitNameOld": "61c3f3d9fdf617097f121d26053f0d24ae621f08",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 168.6,
      "commitsBetweenForRepo": 608,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (Object.class.equals(requiredType)) {\n\t\t\t\t\treturn (T) convertedValue;\n\t\t\t\t}\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,135 +1,138 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n+\t\t\t\tif (Object.class.equals(requiredType)) {\n+\t\t\t\t\treturn (T) convertedValue;\n+\t\t\t\t}\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ff7dcec5f7d2b54324476bd617af74de9cbd56ec": {
      "type": "Ybodychange",
      "commitMessage": "BeanWrapper does not fall back to String constructor if ConversionService attempt failed before\n\nIssue: SPR-9865\n",
      "commitDate": "2012-10-12, 5:34 p.m.",
      "commitName": "ff7dcec5f7d2b54324476bd617af74de9cbd56ec",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012-09-04, 6:59 p.m.",
      "commitNameOld": "6bce09831060430b00e6ed93785c7d40ac8529a8",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 37.94,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,136 +1,135 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tboolean standardConversion \u003d false;\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n-\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n+\t\t\t\t\tif (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n-\t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n \t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6bce09831060430b00e6ed93785c7d40ac8529a8": {
      "type": "Ybodychange",
      "commitMessage": "refined TypeConverterDelegate\u0027s ConversionService exception handling\n\nIssue: SPR-9498\n",
      "commitDate": "2012-09-04, 6:59 p.m.",
      "commitName": "6bce09831060430b00e6ed93785c7d40ac8529a8",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012-09-04, 4:36 p.m.",
      "commitNameOld": "e904589bd1f910b095acdd1fb760a76ab84e8e54",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tboolean standardConversion \u003d false;\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t\tstandardConversion \u003d true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,131 +1,136 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n-\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n+\t\t\t\teditor \u003d findDefaultEditor(requiredType);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n+\t\tboolean standardConversion \u003d false;\n+\n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n+\t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n+\t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n+\t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n+\t\t\t\t\tstandardConversion \u003d true;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n-\t\t\tif (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue \u0026\u0026 requiredType !\u003d null \u0026\u0026\n-\t\t\t\t\t!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+\t\t\tif (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e754e9065b5703f93909f480933488a2b180429": {
      "type": "Ybodychange",
      "commitMessage": "SPR-9498: don\u0027t make assumptions about equality if ConversionService has failed\n\nThe failure of the conversion service is not fatal, but the check that\nwas in there (line 248) was inadequate to detect the cases that could\nalready be handled by the default property editors.  This code path\nwas also not tested anywhere in spring-beans tests until now.\n",
      "commitDate": "2012-06-14, 6:40 a.m.",
      "commitName": "8e754e9065b5703f93909f480933488a2b180429",
      "commitAuthor": "Dave Syer",
      "commitDateOld": "2012-01-31, 8:37 a.m.",
      "commitNameOld": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 134.88,
      "commitsBetweenForRepo": 260,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue \u0026\u0026 requiredType!\u003dnull \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 127,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,130 +1,130 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n-\t\t\tif (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue) {\n+\t\t\tif (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue \u0026\u0026 requiredType!\u003dnull \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012-01-31, 8:37 a.m.",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012-01-31, 8:37 a.m.",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 126,
      "functionName": "convertIfNecessary",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
        "newPath": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java"
      }
    },
    "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79": {
      "type": "Ybodychange",
      "commitMessage": "correctly handle ParseException from Formatter for String-\u003eString case (SPR-8944)\n",
      "commitDate": "2011-12-22, 10:30 a.m.",
      "commitName": "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011-12-22, 9:54 a.m.",
      "commitNameOld": "86bef9030fa4e026107db74cd9eef288beb1beca",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 126,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,130 +1,130 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n-\t\t\tif (editor \u003d\u003d null) {\n+\t\t\tif (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue) {\n \t\t\t\tthrow firstAttemptEx;\n \t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "86bef9030fa4e026107db74cd9eef288beb1beca": {
      "type": "Ybodychange",
      "commitMessage": "correctly handle ParseException from Formatter for String-\u003eString case (SPR-8944)\n",
      "commitDate": "2011-12-22, 9:54 a.m.",
      "commitName": "86bef9030fa4e026107db74cd9eef288beb1beca",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011-12-03, 10:57 a.m.",
      "commitNameOld": "84be348cb0ac99896674170dc9f99021b43ba9ee",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 18.96,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\tthrow firstAttemptEx;\n\t\t\t}\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 126,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,127 +1,130 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\tConversionFailedException firstAttemptEx \u003d null;\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t}\n \t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\tif (firstAttemptEx !\u003d null) {\n \t\t\t\t\tthrow firstAttemptEx;\n \t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (firstAttemptEx !\u003d null) {\n+\t\t\tif (editor \u003d\u003d null) {\n+\t\t\t\tthrow firstAttemptEx;\n+\t\t\t}\n \t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n \t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84be348cb0ac99896674170dc9f99021b43ba9ee": {
      "type": "Ybodychange",
      "commitMessage": "log or rethrow original ConversionFailedException as appropriate\n",
      "commitDate": "2011-12-03, 10:57 a.m.",
      "commitName": "84be348cb0ac99896674170dc9f99021b43ba9ee",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011-07-04, 5:43 a.m.",
      "commitNameOld": "57998293c811067cf87e6933f7abb4d4edb677c1",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 152.26,
      "commitsBetweenForRepo": 515,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\tConversionFailedException firstAttemptEx \u003d null;\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t}\n\t\t\t\tcatch (ConversionFailedException ex) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t\tfirstAttemptEx \u003d ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\tif (firstAttemptEx !\u003d null) {\n\t\t\t\t\tthrow firstAttemptEx;\n\t\t\t\t}\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstAttemptEx !\u003d null) {\n\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 126,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,115 +1,127 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n+\t\tConversionFailedException firstAttemptEx \u003d null;\n+\n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n-\t\t\t\t} catch (ConversionFailedException e) {\n+\t\t\t\t}\n+\t\t\t\tcatch (ConversionFailedException ex) {\n \t\t\t\t\t// fallback to default conversion logic below\n+\t\t\t\t\tfirstAttemptEx \u003d ex;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+\t\t\t\tif (firstAttemptEx !\u003d null) {\n+\t\t\t\t\tthrow firstAttemptEx;\n+\t\t\t\t}\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n \t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\tif (firstAttemptEx !\u003d null) {\n+\t\t\tlogger.debug(\"Original ConversionService attempt failed - ignored since \" +\n+\t\t\t\t\t\"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n+\t\t}\n+\n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f288060ad8f0d007f1541213130d006729b9ec40": {
      "type": "Ybodychange",
      "commitMessage": "restored support for String-to-ContextResource conversion (SPR-8383)\n",
      "commitDate": "2011-06-15, 11:40 a.m.",
      "commitName": "f288060ad8f0d007f1541213130d006729b9ec40",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011-06-06, 10:51 p.m.",
      "commitNameOld": "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 8.53,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t} catch (ConversionFailedException e) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 125,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,114 +1,115 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t} catch (ConversionFailedException e) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n-\t\t\t\t\t\t\t\"] returned inappropriate value\");\n+\t\t\t\t\t\t\t\"] returned inappropriate value of type [\").append(\n+\t\t\t\t\t\t\tClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5e3a5202fbd17cd30607ca7bb5360c9db8197e75": {
      "type": "Ybodychange",
      "commitMessage": "restored TypeDescriptor getElementType, getMapKeyType, and getMapValueType compatibility; StringToCollection and Array Converters are now conditional and check targetElementType if present; TypeDesciptor#isAssignable no longer bothers with element type and map key/value types in checking assignability for consistency elsewhere; improved javadoc\n",
      "commitDate": "2011-06-06, 10:51 p.m.",
      "commitName": "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-06-05, 1:52 p.m.",
      "commitNameOld": "8c6890605a7080e2744be3f3994757cc72e394b0",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 1.37,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t} catch (ConversionFailedException e) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 125,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,114 +1,114 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t} catch (ConversionFailedException e) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n-\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n+\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c6890605a7080e2744be3f3994757cc72e394b0": {
      "type": "Ybodychange",
      "commitMessage": "null type descriptor handling\n",
      "commitDate": "2011-06-05, 1:52 p.m.",
      "commitName": "8c6890605a7080e2744be3f3994757cc72e394b0",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-06-05, 2:04 a.m.",
      "commitNameOld": "2127b160512911e5f65a4e304f0b57826710a91d",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t} catch (ConversionFailedException e) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 125,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,114 +1,114 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n-\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n+\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\ttry {\n \t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t\t} catch (ConversionFailedException e) {\n \t\t\t\t\t// fallback to default conversion logic below\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2127b160512911e5f65a4e304f0b57826710a91d": {
      "type": "Ybodychange",
      "commitMessage": "catch ConversionFailedException and fallback to default container conversion logic rather than propogate exception\n",
      "commitDate": "2011-06-05, 2:04 a.m.",
      "commitName": "2127b160512911e5f65a4e304f0b57826710a91d",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-06-05, 1:46 a.m.",
      "commitNameOld": "c306afed63e439ee133872a49380d76064bd2638",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t\t} catch (ConversionFailedException e) {\n\t\t\t\t\t// fallback to default conversion logic below\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 125,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,110 +1,114 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\t\ttry {\n+\t\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\t\t} catch (ConversionFailedException e) {\n+\t\t\t\t\t// fallback to default conversion logic below\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c306afed63e439ee133872a49380d76064bd2638": {
      "type": "Ybodychange",
      "commitMessage": "polishing\n",
      "commitDate": "2011-06-05, 1:46 a.m.",
      "commitName": "c306afed63e439ee133872a49380d76064bd2638",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-06-05, 12:43 a.m.",
      "commitNameOld": "c84cccf06dad4e3f11cd529ab16a5655bf723820",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 124,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,110 +1,110 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n-\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n+\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n \t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c84cccf06dad4e3f11cd529ab16a5655bf723820": {
      "type": "Ybodychange",
      "commitMessage": "revised TypeDescriptor NULL and element/mapKey/mapValue type semantics\n",
      "commitDate": "2011-06-05, 12:43 a.m.",
      "commitName": "c84cccf06dad4e3f11cd529ab16a5655bf723820",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-06-02, 7:37 p.m.",
      "commitNameOld": "6f146737f475828b6d765784017773378c2c4922",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 2.21,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 123,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,110 +1,110 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n-\t\t\t\tClass elemType \u003d typeDescriptor.getElementType();\n-\t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n+\t\t\t\tTypeDescriptor elementType \u003d typeDescriptor.getElementType();\n+\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f146737f475828b6d765784017773378c2c4922": {
      "type": "Ybodychange",
      "commitMessage": "simplified TypeDescriptor usage and updated use of the API across BeanWrapper and SpEL; collapsed PropertyTypeDescriptor into TypeDescriptor for simplicity and ease of use; improved docs\n",
      "commitDate": "2011-06-02, 7:37 p.m.",
      "commitName": "6f146737f475828b6d765784017773378c2c4922",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-05, 12:49 a.m.",
      "commitNameOld": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 148.74,
      "commitsBetweenForRepo": 438,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n\t\t\t\tClass elemType \u003d typeDescriptor.getElementType();\n\t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 123,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,111 +1,110 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n-\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n-\t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n-\t\t\t\tClass elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n+\t\t\t\tClass elemType \u003d typeDescriptor.getElementType();\n \t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": {
      "type": "Ybodychange",
      "commitMessage": "TypeDescriptor cleanup and general polishing; fixed a number of bugs related to TypeDescriptor usage in client code across beans and spel packages\n",
      "commitDate": "2011-01-05, 12:49 a.m.",
      "commitName": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2010-06-23, 4:05 p.m.",
      "commitNameOld": "942c656970df903705417b0b9631b2dd66e3bff0",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 195.41,
      "commitsBetweenForRepo": 382,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n\t\t\t\tClass elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n\t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 127,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,111 +1,111 @@\n \tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n-\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n+\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor;\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n \t\t\t\tClass elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n \t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": {
      "type": "Ymodifierchange",
      "commitMessage": "revised BeanWrapper\u0027s exception wrapping to consistently handle ConversionExceptions (SPR-7177)\n",
      "commitDate": "2010-05-17, 5:59 p.m.",
      "commitName": "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-04-02, 4:00 a.m.",
      "commitNameOld": "580dc8e72ae823ab4cf988de94fd8ae922bd2fc4",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 45.58,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n\t\t\t\tClass elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n\t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 127,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,111 +1,111 @@\n-\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n+\tpublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n \t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n \t\t\t\tClass elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n \t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[public]"
      }
    },
    "cbed1c1b4b5fd74c9cd201890f619a7079804d3f": {
      "type": "Ybodychange",
      "commitMessage": "fixed collection element conversion using ConversionService (SPR-6950)\n",
      "commitDate": "2010-03-25, 11:02 a.m.",
      "commitName": "cbed1c1b4b5fd74c9cd201890f619a7079804d3f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-03-25, 7:53 a.m.",
      "commitNameOld": "d50881d82b8f2ed8e0947cdffe0e4f74fd3a53dd",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n\t\t\t\tClass elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n\t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 187,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,110 +1,111 @@\n \tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n+\t\t\tTypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n-\t\t\t\tClass elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n-\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n+\t\t\t\tClass elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+\t\t\t\tif (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc99df297274d8c1291cdaed5d9dd508910584d3": {
      "type": "Ybodychange",
      "commitMessage": "use TypeDescriptor.forObject instead of constructor; enforce use of TypeDescriptor.valueOf through making the constructor private\n",
      "commitDate": "2009-12-15, 3:18 p.m.",
      "commitName": "dc99df297274d8c1291cdaed5d9dd508910584d3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-12-15, 7:36 a.m.",
      "commitNameOld": "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n\t\t\t\tClass elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 186,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,110 +1,110 @@\n \tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n-\t\t\tTypeDescriptor sourceTypeDesc \u003d new TypeDescriptor(convertedValue);\n+\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n \t\t\t\tClass elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde": {
      "type": "Ybodychange",
      "commitMessage": "introspect element type in case of incoming Collection/Map in order to not accidentally say canConvert\u003dtrue (SPR-6564)\n",
      "commitDate": "2009-12-15, 7:36 a.m.",
      "commitName": "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-12-13, 8:21 a.m.",
      "commitNameOld": "5f9b4443194d3aa3948d76956897c0a1d918d546",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.97,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d new TypeDescriptor(convertedValue);\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n\t\t\t\tClass elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 186,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,110 +1,110 @@\n \tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n-\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n+\t\t\tTypeDescriptor sourceTypeDesc \u003d new TypeDescriptor(convertedValue);\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n \t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n \t\t\t\tClass elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n \t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n \t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n \t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f9b4443194d3aa3948d76956897c0a1d918d546": {
      "type": "Ybodychange",
      "commitMessage": "bean properties of type enum array/collection can be populated with comma-separated String (SPR-6547)\n",
      "commitDate": "2009-12-13, 8:21 a.m.",
      "commitName": "5f9b4443194d3aa3948d76956897c0a1d918d546",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-11-26, 8:43 p.m.",
      "commitNameOld": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 16.48,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n\t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n\t\t\t\tClass elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 186,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,100 +1,110 @@\n \tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n \t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n+\t\t\tif (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026\n+\t\t\t\t\tconvertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n+\t\t\t\tClass elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+\t\t\t\tif (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n+\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n+\t\t\t\t\tif (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n+\t\t\t\t\t\tconvertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+\t\t\t\t\t}\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ac490114aee005a66eeb0fba6c3c853552fc6a94": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
      "commitDate": "2009-11-26, 8:43 p.m.",
      "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
          "commitDate": "2009-11-26, 8:43 p.m.",
          "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-10-14, 4:45 p.m.",
          "commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 43.21,
          "commitsBetweenForRepo": 404,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 186,
          "functionName": "convertIfNecessary",
          "diff": "@@ -1,110 +1,100 @@\n-\tprotected \u003cT\u003e T convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n-\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n-\t\t\tthrows IllegalArgumentException {\n+\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n+\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n-\t\t\tTypeDescriptor targetTypeDesc;\n-\t\t\tif (methodParam !\u003d null) {\n-\t\t\t\ttargetTypeDesc \u003d (descriptor !\u003d null ?\n-\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\ttargetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n-\t\t\t}\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n-\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n+\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n-\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n-\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class\u003cT\u003e, descriptor-PropertyDescriptor, methodParam-MethodParameter]",
            "newValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class\u003cT\u003e, typeDescriptor-TypeDescriptor]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
          "commitDate": "2009-11-26, 8:43 p.m.",
          "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-10-14, 4:45 p.m.",
          "commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 43.21,
          "commitsBetweenForRepo": 404,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 186,
          "functionName": "convertIfNecessary",
          "diff": "@@ -1,110 +1,100 @@\n-\tprotected \u003cT\u003e T convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n-\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n-\t\t\tthrows IllegalArgumentException {\n+\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n+\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n-\t\t\tTypeDescriptor targetTypeDesc;\n-\t\t\tif (methodParam !\u003d null) {\n-\t\t\t\ttargetTypeDesc \u003d (descriptor !\u003d null ?\n-\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\ttargetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n-\t\t\t}\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n-\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n+\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n-\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n-\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
          "commitDate": "2009-11-26, 8:43 p.m.",
          "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-10-14, 4:45 p.m.",
          "commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 43.21,
          "commitsBetweenForRepo": 404,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 186,
          "functionName": "convertIfNecessary",
          "diff": "@@ -1,110 +1,100 @@\n-\tprotected \u003cT\u003e T convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n-\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n-\t\t\tthrows IllegalArgumentException {\n+\tprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue,\n+\t\t\tClass\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n-\t\t\tTypeDescriptor targetTypeDesc;\n-\t\t\tif (methodParam !\u003d null) {\n-\t\t\t\ttargetTypeDesc \u003d (descriptor !\u003d null ?\n-\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\ttargetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n-\t\t\t}\n-\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n-\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n+\t\t\t\teditor \u003d findDefaultEditor(requiredType, typeDescriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n-\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n-\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n+\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, typeDescriptor);\n \t\t\t\t}\n \t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n \t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n \t\t\t\t}\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "84447cdf9493a5f6ead3450627d8938af1b7ac5f": {
      "type": "Ybodychange",
      "commitMessage": "DataBinder activates autoGrowNestedPaths by default; fixed enum binding with WebRequestDataBinder\n",
      "commitDate": "2009-10-13, 4:55 p.m.",
      "commitName": "84447cdf9493a5f6ead3450627d8938af1b7ac5f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-09-18, 4:32 p.m.",
      "commitNameOld": "45c542e51e9b01526a97a1644aebfe1e94a2342f",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 25.02,
      "commitsBetweenForRepo": 161,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n\t\t\tTypeDescriptor targetTypeDesc;\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\ttargetTypeDesc \u003d (descriptor !\u003d null ?\n\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n\t\t\t}\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n\t\t\t\t}\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 157,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,107 +1,110 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n \t\t\tTypeDescriptor targetTypeDesc;\n \t\t\tif (methodParam !\u003d null) {\n \t\t\t\ttargetTypeDesc \u003d (descriptor !\u003d null ?\n \t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttargetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n \t\t\t}\n \t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n-\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n-\t\t\t\t\t// We can stringify any primitive value...\n-\t\t\t\t\treturn (T) convertedValue.toString();\n-\t\t\t\t}\n-\t\t\t\telse if (requiredType.isArray()) {\n+\t\t\t\tif (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n+\t\t\t\tif (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n+\t\t\t\t\tconvertedValue \u003d Array.get(convertedValue, 0);\n+\t\t\t\t}\n+\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+\t\t\t\t\t// We can stringify any primitive value...\n+\t\t\t\t\treturn (T) convertedValue.toString();\n+\t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45c542e51e9b01526a97a1644aebfe1e94a2342f": {
      "type": "Ybodychange",
      "commitMessage": "updated for change in conversion service api; source type desc now required\n",
      "commitDate": "2009-09-18, 4:32 p.m.",
      "commitName": "45c542e51e9b01526a97a1644aebfe1e94a2342f",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009-09-18, 3:57 p.m.",
      "commitNameOld": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n\t\t\tTypeDescriptor targetTypeDesc;\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\ttargetTypeDesc \u003d (descriptor !\u003d null ?\n\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n\t\t\t}\n\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,106 +1,107 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n-\t\t\tTypeDescriptor typeDesc;\n+\t\t\tTypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n+\t\t\tTypeDescriptor targetTypeDesc;\n \t\t\tif (methodParam !\u003d null) {\n-\t\t\t\ttypeDesc \u003d (descriptor !\u003d null ?\n+\t\t\t\ttargetTypeDesc \u003d (descriptor !\u003d null ?\n \t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n-\t\t\t\ttypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n+\t\t\t\ttargetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n \t\t\t}\n-\t\t\tif (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n+\t\t\tif (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d": {
      "type": "Ybodychange",
      "commitMessage": "refined generic converter concept\n",
      "commitDate": "2009-09-18, 3:57 p.m.",
      "commitName": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009-09-11, 2:31 p.m.",
      "commitNameOld": "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
      "commitAuthorOld": "Rob Harrop",
      "daysBetweenCommits": 7.06,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor typeDesc;\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\ttypeDesc \u003d (descriptor !\u003d null ?\n\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n\t\t\t}\n\t\t\tif (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,106 +1,106 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor typeDesc;\n \t\t\tif (methodParam !\u003d null) {\n \t\t\t\ttypeDesc \u003d (descriptor !\u003d null ?\n \t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n \t\t\t}\n-\t\t\tif (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n+\t\t\tif (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1480202aa37d7edaf7f070a2bf45cd3a1016eea7": {
      "type": "Ybodychange",
      "commitMessage": "[SPR-5644] Support for Enum\u003c?\u003e and Enum\u003cT\u003e values as FQN.FIELD_NAME in type conversion\n",
      "commitDate": "2009-09-11, 2:31 p.m.",
      "commitName": "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
      "commitAuthor": "Rob Harrop",
      "commitDateOld": "2009-09-07, 7:58 p.m.",
      "commitNameOld": "a86a698e5b3394c9b6721a784c8fe251611ff16b",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor typeDesc;\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\ttypeDesc \u003d (descriptor !\u003d null ?\n\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n\t\t\t}\n\t\t\tif (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,116 +1,106 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n \t\t\tTypeDescriptor typeDesc;\n \t\t\tif (methodParam !\u003d null) {\n \t\t\t\ttypeDesc \u003d (descriptor !\u003d null ?\n \t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n \t\t\t}\n \t\t\tif (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n-\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n-\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n-\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n-\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (Throwable ex) {\n-\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\t\t\n+\t\t\t\t\tconvertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a86a698e5b3394c9b6721a784c8fe251611ff16b": {
      "type": "Ybodychange",
      "commitMessage": "initial JSR-303 Bean Validation support; revised ConversionService and FormatterRegistry\n",
      "commitDate": "2009-09-07, 7:58 p.m.",
      "commitName": "a86a698e5b3394c9b6721a784c8fe251611ff16b",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-08-25, 9:49 a.m.",
      "commitNameOld": "04cd95ff50f78f4b8ff738f6ca183abe06b366ee",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 13.42,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n\t\t\tTypeDescriptor typeDesc;\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\ttypeDesc \u003d (descriptor !\u003d null ?\n\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n\t\t\t}\n\t\t\tif (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,112 +1,116 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n-\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n-\t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n+\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n+\t\t\tTypeDescriptor typeDesc;\n \t\t\tif (methodParam !\u003d null) {\n-\t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n+\t\t\t\ttypeDesc \u003d (descriptor !\u003d null ?\n+\t\t\t\t\t\tnew BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n-\t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n+\t\t\t\ttypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n+\t\t\t}\n+\t\t\tif (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, typeDesc);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n \t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n \t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9a48f3f3a896cad821e5847a93d91c997905e325": {
      "type": "Ybodychange",
      "commitMessage": "try to create unknown collection implementation types via default constructor\n",
      "commitDate": "2009-08-25, 9:29 a.m.",
      "commitName": "9a48f3f3a896cad821e5847a93d91c997905e325",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-08-24, 9:48 a.m.",
      "commitNameOld": "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n\t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,108 +1,112 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n \t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n \t\t\tif (methodParam !\u003d null) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n-\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n+\t\t\t\telse if (convertedValue instanceof Collection) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n-\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n+\t\t\t\t\tconvertedValue \u003d convertToTypedCollection(\n+\t\t\t\t\t\t\t(Collection) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n-\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n+\t\t\t\telse if (convertedValue instanceof Map) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n-\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n+\t\t\t\t\tconvertedValue \u003d convertToTypedMap(\n+\t\t\t\t\t\t\t(Map) convertedValue, propertyName, requiredType, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n-\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (NoSuchMethodException ex) {\n-\t\t\t\t\t\t// proceed with field lookup\n-\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\tif (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n+\t\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\tlogger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\tcatch (NoSuchMethodException ex) {\n+\t\t\t\t\t\t\t// proceed with field lookup\n+\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\tlogger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f": {
      "type": "Ybodychange",
      "commitMessage": "fixed accidental test failures\n",
      "commitDate": "2009-08-24, 9:48 a.m.",
      "commitName": "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-08-24, 9:30 a.m.",
      "commitNameOld": "fee838a65e87f5da4b65b04ea5101681d6308104",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n\t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,103 +1,108 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n \t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n \t\t\tif (methodParam !\u003d null) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n \t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (NoSuchMethodException ex) {\n \t\t\t\t\t\t// proceed with field lookup\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\tlogger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fee838a65e87f5da4b65b04ea5101681d6308104": {
      "type": "Ybodychange",
      "commitMessage": "support for default \"conversionService\" bean in an ApplicationContext; revised formatting package, now integrated with DataBinder and AnnotationMethodHandlerAdapter; revised AccessControlContext access from BeanFactory\n",
      "commitDate": "2009-08-24, 9:30 a.m.",
      "commitName": "fee838a65e87f5da4b65b04ea5101681d6308104",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-08-08, 8:46 p.m.",
      "commitNameOld": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 15.53,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n\t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\t// proceed with field lookup\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,93 +1,103 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// No custom editor but custom ConversionService specified?\n \t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n \t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n \t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n \t\t\tif (methodParam !\u003d null) {\n \t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n \t\t\t}\n \t\t\telse {\n \t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n \t\t\t}\n \t\t}\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n-\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n-\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tConstructor strCtor \u003d requiredType.getConstructor(String.class);\n+\t\t\t\t\t\treturn (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (NoSuchMethodException ex) {\n+\t\t\t\t\t\t// proceed with field lookup\n+\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\tlogger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tString trimmedValue \u003d ((String) convertedValue).trim();\n+\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n+\t\t\t\t\t\tField enumField \u003d requiredType.getField(trimmedValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": {
      "type": "Ybodychange",
      "commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
      "commitDate": "2009-08-08, 8:46 p.m.",
      "commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-05-11, 6:44 p.m.",
      "commitNameOld": "0297116542a3ce33d19a6a81b8240097081376c5",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 89.08,
      "commitsBetweenForRepo": 569,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// No custom editor but custom ConversionService specified?\n\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n\t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n\t\t\tif (methodParam !\u003d null) {\n\t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n\t\t\t}\n\t\t}\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 155,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,81 +1,93 @@\n \tprotected \u003cT\u003e T convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n+\t\t// No custom editor but custom ConversionService specified?\n+\t\tConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n+\t\tif (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026\n+\t\t\t\tconversionService.canConvert(convertedValue.getClass(), requiredType)) {\n+\t\t\tif (methodParam !\u003d null) {\n+\t\t\t\treturn (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\treturn conversionService.convert(convertedValue, requiredType);\n+\t\t\t}\n+\t\t}\n+\n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0297116542a3ce33d19a6a81b8240097081376c5": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "generified TypeConverter interface\n",
      "commitDate": "2009-05-11, 6:44 p.m.",
      "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "generified TypeConverter interface\n",
          "commitDate": "2009-05-11, 6:44 p.m.",
          "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-05-11, 10:52 a.m.",
          "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 153,
          "functionName": "convertIfNecessary",
          "diff": "@@ -1,81 +1,81 @@\n-\tprotected Object convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n+\tprotected \u003cT\u003e T convertIfNecessary(\n+\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n-\t\t\t\t\treturn convertedValue.toString();\n+\t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n-\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn convertedValue;\n+\t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class, descriptor-PropertyDescriptor, methodParam-MethodParameter]",
            "newValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class\u003cT\u003e, descriptor-PropertyDescriptor, methodParam-MethodParameter]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "generified TypeConverter interface\n",
          "commitDate": "2009-05-11, 6:44 p.m.",
          "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-05-11, 10:52 a.m.",
          "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 153,
          "functionName": "convertIfNecessary",
          "diff": "@@ -1,81 +1,81 @@\n-\tprotected Object convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n+\tprotected \u003cT\u003e T convertIfNecessary(\n+\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n-\t\t\t\t\treturn convertedValue.toString();\n+\t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n-\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn convertedValue;\n+\t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Object",
            "newValue": "T"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "generified TypeConverter interface\n",
          "commitDate": "2009-05-11, 6:44 p.m.",
          "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-05-11, 10:52 a.m.",
          "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected \u003cT\u003e T convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn (T) convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (T) convertedValue;\n\t}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 153,
          "functionName": "convertIfNecessary",
          "diff": "@@ -1,81 +1,81 @@\n-\tprotected Object convertIfNecessary(\n-\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n+\tprotected \u003cT\u003e T convertIfNecessary(\n+\t\t\tString propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n-\t\t\t\t\treturn convertedValue.toString();\n+\t\t\t\t\treturn (T) convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n-\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+\t\t\t\t\treturn (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn convertedValue;\n+\t\treturn (T) convertedValue;\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "bf7a947559d8f9918cc738780bf04caf8ea46962": {
      "type": "Ybodychange",
      "commitMessage": "SPR-5732 - When no type conversion strategy is found on a @Controller handler method bind target, a 500 error code should be returned not a 400.\n\n",
      "commitDate": "2009-05-11, 10:52 a.m.",
      "commitName": "bf7a947559d8f9918cc738780bf04caf8ea46962",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2008-11-24, 8:29 p.m.",
      "commitNameOld": "29657105da133995b0b2277b82c75d1df2931b64",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 167.56,
      "commitsBetweenForRepo": 808,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected Object convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 152,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,80 +1,81 @@\n \tprotected Object convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n-\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException.\n+\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException/IllegalStateException\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n \t\t\t\t\t\t\t\"] returned inappropriate value\");\n+\t\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n+\t\t\t\t\tthrow new IllegalStateException(msg.toString());\n \t\t\t\t}\n-\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t}\n \t\t}\n \n \t\treturn convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "29657105da133995b0b2277b82c75d1df2931b64": {
      "type": "Ybodychange",
      "commitMessage": "Java 5 code style\n",
      "commitDate": "2008-11-24, 8:29 p.m.",
      "commitName": "29657105da133995b0b2277b82c75d1df2931b64",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008-11-19, 9:10 p.m.",
      "commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected Object convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException.\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n\t\t\t\t\t\t\t\"] returned inappropriate value\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t}\n\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t}\n\t\t}\n\n\t\treturn convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 152,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,79 +1,80 @@\n \tprotected Object convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n \t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException.\n \t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n-\t\t\t\t\tmsg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n+\t\t\t\t\tmsg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n-\t\t\t\t\tmsg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n+\t\t\t\t\tmsg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\n+\t\t\t\t\t\t\t\"] returned inappropriate value\");\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t}\n \t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t}\n \t\t}\n \n \t\treturn convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
      "type": "Ybodychange",
      "commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
      "commitDate": "2008-11-19, 9:10 p.m.",
      "commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008-10-22, 12:13 p.m.",
      "commitNameOld": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 28.41,
      "commitsBetweenForRepo": 194,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected Object convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException.\n\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t}\n\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t}\n\t\t}\n\n\t\treturn convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 152,
      "functionName": "convertIfNecessary",
      "diff": "@@ -1,79 +1,79 @@\n \tprotected Object convertIfNecessary(\n \t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n \t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n \t\t\tthrows IllegalArgumentException {\n \n \t\tObject convertedValue \u003d newValue;\n \n \t\t// Custom editor for this type?\n \t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n \n \t\t// Value not of required type?\n \t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n \t\t\tif (editor \u003d\u003d null) {\n \t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n \t\t\t}\n \t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n \t\t}\n \n \t\tif (requiredType !\u003d null) {\n \t\t\t// Try to apply some standard type conversion rules if appropriate.\n \n \t\t\tif (convertedValue !\u003d null) {\n \t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n \t\t\t\t\t// We can stringify any primitive value...\n \t\t\t\t\treturn convertedValue.toString();\n \t\t\t\t}\n \t\t\t\telse if (requiredType.isArray()) {\n \t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n \t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n \t\t\t\t\t// Convert elements to target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n \t\t\t\t\t// Convert keys and values to respective target type, if determined.\n \t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n \t\t\t\t}\n \t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n \t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n-\t\t\t\t\tif (JdkVersion.isAtLeastJava15() \u0026\u0026 requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n+\t\t\t\t\tif (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n \t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n \t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n \t\t\t\t\t// with values defined as static fields. Resulting value still needs\n \t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n \t\t\t\t\ttry {\n \t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n \t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Throwable ex) {\n \t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n \t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException.\n-\t\t\t\tStringBuffer msg \u003d new StringBuffer();\n+\t\t\t\tStringBuilder msg \u003d new StringBuilder();\n \t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n \t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n \t\t\t\tif (propertyName !\u003d null) {\n \t\t\t\t\tmsg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n \t\t\t\t}\n \t\t\t\tif (editor !\u003d null) {\n \t\t\t\t\tmsg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n \t\t\t\t}\n \t\t\t\tthrow new IllegalArgumentException(msg.toString());\n \t\t\t}\n \t\t}\n \n \t\treturn convertedValue;\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
      "type": "Yintroduced",
      "commitMessage": "Moved over initial version of beans bundle\n",
      "commitDate": "2008-10-22, 12:13 p.m.",
      "commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthor": "Arjen Poutsma",
      "diff": "@@ -0,0 +1,79 @@\n+\tprotected Object convertIfNecessary(\n+\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n+\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n+\t\t\tthrows IllegalArgumentException {\n+\n+\t\tObject convertedValue \u003d newValue;\n+\n+\t\t// Custom editor for this type?\n+\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n+\n+\t\t// Value not of required type?\n+\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n+\t\t\tif (editor \u003d\u003d null) {\n+\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n+\t\t\t}\n+\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n+\t\t}\n+\n+\t\tif (requiredType !\u003d null) {\n+\t\t\t// Try to apply some standard type conversion rules if appropriate.\n+\n+\t\t\tif (convertedValue !\u003d null) {\n+\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+\t\t\t\t\t// We can stringify any primitive value...\n+\t\t\t\t\treturn convertedValue.toString();\n+\t\t\t\t}\n+\t\t\t\telse if (requiredType.isArray()) {\n+\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n+\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+\t\t\t\t}\n+\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n+\t\t\t\t\t// Convert elements to target type, if determined.\n+\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n+\t\t\t\t}\n+\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n+\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n+\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n+\t\t\t\t}\n+\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n+\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n+\t\t\t\t\tif (JdkVersion.isAtLeastJava15() \u0026\u0026 requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n+\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n+\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n+\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n+\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (Throwable ex) {\n+\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException.\n+\t\t\t\tStringBuffer msg \u003d new StringBuffer();\n+\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n+\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n+\t\t\t\tif (propertyName !\u003d null) {\n+\t\t\t\t\tmsg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n+\t\t\t\t}\n+\t\t\t\tif (editor !\u003d null) {\n+\t\t\t\t\tmsg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n+\t\t\t\t}\n+\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn convertedValue;\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tprotected Object convertIfNecessary(\n\t\t\tString propertyName, Object oldValue, Object newValue, Class requiredType,\n\t\t\tPropertyDescriptor descriptor, MethodParameter methodParam)\n\t\t\tthrows IllegalArgumentException {\n\n\t\tObject convertedValue \u003d newValue;\n\n\t\t// Custom editor for this type?\n\t\tPropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n\n\t\t// Value not of required type?\n\t\tif (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n\t\t\tif (editor \u003d\u003d null) {\n\t\t\t\teditor \u003d findDefaultEditor(requiredType, descriptor);\n\t\t\t}\n\t\t\tconvertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n\t\t}\n\n\t\tif (requiredType !\u003d null) {\n\t\t\t// Try to apply some standard type conversion rules if appropriate.\n\n\t\t\tif (convertedValue !\u003d null) {\n\t\t\t\tif (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n\t\t\t\t\t// We can stringify any primitive value...\n\t\t\t\t\treturn convertedValue.toString();\n\t\t\t\t}\n\t\t\t\telse if (requiredType.isArray()) {\n\t\t\t\t\t// Array required -\u003e apply appropriate conversion of elements.\n\t\t\t\t\treturn convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n\t\t\t\t\t// Convert elements to target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n\t\t\t\t\t// Convert keys and values to respective target type, if determined.\n\t\t\t\t\tconvertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n\t\t\t\t}\n\t\t\t\telse if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n\t\t\t\t\tString strValue \u003d ((String) convertedValue).trim();\n\t\t\t\t\tif (JdkVersion.isAtLeastJava15() \u0026\u0026 requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n\t\t\t\t\t\t// It\u0027s an empty enum identifier: reset the enum value to null.\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// Try field lookup as fallback: for JDK 1.5 enum or custom enum\n\t\t\t\t\t// with values defined as static fields. Resulting value still needs\n\t\t\t\t\t// to be checked, hence we don\u0027t return it right away.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tField enumField \u003d requiredType.getField(strValue);\n\t\t\t\t\t\tconvertedValue \u003d enumField.get(null);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n\t\t\t\t// Definitely doesn\u0027t match: throw IllegalArgumentException.\n\t\t\t\tStringBuffer msg \u003d new StringBuffer();\n\t\t\t\tmsg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n\t\t\t\tmsg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n\t\t\t\tif (propertyName !\u003d null) {\n\t\t\t\t\tmsg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n\t\t\t\t}\n\t\t\t\tif (editor !\u003d null) {\n\t\t\t\t\tmsg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmsg.append(\": no matching editors or conversion strategy found\");\n\t\t\t\t}\n\t\t\t\tthrow new IllegalArgumentException(msg.toString());\n\t\t\t}\n\t\t}\n\n\t\treturn convertedValue;\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 158,
      "functionName": "convertIfNecessary"
    }
  }
}