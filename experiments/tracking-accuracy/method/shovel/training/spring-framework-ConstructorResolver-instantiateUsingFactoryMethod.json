{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "H:\\Projects\\spring-projects\\spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "ConstructorResolver.java",
  "functionName": "instantiateUsingFactoryMethod",
  "functionId": "instantiateUsingFactoryMethod___beanName-String(modifiers-final)__mbd-RootBeanDefinition(modifiers-final)__explicitArgs-Object[](annotations-@Nullable__modifiers-final)",
  "sourceFilePath": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
  "functionStartLine": 360,
  "functionEndLine": 597,
  "numCommitsSeen": 83,
  "timeTaken": 8585,
  "changeHistory": [
    "1603c4ab2fc49d1bd65f55e35ca899044835ca94",
    "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
    "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
    "a5cbf5fe246e362c939db006cb44793b22bdc741",
    "b5cedd43eb2b70510729696554bbc1f99003ac10",
    "b94302b5bde7475b9926dacb9fb69f3c8c894444",
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "87598f48e41d483745aba56cbf4e998c6f6d680c",
    "cf479bf893df758b54f1a7117a7eae9a32728ab7",
    "39e3f2ebf6690b72b7a8af852a35df6ff6229515",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
    "b944283354f0f340ffc7ec74b430d79703a4294a",
    "8a83af55b8adf833683b8d9a6924eecf69709a12",
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
    "ad62b2afb145499d384cb76c5f254113db99796c",
    "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
    "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
    "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
    "603cdea26e0880a46c697194bf5f1cbe60177f16",
    "b093b8495416cd3f05a32add1c671174341bd595",
    "94685481162a93666fc2f39b66223833a6bcb418",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "061063257ab8e16786d04eaddb5b5aba61dcd7f1",
    "a9da12325995ab03cef56e8f51870081e36a3c9e",
    "9857ba077b16312e78ca6dcf2a219326955daae5",
    "12ce250c6ce911774a7983905fd6e006b5a1eac1",
    "351e72b6e258bd030fb21be253f6348319f81d0e",
    "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
    "45448463b87629bdd85cb375d3faa391bfaf147f",
    "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
    "af8af8c633ba016eca671bc9468eba006e8834b1",
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
    "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
    "3cb073abce659c130abc9adc0662b75380fcc7f3",
    "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
    "7eabd2da563a4e95928e89f72f7a207804eef0ab",
    "53333c3ed06e465a55592a0f351ffab40110e5b3",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
    "14bd47551900ced88eeacf2a5f63c187ff72028c",
    "4344832a479831e7e67de1a9e81d52d023cd59ac",
    "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
    "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3"
  ],
  "changeHistoryShort": {
    "1603c4ab2fc49d1bd65f55e35ca899044835ca94": "Ybodychange",
    "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d": "Ybodychange",
    "74fcdea2d96e6c88d232c487e6e2ca6b9978773a": "Ybodychange",
    "a5cbf5fe246e362c939db006cb44793b22bdc741": "Ybodychange",
    "b5cedd43eb2b70510729696554bbc1f99003ac10": "Ybodychange",
    "b94302b5bde7475b9926dacb9fb69f3c8c894444": "Ybodychange",
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ybodychange",
    "87598f48e41d483745aba56cbf4e998c6f6d680c": "Yparametermetachange",
    "cf479bf893df758b54f1a7117a7eae9a32728ab7": "Ybodychange",
    "39e3f2ebf6690b72b7a8af852a35df6ff6229515": "Ybodychange",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": "Ybodychange",
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a": "Ybodychange",
    "b944283354f0f340ffc7ec74b430d79703a4294a": "Ybodychange",
    "8a83af55b8adf833683b8d9a6924eecf69709a12": "Ybodychange",
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": "Ybodychange",
    "ad62b2afb145499d384cb76c5f254113db99796c": "Ybodychange",
    "8c9274e01743a87d7fb8519f7772c1b1677ecbe0": "Ybodychange",
    "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b": "Ybodychange",
    "ad317774fb8e0b1f70e0135e5786c94c2521fb73": "Ybodychange",
    "603cdea26e0880a46c697194bf5f1cbe60177f16": "Ybodychange",
    "b093b8495416cd3f05a32add1c671174341bd595": "Ybodychange",
    "94685481162a93666fc2f39b66223833a6bcb418": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "061063257ab8e16786d04eaddb5b5aba61dcd7f1": "Ybodychange",
    "a9da12325995ab03cef56e8f51870081e36a3c9e": "Ybodychange",
    "9857ba077b16312e78ca6dcf2a219326955daae5": "Ybodychange",
    "12ce250c6ce911774a7983905fd6e006b5a1eac1": "Ybodychange",
    "351e72b6e258bd030fb21be253f6348319f81d0e": "Ybodychange",
    "18bd4a83375a1815dbf83aca384cf7f5c27e93f5": "Ybodychange",
    "45448463b87629bdd85cb375d3faa391bfaf147f": "Ybodychange",
    "904c2358cdfd9cd8337da0950b8c8d6fc7099839": "Ybodychange",
    "af8af8c633ba016eca671bc9468eba006e8834b1": "Ybodychange",
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209": "Ymultichange(Ybodychange,Yparametermetachange)",
    "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2": "Ybodychange",
    "3cb073abce659c130abc9adc0662b75380fcc7f3": "Ybodychange",
    "1eabe2b4416ee7619bd863fcdc1e6f6ada766400": "Ybodychange",
    "7eabd2da563a4e95928e89f72f7a207804eef0ab": "Ybodychange",
    "53333c3ed06e465a55592a0f351ffab40110e5b3": "Ybodychange",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": "Ybodychange",
    "14bd47551900ced88eeacf2a5f63c187ff72028c": "Ybodychange",
    "4344832a479831e7e67de1a9e81d52d023cd59ac": "Ybodychange",
    "092de0107cd876d7f8207da7a9fc9ba163cfadfe": "Ybodychange",
    "05bebb0c056714d97b479cf6c5552ba3c5b06d9c": "Ybodychange",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": "Ybodychange",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1603c4ab2fc49d1bd65f55e35ca899044835ca94": {
      "type": "Ybodychange",
      "commitMessage": "Programmatic ObjectProvider retrieval through BeanFactory API\n\nIntroduces getBeanProvider(Class) and getBeanProvider(ResolvableType), also narrowing getBean(String, Class) and isTypeMatch(String, Class) to a non-null Class argument and enriching NoUniqueBeanDefinitionException with a full ResolvableType. In addition, ObjectProvider supports iterable/stream access for collection-style resolution of multiple matching beans now, and collection injection falls back to an empty collection in a single-constructor case with non-null arguments.\n\nIssue: SPR-17075\nIssue: SPR-11419\nIssue: SPR-15338\n",
      "commitDate": "2018-07-23, 6:42 p.m.",
      "commitName": "1603c4ab2fc49d1bd65f55e35ca899044835ca94",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018-06-28, 4:28 a.m.",
      "commitNameOld": "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 25.59,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[0]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n\t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tminNrOfArgs \u003d 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (explicitArgs !\u003d null){\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw,\n\t\t\t\t\t\t\t\t\tparamTypes, paramNames, candidate, autowiring, candidates.length \u003d\u003d 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (resolvedValues !\u003d null){\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n\t\t\t\t\t\tthis.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args),\n\t\t\t\t\t\tthis.beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 358,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,238 +1,238 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n-\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n+\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[0]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n \t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tminNrOfArgs \u003d 0;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (explicitArgs !\u003d null){\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n-\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n+\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw,\n+\t\t\t\t\t\t\t\t\tparamTypes, paramNames, candidate, autowiring, candidates.length \u003d\u003d 1);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (resolvedValues !\u003d null){\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n \t\t\t\t\t\tthis.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tthis.beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d": {
      "type": "Ybodychange",
      "commitMessage": "Always use \u0027this.\u0027 when accessing fields\n\nEnsure that `this.` is used consistently when accessing class\nfields.\n\nIssue: SPR-16968\n",
      "commitDate": "2018-06-28, 4:28 a.m.",
      "commitName": "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2018-05-29, 3:51 p.m.",
      "commitNameOld": "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 29.53,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[0]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n\t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tminNrOfArgs \u003d 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (explicitArgs !\u003d null){\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (resolvedValues !\u003d null){\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n\t\t\t\t\t\tthis.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args),\n\t\t\t\t\t\tthis.beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,238 +1,238 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[0]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n \t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tminNrOfArgs \u003d 0;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (explicitArgs !\u003d null){\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (resolvedValues !\u003d null){\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n-\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n-\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n+\t\t\t\t\t\tthis.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args),\n+\t\t\t\t\t\tthis.beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "74fcdea2d96e6c88d232c487e6e2ca6b9978773a": {
      "type": "Ybodychange",
      "commitMessage": "SimpleAliasRegistry logs info message for alias overriding\n\nIssue: SPR-16871\n",
      "commitDate": "2018-05-29, 3:51 p.m.",
      "commitName": "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018-02-25, 7:14 a.m.",
      "commitNameOld": "c782075a13596a20eb3877cced2421b40246392e",
      "commitAuthorOld": "igor-suhorukov",
      "daysBetweenCommits": 93.32,
      "commitsBetweenForRepo": 476,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[0]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n\t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tminNrOfArgs \u003d 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (explicitArgs !\u003d null){\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (resolvedValues !\u003d null){\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,239 +1,238 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[0]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n \t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tminNrOfArgs \u003d 0;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (explicitArgs !\u003d null){\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n-\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n-\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n-\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n+\t\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\t\tlogger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (resolvedValues !\u003d null){\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n \t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a5cbf5fe246e362c939db006cb44793b22bdc741": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of Collection.toArray with zero-sized array argument\n\nIncludes consistent use of ClassUtils.toClassArray (as non-null variant)\n\nIssue: SPR-16523\n",
      "commitDate": "2018-02-22, 5:29 a.m.",
      "commitName": "a5cbf5fe246e362c939db006cb44793b22bdc741",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-11-13, 3:51 p.m.",
      "commitNameOld": "b5cedd43eb2b70510729696554bbc1f99003ac10",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 100.57,
      "commitsBetweenForRepo": 420,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[0]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n\t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tminNrOfArgs \u003d 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (explicitArgs !\u003d null){\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (resolvedValues !\u003d null){\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,239 +1,239 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n+\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[0]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n \t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tminNrOfArgs \u003d 0;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (explicitArgs !\u003d null){\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (resolvedValues !\u003d null){\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n \t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b5cedd43eb2b70510729696554bbc1f99003ac10": {
      "type": "Ybodychange",
      "commitMessage": "Consistent and efficient access to BeanDefinition argument values\n\nIssue: SPR-16192\n",
      "commitDate": "2017-11-13, 3:51 p.m.",
      "commitName": "b5cedd43eb2b70510729696554bbc1f99003ac10",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-09-27, 6:31 p.m.",
      "commitNameOld": "ec345bf162285e397df774bdc2ad756e3aba155a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 46.93,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n\t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tminNrOfArgs \u003d 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (explicitArgs !\u003d null){\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (resolvedValues !\u003d null){\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,235 +1,239 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n-\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n-\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n-\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+\t\t\t\tif (mbd.hasConstructorArgumentValues()) {\n+\t\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n+\t\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n+\t\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tminNrOfArgs \u003d 0;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n-\t\t\t\t\tif (resolvedValues !\u003d null) {\n+\t\t\t\t\tif (explicitArgs !\u003d null){\n+\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n+\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\telse {\n-\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n-\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n-\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n-\t\t\t\t\t}\n-\n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse {\n+\t\t\t\telse if (resolvedValues !\u003d null){\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n \t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b94302b5bde7475b9926dacb9fb69f3c8c894444": {
      "type": "Ybodychange",
      "commitMessage": "Enforce non-null value from getBean and at injection points\n\nBean-derived null values may still get passed into bean properties and injection points but only if those are declared as non-required. Note that getBean will never return null; a manual bean.equals(null) / \"null\".equals(bean.toString()) check identifies expected null values now.  This will only ever happen with custom FactoryBeans or factory methods returning null - and since all common cases are handled by autowiring or bean property values in bean definitions, there should be no need to ever manually check for such a null value received from getBean.\n\nIssue: SPR-15829\n",
      "commitDate": "2017-08-17, 6:11 p.m.",
      "commitName": "b94302b5bde7475b9926dacb9fb69f3c8c894444",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-06-07, 8:19 a.m.",
      "commitNameOld": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 71.41,
      "commitsBetweenForRepo": 370,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 351,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,238 +1,235 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n \t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n \t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n-\t\t\tif (beanInstance \u003d\u003d null) {\n-\t\t\t\treturn null;\n-\t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017-06-07, 8:19 a.m.",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-05-31, 3:42 p.m.",
      "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 6.69,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,246 +1,238 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n-\t\t\tif (factoryBean \u003d\u003d null) {\n-\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n-\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n-\t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n-\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n-\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n-\t\t\t\t\t}\n-\t\t\t\t}, beanFactory.getAccessControlContext());\n+\t\t\t\tbeanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e\n+\t\t\t\t\t\tbeanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),\n+\t\t\t\t\t\tbeanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "87598f48e41d483745aba56cbf4e998c6f6d680c": {
      "type": "Yparametermetachange",
      "commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
      "commitDate": "2017-05-27, 2:57 a.m.",
      "commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2016-11-07, 12:00 p.m.",
      "commitNameOld": "cf479bf893df758b54f1a7117a7eae9a32728ab7",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 200.58,
      "commitsBetweenForRepo": 1145,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 358,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,246 +1,246 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n-\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n+\t\t\tfinal String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](modifiers-final)]",
        "newValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](annotations-@Nullable__modifiers-final)]"
      }
    },
    "cf479bf893df758b54f1a7117a7eae9a32728ab7": {
      "type": "Ybodychange",
      "commitMessage": "Consistent throwing of BeanCreationExceptions (and reflection exceptions)\n\nIssue: SPR-14883\n(cherry picked from commit b42d731)\n",
      "commitDate": "2016-11-07, 12:00 p.m.",
      "commitName": "cf479bf893df758b54f1a7117a7eae9a32728ab7",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-07-24, 9:34 a.m.",
      "commitNameOld": "ed49ce838ee00df24e6aa89892ee168761c206d2",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 106.14,
      "commitsBetweenForRepo": 539,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,247 +1,246 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n-\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n-\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n+\t\t\t\tthrow new ImplicitlyAppearedSingletonException();\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39e3f2ebf6690b72b7a8af852a35df6ff6229515": {
      "type": "Ybodychange",
      "commitMessage": "MethodParameter supports Java 8 Executable/Parameter and validates parameter indexes\n\nAlso, equals insists on the same class now, differentiating from SynthesizingMethodParameter.\n\nIssue: SPR-14055\nIssue: SPR-13456\nIssue: SPR-14438\n",
      "commitDate": "2016-07-06, 6:37 p.m.",
      "commitName": "39e3f2ebf6690b72b7a8af852a35df6ff6229515",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-07-05, 11:00 a.m.",
      "commitNameOld": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 1.32,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,247 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n-\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n+\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
      "type": "Ybodychange",
      "commitMessage": "Explicit type can be replaced by \u003c\u003e\n\nIssue: SPR-13188\n",
      "commitDate": "2016-07-05, 11:00 a.m.",
      "commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2016-04-07, 8:18 a.m.",
      "commitNameOld": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 89.11,
      "commitsBetweenForRepo": 357,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,247 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n-\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n+\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n-\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n+\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003c\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n-\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n+\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n-\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n+\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n+\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a": {
      "type": "Ybodychange",
      "commitMessage": "BeanFactory does not unwrap java.util.Optional for top-level bean\n\nIssue: SPR-14121\n",
      "commitDate": "2016-04-07, 8:18 a.m.",
      "commitName": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-03-18, 1:51 p.m.",
      "commitNameOld": "431ca9314af6929a53b177640522323602e6d224",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 19.77,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setBeanInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,247 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tbw.setWrappedInstance(beanInstance);\n+\t\t\tbw.setBeanInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b944283354f0f340ffc7ec74b430d79703a4294a": {
      "type": "Ybodychange",
      "commitMessage": "ConstructorResolver exposes parameter signature from user-declared class (in case of a CGLIB-generated subclass)\n\nIssue: SPR-14015\n",
      "commitDate": "2016-03-11, 6:52 a.m.",
      "commitName": "b944283354f0f340ffc7ec74b430d79703a4294a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-02-26, 6:31 a.m.",
      "commitNameOld": "8a83af55b8adf833683b8d9a6924eecf69709a12",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 14.02,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,248 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n-\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n-\t\t\t\tMethod candidate \u003d candidates[i];\n+\t\t\tfor (Method candidate : candidates) {\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n \t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t}\n \t\t\t\t\tthrow ex;\n \t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8a83af55b8adf833683b8d9a6924eecf69709a12": {
      "type": "Ybodychange",
      "commitMessage": "Consistent resolution of factory method exceptions\n\nIssue: SPR-13985\n",
      "commitDate": "2016-02-26, 6:31 a.m.",
      "commitName": "8a83af55b8adf833683b8d9a6924eecf69709a12",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-02-25, 3:36 p.m.",
      "commitNameOld": "b6dd8a923365f021af636705e652a725e1cf0ebe",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.62,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,251 +1,248 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n-\t\t\tList\u003cException\u003e causes \u003d null;\n+\t\t\tLinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n-\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n-\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n-\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tthrow ex;\n+\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n+\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n+\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n-\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n-\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tcauses.add(ex);\n-\t\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcauses.add(ex);\n+\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n+\t\t\t\tif (causes !\u003d null) {\n+\t\t\t\t\tUnsatisfiedDependencyException ex \u003d causes.removeLast();\n+\t\t\t\t\tfor (Exception cause : causes) {\n+\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow ex;\n+\t\t\t\t}\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": {
      "type": "Ybodychange",
      "commitMessage": "Class identity comparisons wherever possible\n\nIssue: SPR-12926\n",
      "commitDate": "2015-05-20, 8:34 a.m.",
      "commitName": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-12-23, 11:35 a.m.",
      "commitNameOld": "d55af2b445cd3b1c08a7038de4db8e903c36083f",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 147.83,
      "commitsBetweenForRepo": 632,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,251 +1,251 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n-\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n+\t\t\telse if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad62b2afb145499d384cb76c5f254113db99796c": {
      "type": "Ybodychange",
      "commitMessage": "Consistent throwing of BeanInstantiationException for factory methods, including a hint about circular references\n\nIssue: SPR-12317\n",
      "commitDate": "2014-10-21, 3:40 p.m.",
      "commitName": "ad62b2afb145499d384cb76c5f254113db99796c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-09-02, 4:13 p.m.",
      "commitNameOld": "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 48.98,
      "commitsBetweenForRepo": 255,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 355,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,250 +1,251 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n \t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n \t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n-\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t\tbeanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n-\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n+\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\"Bean instantiation via factory method failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c9274e01743a87d7fb8519f7772c1b1677ecbe0": {
      "type": "Ybodychange",
      "commitMessage": "LazyInitTargetSource works for @Bean targets as well\n\nIssue: SPR-10508\nIssue: SPR-8080\n",
      "commitDate": "2014-09-02, 4:13 p.m.",
      "commitName": "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-07-04, 4:30 p.m.",
      "commitNameOld": "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 59.99,
      "commitsBetweenForRepo": 375,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 354,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,246 +1,250 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n+\t\t\tif (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n+\t\t\t\tthrow new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" +\n+\t\t\t\t\t\t\"through the creation of the factory bean that its bean definition points to\");\n+\t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b": {
      "type": "Ybodychange",
      "commitMessage": "ConstructorResolver\u0027s exception message on null factory-bean hints at potential BeanPostProcessor involvement\n\nIssue: SPR-11951\n",
      "commitDate": "2014-07-04, 4:30 p.m.",
      "commitName": "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-03-05, 10:16 a.m.",
      "commitNameOld": "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 121.22,
      "commitsBetweenForRepo": 647,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 354,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,246 +1,246 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n-\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n+\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n \t\t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\t\tfor (Object arg : explicitArgs) {\n \t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n \t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n \t\t\t\t\tfor (ValueHolder value : valueHolders) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n \t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad317774fb8e0b1f70e0135e5786c94c2521fb73": {
      "type": "Ybodychange",
      "commitMessage": "instantiateUsingFactoryMethod avoids NPE and reports argument types in case of explicitArgs and resolved generic arguments as well\n\nIssue: SPR-11517\n",
      "commitDate": "2014-03-05, 10:16 a.m.",
      "commitName": "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-02-12, 7:08 p.m.",
      "commitNameOld": "ce39146be8889409898264b8a9389d3d1f0d4258",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 20.63,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n\t\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\t\tfor (Object arg : explicitArgs) {\n\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 354,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,240 +1,246 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(\n \t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \n \t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n-\t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n-\t\t\t\tString argDesc \u003d \"\";\n-\t\t\t\tif (hasArgs) {\n-\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n-\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n-\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n-\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n+\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n+\t\t\t\tif (explicitArgs !\u003d null) {\n+\t\t\t\t\tfor (Object arg : explicitArgs) {\n+\t\t\t\t\t\targTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tSet\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n+\t\t\t\t\tvalueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n+\t\t\t\t\tvalueHolders.addAll(resolvedValues.getGenericArgumentValues());\n+\t\t\t\t\tfor (ValueHolder value : valueHolders) {\n+\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) :\n+\t\t\t\t\t\t\t\t(value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n-\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n+\t\t\t\tString argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n-\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n+\t\t\t\t\t\t(minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "603cdea26e0880a46c697194bf5f1cbe60177f16": {
      "type": "Ybodychange",
      "commitMessage": "resolveFactoryMethodIfPossible considers nonPublicAccessAllowed and SecurityManager\n\nIssue: SPR-11422\n",
      "commitDate": "2014-02-12, 5:48 p.m.",
      "commitName": "603cdea26e0880a46c697194bf5f1cbe60177f16",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013-11-25, 3:52 p.m.",
      "commitNameOld": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 79.08,
      "commitsBetweenForRepo": 450,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\n\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 357,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,255 +1,240 @@\n-\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n+\tpublic BeanWrapper instantiateUsingFactoryMethod(\n+\t\t\tfinal String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n+\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n-\t\t\tMethod[] rawCandidates;\n \n-\t\t\tfinal Class\u003c?\u003e factoryClazz \u003d factoryClass;\n-\t\t\tif (System.getSecurityManager() !\u003d null) {\n-\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic Method[] run() {\n-\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n-\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n-\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n-\t\t\t}\n-\n+\t\t\tMethod[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n-\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n-\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n-\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n+\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n \t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n \t\t\t\t\t// and eventually raise an ambiguity exception.\n \t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n \t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n \t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n \t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n \t\t\t\tString argDesc \u003d \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b093b8495416cd3f05a32add1c671174341bd595": {
      "type": "Ybodychange",
      "commitMessage": "Use non-lenient constructor resolution mode for @Bean methods\n\nSince @Bean methods are never used with externally specified constructor argument values but rather just with autowiring, the non-lenient constructor resolution mode is appropriate in case of an overloaded @Bean method, not performing any type difference weight checks. This change includes a refinement of Spring\u0027s existing non-lenient constructor resolution (which needs to be explicitly turned on and is therefore not well tested), narrowing the conditions for the ambiguity check (only in case of the same number of arguments and not for overridden methods).\n\nIssue: SPR-10988\n",
      "commitDate": "2013-11-03, 6:19 p.m.",
      "commitName": "b093b8495416cd3f05a32add1c671174341bd595",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013-05-13, 6:04 p.m.",
      "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthorOld": "Rob Winch",
      "daysBetweenCommits": 174.05,
      "commitsBetweenForRepo": 656,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass\u003c?\u003e factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class\u003c?\u003e factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n\t\t\t\t\t// and eventually raise an ambiguity exception.\n\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 340,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,247 +1,255 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n-\t\tClass factoryClass;\n+\t\tClass\u003c?\u003e factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n-\t\t\tfinal Class factoryClazz \u003d factoryClass;\n+\t\t\tfinal Class\u003c?\u003e factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n-\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n+\t\t\t\tClass\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n-\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n+\t\t\t\t\t// Find out about ambiguity: In case of the same type difference weight\n+\t\t\t\t\t// for methods with the same number of parameters, collect such candidates\n+\t\t\t\t\t// and eventually raise an ambiguity exception.\n+\t\t\t\t\t// However, only perform that check in non-lenient constructor resolution mode,\n+\t\t\t\t\t// and explicitly ignore overridden methods (with the same parameter signature).\n+\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n+\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution() \u0026\u0026\n+\t\t\t\t\t\t\tparamTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026\n+\t\t\t\t\t\t\t!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n \t\t\t\tString argDesc \u003d \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n-\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n+\t\t\telse if (ambiguousFactoryMethods !\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "94685481162a93666fc2f39b66223833a6bcb418": {
      "type": "Ybodychange",
      "commitMessage": "Add @Override to remaining source files\n\nIssue: SPR-10130\n",
      "commitDate": "2013-05-13, 6:04 p.m.",
      "commitName": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthor": "Rob Winch",
      "commitDateOld": "2013-02-04, 1:35 p.m.",
      "commitNameOld": "f464a45ba481ff3e960ad3dd8b5edd4464a46289",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 98.15,
      "commitsBetweenForRepo": 366,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 340,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,245 +1,247 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n+\t\t\t\t\t@Override\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n \t\t\t\tString argDesc \u003d \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\t\t\t\t\t@Override\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012-01-31, 8:37 a.m.",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012-01-31, 8:37 a.m.",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 339,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
        "newPath": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java"
      }
    },
    "061063257ab8e16786d04eaddb5b5aba61dcd7f1": {
      "type": "Ybodychange",
      "commitMessage": "optimized @Bean error messages (SPR-7628, SPR-7629)\n",
      "commitDate": "2010-10-10, 2:31 p.m.",
      "commitName": "061063257ab8e16786d04eaddb5b5aba61dcd7f1",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-08-19, 5:30 a.m.",
      "commitNameOld": "a9da12325995ab03cef56e8f51870081e36a3c9e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 52.38,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 339,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,245 +1,245 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n+\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n \t\t\t\tString argDesc \u003d \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n-\t\t\tif (explicitArgs \u003d\u003d null) {\n+\t\t\tif (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9da12325995ab03cef56e8f51870081e36a3c9e": {
      "type": "Ybodychange",
      "commitMessage": "temporarily disabled constructor argument caching for converted values (SPR-7423)\n",
      "commitDate": "2010-08-19, 5:30 a.m.",
      "commitName": "a9da12325995ab03cef56e8f51870081e36a3c9e",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-08-18, 5:08 a.m.",
      "commitNameOld": "9857ba077b16312e78ca6dcf2a219326955daae5",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 339,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,245 +1,245 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tObject[] argsToResolve \u003d null;\n \t\t\tsynchronized (mbd.constructorArgumentLock) {\n \t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n \t\t\t\t\t// Found a cached factory method...\n \t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (argsToResolve !\u003d null) {\n \t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n-\t\t\t\tboolean hasArgs  \u003d resolvedValues.getArgumentCount() \u003e 0;\n+\t\t\t\tboolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n \t\t\t\tString argDesc \u003d \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n-\t\t\t\t\t\tString argType \u003d value.getType() !\u003d null ?\n-\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n+\t\t\t\t\t\tString argType \u003d (value.getType() !\u003d null ?\n+\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9857ba077b16312e78ca6dcf2a219326955daae5": {
      "type": "Ybodychange",
      "commitMessage": "revised constructor argument caching for highly concurrent creation scenarios (follow-up to SPR-7423)\n",
      "commitDate": "2010-08-18, 5:08 a.m.",
      "commitName": "9857ba077b16312e78ca6dcf2a219326955daae5",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-08-11, 3:24 p.m.",
      "commitNameOld": "8a23ce917afb6cd19996508521a27f8ea97db29d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tObject[] argsToResolve \u003d null;\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n\t\t\t\t\t// Found a cached factory method...\n\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argsToResolve !\u003d null) {\n\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs  \u003d resolvedValues.getArgumentCount() \u003e 0;\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 340,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,240 +1,245 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n-\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n-\t\t\tif (factoryMethodToUse !\u003d null) {\n-\t\t\t\t// Found a cached factory method...\n-\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n-\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n-\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n+\t\t\tObject[] argsToResolve \u003d null;\n+\t\t\tsynchronized (mbd.constructorArgumentLock) {\n+\t\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n+\t\t\t\tif (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n+\t\t\t\t\t// Found a cached factory method...\n+\t\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n+\t\t\t\t\tif (argsToUse \u003d\u003d null) {\n+\t\t\t\t\t\targsToResolve \u003d mbd.preparedConstructorArguments;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (argsToResolve !\u003d null) {\n+\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n+\t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n \t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tboolean hasArgs  \u003d resolvedValues.getArgumentCount() \u003e 0;\n \t\t\t\tString argDesc \u003d \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType \u003d value.getType() !\u003d null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n-\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n-\t\t\t\targsHolderToUse.storeCache(mbd);\n+\t\t\t\targsHolderToUse.storeCache(mbd, factoryMethodToUse);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "12ce250c6ce911774a7983905fd6e006b5a1eac1": {
      "type": "Ybodychange",
      "commitMessage": "fixed constructor argument caching for prototypes with multiple constructor matches (SPR-7084)\n",
      "commitDate": "2010-04-14, 8:11 a.m.",
      "commitName": "12ce250c6ce911774a7983905fd6e006b5a1eac1",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-03-26, 8:05 a.m.",
      "commitNameOld": "351e72b6e258bd030fb21be253f6348319f81d0e",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 19.0,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tArgumentsHolder argsHolderToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder argsHolder;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs  \u003d resolvedValues.getArgumentCount() \u003e 0;\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t\targsHolderToUse.storeCache(mbd);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 335,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,237 +1,240 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n+\t\tArgumentsHolder argsHolderToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n-\t\t\t\t\tArgumentsHolder args;\n+\t\t\t\t\tArgumentsHolder argsHolder;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\targs \u003d createArgumentArray(\n+\t\t\t\t\t\t\targsHolder \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n+\t\t\t\t\t\targsHolder \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n-\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n+\t\t\t\t\t\t\targsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n-\t\t\t\t\t\targsToUse \u003d args.arguments;\n+\t\t\t\t\t\targsHolderToUse \u003d argsHolder;\n+\t\t\t\t\t\targsToUse \u003d argsHolder.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tboolean hasArgs  \u003d resolvedValues.getArgumentCount() \u003e 0;\n \t\t\t\tString argDesc \u003d \"\";\n \t\t\t\tif (hasArgs) {\n \t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n \t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n \t\t\t\t\t\tString argType \u003d value.getType() !\u003d null ?\n \t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n \t\t\t\t\t\targTypes.add(argType);\n \t\t\t\t\t}\n \t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n \t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n \t\t\t\t\t\t\"Check that a method with the specified name \" +\n \t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n \t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n+\t\t\t\targsHolderToUse.storeCache(mbd);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "351e72b6e258bd030fb21be253f6348319f81d0e": {
      "type": "Ybodychange",
      "commitMessage": "incorrectly invoked factory methods now result in exceptions with more descriptive messages (SPR-5475)\n",
      "commitDate": "2010-03-26, 8:05 a.m.",
      "commitName": "351e72b6e258bd030fb21be253f6348319f81d0e",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2010-02-15, 8:01 a.m.",
      "commitNameOld": "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 38.96,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tboolean hasArgs  \u003d resolvedValues.getArgumentCount() \u003e 0;\n\t\t\t\tString argDesc \u003d \"\";\n\t\t\t\tif (hasArgs) {\n\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n\t\t\t\t\t\tString argType \u003d value.getType() !\u003d null ?\n\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n\t\t\t\t\t\targTypes.add(argType);\n\t\t\t\t\t}\n\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n\t\t\t\t}\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n\t\t\t\t\t\t\"Check that a method with the specified name \" +\n\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n\t\t\t\t\t\t\"exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 334,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,224 +1,237 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n+\t\t\t\tboolean hasArgs  \u003d resolvedValues.getArgumentCount() \u003e 0;\n+\t\t\t\tString argDesc \u003d \"\";\n+\t\t\t\tif (hasArgs) {\n+\t\t\t\t\tList\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n+\t\t\t\t\tfor (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n+\t\t\t\t\t\tString argType \u003d value.getType() !\u003d null ?\n+\t\t\t\t\t\t\t\tClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n+\t\t\t\t\t\targTypes.add(argType);\n+\t\t\t\t\t}\n+\t\t\t\t\targDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n+\t\t\t\t}\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n-\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n-\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027. \" +\n-\t\t\t\t\t\t\"Check that a method of the specified name exists and that it is \" +\n+\t\t\t\t\t\t\t\"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n+\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" +\n+\t\t\t\t\t\t\"Check that a method with the specified name \" +\n+\t\t\t\t\t\t(hasArgs ? \"and arguments \" : \"\") +\n+\t\t\t\t\t\t\"exists and that it is \" +\n \t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "18bd4a83375a1815dbf83aca384cf7f5c27e93f5": {
      "type": "Ybodychange",
      "commitMessage": "improved \"no matching factory method found\" exception message (SPR-6837)\n",
      "commitDate": "2010-02-15, 8:01 a.m.",
      "commitName": "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-01-20, 4:29 a.m.",
      "commitNameOld": "45448463b87629bdd85cb375d3faa391bfaf147f",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 26.15,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027. \" +\n\t\t\t\t\t\t\"Check that a method of the specified name exists and that it is \" +\n\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 330,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,222 +1,224 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n-\t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n+\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n-\t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n-\t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n-\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n+\t\t\t\t\t\tif (ambiguousFactoryMethods \u003d\u003d null) {\n+\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n+\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n+\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n-\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n+\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027. \" +\n+\t\t\t\t\t\t\"Check that a method of the specified name exists and that it is \" +\n+\t\t\t\t\t\t(isStatic ? \"static\" : \"non-static\") + \".\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45448463b87629bdd85cb375d3faa391bfaf147f": {
      "type": "Ybodychange",
      "commitMessage": "collect exceptions across all constructors that have been tried (SPR-6720)\n",
      "commitDate": "2010-01-20, 4:29 a.m.",
      "commitName": "45448463b87629bdd85cb375d3faa391bfaf147f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-08-27, 6:45 a.m.",
      "commitNameOld": "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 145.95,
      "commitsBetweenForRepo": 967,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates;\n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 330,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,222 +1,222 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n-\t\t\tMethod[] rawCandidates \u003d null; \n+\t\t\tMethod[] rawCandidates;\n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance;\n \n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "904c2358cdfd9cd8337da0950b8c8d6fc7099839": {
      "type": "Ybodychange",
      "commitMessage": "adapted to changes in non-lenient mode\n",
      "commitDate": "2009-08-27, 6:45 a.m.",
      "commitName": "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-08-27, 5:47 a.m.",
      "commitNameOld": "015284af7cf8eff979cd0c5e5ad3d189915e98a9",
      "commitAuthorOld": "Costin Leau",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d null; \n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance;\n\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 332,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,226 +1,222 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates \u003d null; \n \n \t\t\tfinal Class factoryClazz \u003d factoryClass;\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n-\t\t\t\t\n \t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \t\t\t\t\tpublic Method[] run() {\n \t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t}\n \t\t\telse {\n \t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n \t\t\t}\n \t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n-\t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n+\t\t\tSet\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n-\t\t\t\n-\t\t\tObject beanInstance \u003d null;\n-\t\t\t\n+\t\t\tObject beanInstance;\n+\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n-\t\t\t\t\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\t\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af8af8c633ba016eca671bc9468eba006e8834b1": {
      "type": "Ybodychange",
      "commitMessage": "+ added fine grained privileged blocks to preserve the caller security stack when invoking the callee\n",
      "commitDate": "2009-08-06, 6:31 p.m.",
      "commitName": "af8af8c633ba016eca671bc9468eba006e8834b1",
      "commitAuthor": "Costin Leau",
      "commitDateOld": "2009-08-06, 3:08 p.m.",
      "commitNameOld": "81eb11486dad59e4a42566f9f7760d85396790b0",
      "commitAuthorOld": "Costin Leau",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d null; \n\n\t\t\tfinal Class factoryClazz \u003d factoryClass;\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\n\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\t\t\t\t\tpublic Method[] run() {\n\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n\t\t\t}\n\t\t\t\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t\n\t\t\tObject beanInstance \u003d null;\n\t\t\t\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\t\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 334,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,211 +1,226 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n-\t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n-\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n+\t\t\tMethod[] rawCandidates \u003d null; \n+\n+\t\t\tfinal Class factoryClazz \u003d factoryClass;\n+\t\t\tif (System.getSecurityManager() !\u003d null) {\n+\t\t\t\t\n+\t\t\t\trawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n+\t\t\t\t\tpublic Method[] run() {\n+\t\t\t\t\t\treturn (mbd.isNonPublicAccessAllowed() ?\n+\t\t\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\trawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n+\t\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n+\t\t\t}\n+\t\t\t\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\t\n \t\t\tObject beanInstance \u003d null;\n \t\t\t\n \t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\tfinal Object fb \u003d factoryBean;\n \t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n \t\t\t\tfinal Object[] args \u003d argsToUse;\n \t\t\t\t\n \t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\n \t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n \t\t\t\t\t}\n \t\t\t\t}, beanFactory.getAccessControlContext());\n \t\t\t}\n \t\t\telse {\n \t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\t}\n \t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
      "commitDate": "2009-08-06, 12:34 p.m.",
      "commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
      "commitAuthor": "Costin Leau",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
          "commitDate": "2009-08-06, 12:34 p.m.",
          "commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
          "commitAuthor": "Costin Leau",
          "commitDateOld": "2009-07-29, 12:43 p.m.",
          "commitNameOld": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 7.99,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t\n\t\t\tObject beanInstance \u003d null;\n\t\t\t\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\t\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
          "functionStartLine": 334,
          "functionName": "instantiateUsingFactoryMethod",
          "diff": "@@ -1,192 +1,211 @@\n-\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n-\t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n-\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t\n+\t\t\tObject beanInstance \u003d null;\n+\t\t\t\n+\t\t\tif (System.getSecurityManager() !\u003d null) {\n+\t\t\t\tfinal Object fb \u003d factoryBean;\n+\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n+\t\t\t\tfinal Object[] args \u003d argsToUse;\n+\t\t\t\t\n+\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\t\n+\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n+\t\t\t\t\t}\n+\t\t\t\t}, beanFactory.getAccessControlContext());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t}\n+\t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
          "commitDate": "2009-08-06, 12:34 p.m.",
          "commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
          "commitAuthor": "Costin Leau",
          "commitDateOld": "2009-07-29, 12:43 p.m.",
          "commitNameOld": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 7.99,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t\n\t\t\tObject beanInstance \u003d null;\n\t\t\t\n\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\tfinal Object fb \u003d factoryBean;\n\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n\t\t\t\tfinal Object[] args \u003d argsToUse;\n\t\t\t\t\n\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\n\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n\t\t\t\t\t}\n\t\t\t\t}, beanFactory.getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\t}\n\t\t\t\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
          "functionStartLine": 334,
          "functionName": "instantiateUsingFactoryMethod",
          "diff": "@@ -1,192 +1,211 @@\n-\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+\tpublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n \t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n \t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n \t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n \t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n \t\t\t\t\t\tambiguousFactoryMethods);\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n-\t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n-\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t\n+\t\t\tObject beanInstance \u003d null;\n+\t\t\t\n+\t\t\tif (System.getSecurityManager() !\u003d null) {\n+\t\t\t\tfinal Object fb \u003d factoryBean;\n+\t\t\t\tfinal Method factoryMethod \u003d factoryMethodToUse;\n+\t\t\t\tfinal Object[] args \u003d argsToUse;\n+\t\t\t\t\n+\t\t\t\tbeanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\t\n+\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\treturn beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\t\t\tmbd, beanName, beanFactory, fb, factoryMethod, args);\n+\t\t\t\t\t}\n+\t\t\t\t}, beanFactory.getAccessControlContext());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tbeanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(\n+\t\t\t\t\t\tmbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\t}\n+\t\t\t\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[beanName-String, mbd-RootBeanDefinition, explicitArgs-Object[]]",
            "newValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](modifiers-final)]"
          }
        }
      ]
    },
    "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2": {
      "type": "Ybodychange",
      "commitMessage": "fixed constructor resolution algorithm to trigger ambiguity exception as late as possible\n",
      "commitDate": "2009-07-29, 12:43 p.m.",
      "commitName": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-07-28, 10:43 a.m.",
      "commitNameOld": "3cb073abce659c130abc9adc0662b75380fcc7f3",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n\t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n\t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n\t\t\t\t\t\tambiguousFactoryMethods);\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 314,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,183 +1,192 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n+\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n-\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n+\t\t\tSet\u003cMethod\u003e \tambiguousFactoryMethods \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n \t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n \t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n+\t\t\t\t\t\t\tambiguousFactoryMethods \u003d null;\n \t\t\t\t\t}\n-\t\t\t\t\telse if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n-\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution()) {\n-\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n-\t\t\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n-\t\t\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n+\t\t\t\t\telse if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n+\t\t\t\t\t\tif (\tambiguousFactoryMethods \u003d\u003d null) {\n+\t\t\t\t\t\t\t\tambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n+\t\t\t\t\t\t\t\tambiguousFactoryMethods.add(factoryMethodToUse);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tambiguousFactoryMethods.add(candidate);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n-\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n+\t\t\telse if (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n+\t\t\telse if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n+\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n+\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" +\n+\t\t\t\t\t\tambiguousFactoryMethods);\n+\t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3cb073abce659c130abc9adc0662b75380fcc7f3": {
      "type": "Ybodychange",
      "commitMessage": "revised non-lenient resolution\n",
      "commitDate": "2009-07-28, 10:43 a.m.",
      "commitName": "3cb073abce659c130abc9adc0662b75380fcc7f3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-07-27, 10:09 a.m.",
      "commitNameOld": "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n\t\t\t\t\t// Choose this factory method if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution()) {\n\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 305,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,182 +1,183 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n-\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n-\t\t\t\t\t// Choose this constructor if it represents the closest match.\n+\t\t\t\t\tint typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ?\n+\t\t\t\t\t\t\targs.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n+\t\t\t\t\t// Choose this factory method if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t\telse if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n \t\t\t\t\t\t\t!mbd.isLenientConstructorResolution()) {\n \t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n \t\t\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1eabe2b4416ee7619bd863fcdc1e6f6ada766400": {
      "type": "Ybodychange",
      "commitMessage": "lenientConstructorResolution flag applies to factory methods as well\n",
      "commitDate": "2009-07-27, 10:09 a.m.",
      "commitName": "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-07-16, 1:22 p.m.",
      "commitNameOld": "8e2797153bf3d4eb7fbc679907dc06700c0595f4",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 10.87,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution()) {\n\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n\t\t\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 304,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,176 +1,182 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n \t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n+\t\t\t\t\telse if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026\n+\t\t\t\t\t\t\t!mbd.isLenientConstructorResolution()) {\n+\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\t\t\"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" +\n+\t\t\t\t\t\t\t\t\"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7eabd2da563a4e95928e89f72f7a207804eef0ab": {
      "type": "Ybodychange",
      "commitMessage": "introduced \"nonPublicAccessAllowed\" flag (SPR-5882)\n",
      "commitDate": "2009-07-16, 11:52 a.m.",
      "commitName": "7eabd2da563a4e95928e89f72f7a207804eef0ab",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-07-16, 9:27 a.m.",
      "commitNameOld": "a9254b34d19237f5fde7ceedec2126b08cf48e4d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 304,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,175 +1,176 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n-\t\t\tMethod[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+\t\t\tMethod[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ?\n+\t\t\t\t\tReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tString[] paramNames \u003d null;\n \t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n \t\t\t\t\t\t\tif (pnd !\u003d null) {\n \t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53333c3ed06e465a55592a0f351ffab40110e5b3": {
      "type": "Ybodychange",
      "commitMessage": "XML constructor-arg element allows for specifying a constructor argument by name now, with target argument names read from the class file via ASM or from Java 6\u0027s @ConstructorProperties annotation (SPR-3313)\n",
      "commitDate": "2009-06-03, 6:21 a.m.",
      "commitName": "53333c3ed06e465a55592a0f351ffab40110e5b3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-22, 6:46 a.m.",
      "commitNameOld": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 41.98,
      "commitsBetweenForRepo": 258,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString[] paramNames \u003d null;\n\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n\t\t\t\t\t\t\tif (pnd !\u003d null) {\n\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 297,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,170 +1,175 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n-\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n+\t\t\t\t\t\t// Resolved constructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tString[] paramNames \u003d null;\n+\t\t\t\t\t\t\tParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n+\t\t\t\t\t\t\tif (pnd !\u003d null) {\n+\t\t\t\t\t\t\t\tparamNames \u003d pnd.getParameterNames(candidate);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n-\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n+\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n-\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n+\t\t\tObject beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": {
      "type": "Ybodychange",
      "commitMessage": "next cut of JavaConfig metadata reading revision: using cached MetadataReaders\n",
      "commitDate": "2009-04-22, 6:46 a.m.",
      "commitName": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-19, 7:45 p.m.",
      "commitNameOld": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.46,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 296,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,169 +1,170 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tif (!mbd.hasBeanClass()) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n \t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n-\t\t\t\tif (argsToUse \u003d\u003d null) {\n+\t\t\t\tif (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (factoryMethodToUse \u003d\u003d null) {\n+\t\tif (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n \t\t\tMethod[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n \t\t\tfor (Method candidate : rawCandidates) {\n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n-\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName())) {\n+\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n+\t\t\t\t\t\tmbd.isFactoryMethod(candidate)) {\n \t\t\t\t\tcandidateSet.add(candidate);\n \t\t\t\t}\n \t\t\t}\n \t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n \t\t\tAutowireUtils.sortFactoryMethods(candidates);\n \n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14bd47551900ced88eeacf2a5f63c187ff72028c": {
      "type": "Ybodychange",
      "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
      "commitDate": "2009-04-19, 7:45 p.m.",
      "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-03-23, 10:13 a.m.",
      "commitNameOld": "4344832a479831e7e67de1a9e81d52d023cd59ac",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 27.4,
      "commitsBetweenForRepo": 234,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tif (!mbd.hasBeanClass()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n\t\t\t}\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n\t\t\tMethod[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n\t\t\tfor (Method candidate : rawCandidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName())) {\n\t\t\t\t\tcandidateSet.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 265,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,157 +1,169 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n+\t\t\tif (!mbd.hasBeanClass()) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"bean definition declares neither a bean class nor a factory-bean reference\");\n+\t\t\t}\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n-\t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+\t\t\tfactoryClass \u003d ClassUtils.getUserClass(factoryClass);\n+\t\t\tMethod[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+\t\t\tList\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n+\t\t\tfor (Method candidate : rawCandidates) {\n+\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n+\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName())) {\n+\t\t\t\t\tcandidateSet.add(candidate);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tMethod[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n+\t\t\tAutowireUtils.sortFactoryMethods(candidates);\n+\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n-\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n-\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n-\t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n-\n+\t\t\t\tif (paramTypes.length \u003e\u003d minNrOfArgs) {\n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4344832a479831e7e67de1a9e81d52d023cd59ac": {
      "type": "Ybodychange",
      "commitMessage": "qualifier annotations and @Value can be used at method level as well (applying to all parameters); \nfixed EL evaluation of prepared constructor arguments for repeated prototype creation\n",
      "commitDate": "2009-03-23, 10:13 a.m.",
      "commitName": "4344832a479831e7e67de1a9e81d52d023cd59ac",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-02-25, 5:07 a.m.",
      "commitNameOld": "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 26.17,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 263,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,174 +1,157 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tObject factoryBean;\n \t\tClass factoryClass;\n \t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null) {\n-\t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n-\t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n-\t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n-\t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n-\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n-\t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n-\t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n-\t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n-\t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n-\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n-\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n-\t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n-\t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n-\t\t\t\t\t}\n+\t\t\t\t\targsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n \n \t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "092de0107cd876d7f8207da7a9fc9ba163cfadfe": {
      "type": "Ybodychange",
      "commitMessage": "improved NoClassDefFoundError handling during constructor resolution (SPR-5522)\n",
      "commitDate": "2009-02-25, 5:07 a.m.",
      "commitName": "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008-11-20, 12:33 p.m.",
      "commitNameOld": "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 96.69,
      "commitsBetweenForRepo": 373,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tObject factoryBean;\n\t\tClass factoryClass;\n\t\tboolean isStatic;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tfactoryBean \u003d null;\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t\tisStatic \u003d true;\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n\t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n\t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n\t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n\t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n\t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n\n\t\t\t\t\tArgumentsHolder args;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 279,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,172 +1,174 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n-\t\tClass factoryClass \u003d null;\n-\t\tObject factoryBean \u003d null;\n-\t\tboolean isStatic \u003d true;\n+\t\tObject factoryBean;\n+\t\tClass factoryClass;\n+\t\tboolean isStatic;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n+\t\t\tfactoryBean \u003d null;\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n+\t\t\tisStatic \u003d true;\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n \t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n \t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n \t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n \t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n \t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n \t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n \t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n \t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n \t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n \t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n \t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n-\t\t\tint minNrOfArgs \u003d 0;\n+\t\t\tint minNrOfArgs;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n \n-\t\t\t\t\tArgumentsHolder args \u003d null;\n+\t\t\t\t\tArgumentsHolder args;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "05bebb0c056714d97b479cf6c5552ba3c5b06d9c": {
      "type": "Ybodychange",
      "commitMessage": "completed value annotation support; Java 5 code style updates\n",
      "commitDate": "2008-11-20, 12:33 p.m.",
      "commitName": "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008-11-19, 9:10 p.m.",
      "commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.64,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tClass factoryClass \u003d null;\n\t\tObject factoryBean \u003d null;\n\t\tboolean isStatic \u003d true;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n\t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n\t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n\t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n\t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n\t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs \u003d 0;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList\u003cException\u003e causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n\n\t\t\t\t\tArgumentsHolder args \u003d null;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 269,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,172 +1,172 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tClass factoryClass \u003d null;\n \t\tObject factoryBean \u003d null;\n \t\tboolean isStatic \u003d true;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n \t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n \t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n \t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n \t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n \t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n \t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n \t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n \t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n \t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n \t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n \t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs \u003d 0;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n-\t\t\tList causes \u003d null;\n+\t\t\tList\u003cException\u003e causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n \n \t\t\t\t\tArgumentsHolder args \u003d null;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n-\t\t\t\t\t\t\t\t\tfor (Iterator it \u003d causes.iterator(); it.hasNext();) {\n-\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException((Exception) it.next());\n+\t\t\t\t\t\t\t\t\tfor (Exception cause : causes) {\n+\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException(cause);\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n-\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList();\n+\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList\u003cException\u003e();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
      "type": "Ybodychange",
      "commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
      "commitDate": "2008-11-19, 9:10 p.m.",
      "commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008-10-22, 12:13 p.m.",
      "commitNameOld": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 28.41,
      "commitsBetweenForRepo": 194,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tClass factoryClass \u003d null;\n\t\tObject factoryBean \u003d null;\n\t\tboolean isStatic \u003d true;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n\t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n\t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n\t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n\t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n\t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs \u003d 0;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n\n\t\t\t\t\tArgumentsHolder args \u003d null;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Iterator it \u003d causes.iterator(); it.hasNext();) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException((Exception) it.next());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 270,
      "functionName": "instantiateUsingFactoryMethod",
      "diff": "@@ -1,174 +1,172 @@\n \tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n \t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n \t\tthis.beanFactory.initBeanWrapper(bw);\n \n \t\tClass factoryClass \u003d null;\n \t\tObject factoryBean \u003d null;\n \t\tboolean isStatic \u003d true;\n \n \t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n \t\tif (factoryBeanName !\u003d null) {\n \t\t\tif (factoryBeanName.equals(beanName)) {\n \t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n \t\t\t}\n \t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n \t\t\tif (factoryBean \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n \t\t\t}\n \t\t\tfactoryClass \u003d factoryBean.getClass();\n \t\t\tisStatic \u003d false;\n \t\t}\n \t\telse {\n \t\t\t// It\u0027s a static factory method on the bean class.\n \t\t\tfactoryClass \u003d mbd.getBeanClass();\n \t\t}\n \n \t\tMethod factoryMethodToUse \u003d null;\n \t\tObject[] argsToUse \u003d null;\n \n \t\tif (explicitArgs !\u003d null) {\n \t\t\targsToUse \u003d explicitArgs;\n \t\t}\n \t\telse {\n \t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n \t\t\tif (factoryMethodToUse !\u003d null) {\n \t\t\t\t// Found a cached factory method...\n \t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n \t\t\t\tif (argsToUse \u003d\u003d null) {\n \t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n \t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n \t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n \t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n \t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n \t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n \t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n \t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n \t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n-\t\t\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n-\t\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n \t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n \t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n \t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n \t\t\t\t\t\t}\n \t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t// Need to determine the factory method...\n \t\t\t// Try all methods with this name to see if they match the given arguments.\n \t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n \t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n \t\t\tConstructorArgumentValues resolvedValues \u003d null;\n \n \t\t\tint minNrOfArgs \u003d 0;\n \t\t\tif (explicitArgs !\u003d null) {\n \t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n \t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n \t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n \t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n \t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n \t\t\t}\n \n \t\t\tList causes \u003d null;\n \n \t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n \t\t\t\tMethod candidate \u003d candidates[i];\n \t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n \n \t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n \t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n \t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n \n \t\t\t\t\tArgumentsHolder args \u003d null;\n \n \t\t\t\t\tif (resolvedValues !\u003d null) {\n \t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\targs \u003d createArgumentArray(\n \t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n \t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n \t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n \t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n \t\t\t\t\t\t\t\tif (causes !\u003d null) {\n \t\t\t\t\t\t\t\t\tfor (Iterator it \u003d causes.iterator(); it.hasNext();) {\n \t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException((Exception) it.next());\n \t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tthrow ex;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n \t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n \t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcauses.add(ex);\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\telse {\n \t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n \t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n \t\t\t\t\t}\n \n \t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n \t\t\t\t\t// Choose this constructor if it represents the closest match.\n \t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n \t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n \t\t\t\t\t\targsToUse \u003d args.arguments;\n \t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (factoryMethodToUse \u003d\u003d null) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"No matching factory method found: \" +\n \t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n \t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n \t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n \t\t\t}\n \t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n \t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n \t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n \t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n \t\t\t}\n \n \t\t\tif (explicitArgs \u003d\u003d null) {\n \t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n \t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n \t\t\tif (beanInstance \u003d\u003d null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tbw.setWrappedInstance(beanInstance);\n \t\t\treturn bw;\n \t\t}\n \t\tcatch (Throwable ex) {\n \t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
      "type": "Yintroduced",
      "commitMessage": "Moved over initial version of beans bundle\n",
      "commitDate": "2008-10-22, 12:13 p.m.",
      "commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthor": "Arjen Poutsma",
      "diff": "@@ -0,0 +1,174 @@\n+\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n+\t\tthis.beanFactory.initBeanWrapper(bw);\n+\n+\t\tClass factoryClass \u003d null;\n+\t\tObject factoryBean \u003d null;\n+\t\tboolean isStatic \u003d true;\n+\n+\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n+\t\tif (factoryBeanName !\u003d null) {\n+\t\t\tif (factoryBeanName.equals(beanName)) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n+\t\t\t}\n+\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n+\t\t\tif (factoryBean \u003d\u003d null) {\n+\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n+\t\t\t}\n+\t\t\tfactoryClass \u003d factoryBean.getClass();\n+\t\t\tisStatic \u003d false;\n+\t\t}\n+\t\telse {\n+\t\t\t// It\u0027s a static factory method on the bean class.\n+\t\t\tfactoryClass \u003d mbd.getBeanClass();\n+\t\t}\n+\n+\t\tMethod factoryMethodToUse \u003d null;\n+\t\tObject[] argsToUse \u003d null;\n+\n+\t\tif (explicitArgs !\u003d null) {\n+\t\t\targsToUse \u003d explicitArgs;\n+\t\t}\n+\t\telse {\n+\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n+\t\t\tif (factoryMethodToUse !\u003d null) {\n+\t\t\t\t// Found a cached factory method...\n+\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n+\t\t\t\tif (argsToUse \u003d\u003d null) {\n+\t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n+\t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n+\t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n+\t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n+\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n+\t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n+\t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n+\t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n+\t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n+\t\t\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n+\t\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n+\t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n+\t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (factoryMethodToUse \u003d\u003d null) {\n+\t\t\t// Need to determine the factory method...\n+\t\t\t// Try all methods with this name to see if they match the given arguments.\n+\t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n+\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n+\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n+\n+\t\t\tint minNrOfArgs \u003d 0;\n+\t\t\tif (explicitArgs !\u003d null) {\n+\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n+\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n+\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n+\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n+\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+\t\t\t}\n+\n+\t\t\tList causes \u003d null;\n+\n+\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n+\t\t\t\tMethod candidate \u003d candidates[i];\n+\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n+\n+\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n+\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n+\t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n+\n+\t\t\t\t\tArgumentsHolder args \u003d null;\n+\n+\t\t\t\t\tif (resolvedValues !\u003d null) {\n+\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\targs \u003d createArgumentArray(\n+\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n+\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n+\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n+\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n+\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n+\t\t\t\t\t\t\t\t\tfor (Iterator it \u003d causes.iterator(); it.hasNext();) {\n+\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException((Exception) it.next());\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tthrow ex;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n+\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n+\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcauses.add(ex);\n+\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\telse {\n+\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n+\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n+\t\t\t\t\t// Choose this constructor if it represents the closest match.\n+\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n+\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n+\t\t\t\t\t\targsToUse \u003d args.arguments;\n+\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n+\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"No matching factory method found: \" +\n+\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n+\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n+\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n+\t\t\t}\n+\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n+\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n+\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n+\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n+\t\t\t}\n+\n+\t\t\tif (explicitArgs \u003d\u003d null) {\n+\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n+\t\t\t}\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n+\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+\t\t\tif (beanInstance \u003d\u003d null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tbw.setWrappedInstance(beanInstance);\n+\t\t\treturn bw;\n+\t\t}\n+\t\tcatch (Throwable ex) {\n+\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n\t\tBeanWrapperImpl bw \u003d new BeanWrapperImpl();\n\t\tthis.beanFactory.initBeanWrapper(bw);\n\n\t\tClass factoryClass \u003d null;\n\t\tObject factoryBean \u003d null;\n\t\tboolean isStatic \u003d true;\n\n\t\tString factoryBeanName \u003d mbd.getFactoryBeanName();\n\t\tif (factoryBeanName !\u003d null) {\n\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t}\n\t\t\tfactoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n\t\t\tif (factoryBean \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n\t\t\t}\n\t\t\tfactoryClass \u003d factoryBean.getClass();\n\t\t\tisStatic \u003d false;\n\t\t}\n\t\telse {\n\t\t\t// It\u0027s a static factory method on the bean class.\n\t\t\tfactoryClass \u003d mbd.getBeanClass();\n\t\t}\n\n\t\tMethod factoryMethodToUse \u003d null;\n\t\tObject[] argsToUse \u003d null;\n\n\t\tif (explicitArgs !\u003d null) {\n\t\t\targsToUse \u003d explicitArgs;\n\t\t}\n\t\telse {\n\t\t\tfactoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n\t\t\tif (factoryMethodToUse !\u003d null) {\n\t\t\t\t// Found a cached factory method...\n\t\t\t\targsToUse \u003d mbd.resolvedConstructorArguments;\n\t\t\t\tif (argsToUse \u003d\u003d null) {\n\t\t\t\t\tClass[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n\t\t\t\t\tObject[] argsToResolve \u003d mbd.preparedConstructorArguments;\n\t\t\t\t\tTypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n\t\t\t\t\tBeanDefinitionValueResolver valueResolver \u003d\n\t\t\t\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\t\t\t\targsToUse \u003d new Object[argsToResolve.length];\n\t\t\t\t\tfor (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n\t\t\t\t\t\tObject argValue \u003d argsToResolve[i];\n\t\t\t\t\t\tMethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n\t\t\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n\t\t\t\t\t\t\tGenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\t\t\t\targValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\t\t\t\targValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t// Need to determine the factory method...\n\t\t\t// Try all methods with this name to see if they match the given arguments.\n\t\t\tMethod[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n\t\t\tboolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\t\tint minTypeDiffWeight \u003d Integer.MAX_VALUE;\n\t\t\tConstructorArgumentValues resolvedValues \u003d null;\n\n\t\t\tint minNrOfArgs \u003d 0;\n\t\t\tif (explicitArgs !\u003d null) {\n\t\t\t\tminNrOfArgs \u003d explicitArgs.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We don\u0027t have arguments passed in programmatically, so we need to resolve the\n\t\t\t\t// arguments specified in the constructor arguments held in the bean definition.\n\t\t\t\tConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n\t\t\t\tresolvedValues \u003d new ConstructorArgumentValues();\n\t\t\t\tminNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n\t\t\t}\n\n\t\t\tList causes \u003d null;\n\n\t\t\tfor (int i \u003d 0; i \u003c candidates.length; i++) {\n\t\t\t\tMethod candidate \u003d candidates[i];\n\t\t\t\tClass[] paramTypes \u003d candidate.getParameterTypes();\n\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026\n\t\t\t\t\t\tcandidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026\n\t\t\t\t\t\tparamTypes.length \u003e\u003d minNrOfArgs) {\n\n\t\t\t\t\tArgumentsHolder args \u003d null;\n\n\t\t\t\t\tif (resolvedValues !\u003d null) {\n\t\t\t\t\t\t// Resolved contructor arguments: type conversion and/or autowiring necessary.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\targs \u003d createArgumentArray(\n\t\t\t\t\t\t\t\t\tbeanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t\t\t\tif (this.beanFactory.logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t\tthis.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate +\n\t\t\t\t\t\t\t\t\t\t\"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n\t\t\t\t\t\t\t\tif (causes !\u003d null) {\n\t\t\t\t\t\t\t\t\tfor (Iterator it \u003d causes.iterator(); it.hasNext();) {\n\t\t\t\t\t\t\t\t\t\tthis.beanFactory.onSuppressedException((Exception) it.next());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Swallow and try next overloaded factory method.\n\t\t\t\t\t\t\t\tif (causes \u003d\u003d null) {\n\t\t\t\t\t\t\t\t\tcauses \u003d new LinkedList();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcauses.add(ex);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Explicit arguments given -\u003e arguments length must match exactly.\n\t\t\t\t\t\tif (paramTypes.length !\u003d explicitArgs.length) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs \u003d new ArgumentsHolder(explicitArgs);\n\t\t\t\t\t}\n\n\t\t\t\t\tint typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n\t\t\t\t\t// Choose this constructor if it represents the closest match.\n\t\t\t\t\tif (typeDiffWeight \u003c minTypeDiffWeight) {\n\t\t\t\t\t\tfactoryMethodToUse \u003d candidate;\n\t\t\t\t\t\targsToUse \u003d args.arguments;\n\t\t\t\t\t\tminTypeDiffWeight \u003d typeDiffWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (factoryMethodToUse \u003d\u003d null) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"No matching factory method found: \" +\n\t\t\t\t\t\t(mbd.getFactoryBeanName() !\u003d null ?\n\t\t\t\t\t\t \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") +\n\t\t\t\t\t\t\"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n\t\t\t}\n\t\t\tif (void.class.equals(factoryMethodToUse.getReturnType())) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid factory method \u0027\" + mbd.getFactoryMethodName() +\n\t\t\t\t\t\t\"\u0027: needs to have a non-void return type!\");\n\t\t\t}\n\n\t\t\tif (explicitArgs \u003d\u003d null) {\n\t\t\t\tmbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance \u003d this.instantiationStrategy.instantiate(\n\t\t\t\t\tmbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n\t\t\tif (beanInstance \u003d\u003d null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbw.setWrappedInstance(beanInstance);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 273,
      "functionName": "instantiateUsingFactoryMethod"
    }
  }
}