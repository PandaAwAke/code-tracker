{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "H:\\Projects\\square\\okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "OkHttpURLConnection.java",
  "functionName": "getResponse",
  "functionId": "getResponse___networkResponseOnError-boolean",
  "sourceFilePath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
  "functionStartLine": 443,
  "functionEndLine": 484,
  "numCommitsSeen": 145,
  "timeTaken": 2228,
  "changeHistory": [
    "aac684aeae32ff18e443799a3ccff6de9d68a684",
    "2b8ad31b084af93ad202a1b835e5be63ac58a269",
    "2843933b4b4778451d1d43822db1a148bf2aa7ea",
    "ec39c462324c0a54e6abf06cbf8079298056b7d5",
    "084b06b48bae2b566bb1be3415b6c847d8ea3682",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "93d547dcdaecddfa456aee0571131db2342e5abb",
    "c358656c8799d30fd422448153e99a5dd37e298a",
    "4c90a2e04a83646597a506a80b5a885d5c515bf0",
    "e49dd7a2f08deac92fab3de2b8a63e90b588f746",
    "ed70981925e64fd0cb593d09bdd401ea4ea19848",
    "0676d8b1733589a869098b9980118644b3bade4f",
    "ee2ed56c9ad4563f5713ff0f572a5454af16901d",
    "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4",
    "9146c579dd9110d0028144c59515da9be1ce7108",
    "996e9c95bdcafd62e84c79c512d6ccac65c30758",
    "84184afdb26b42ff615896f9c0161157cc84ec73",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
    "4831a8dc6577f762e0f21fd15dd9700fe824740d",
    "350c43b6fe02401a73f967d9ef322061638b372a",
    "37c01895cca5ec2bec26a3d381611f0938acd6d0",
    "a948ffce1eb2b9ec46069722f6744f252d6dbfc7",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3",
    "7e7a3896df109ef442af9ec69423c33ec667c9f5",
    "6f6d959fdae64065521990413f86bc7ab038d7c1",
    "637783ce8ae3ffb9805c2f78b436703c29b2220a",
    "194290e5f3819bf91d87c5d08c152946b6aa3509",
    "689f66222bd8984dd69229a4ee9caf8da528ae12",
    "67604f618d96ae00318ce696ec29a66bec6aafa8",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e"
  ],
  "changeHistoryShort": {
    "aac684aeae32ff18e443799a3ccff6de9d68a684": "Ybodychange",
    "2b8ad31b084af93ad202a1b835e5be63ac58a269": "Ymultichange(Yparameterchange,Ybodychange)",
    "2843933b4b4778451d1d43822db1a148bf2aa7ea": "Ybodychange",
    "ec39c462324c0a54e6abf06cbf8079298056b7d5": "Yfilerename",
    "084b06b48bae2b566bb1be3415b6c847d8ea3682": "Ymultichange(Yreturntypechange,Ybodychange)",
    "c9a89876de476983f273edbf108c365127c18c5e": "Yfilerename",
    "93d547dcdaecddfa456aee0571131db2342e5abb": "Ybodychange",
    "c358656c8799d30fd422448153e99a5dd37e298a": "Ybodychange",
    "4c90a2e04a83646597a506a80b5a885d5c515bf0": "Ybodychange",
    "e49dd7a2f08deac92fab3de2b8a63e90b588f746": "Ybodychange",
    "ed70981925e64fd0cb593d09bdd401ea4ea19848": "Ybodychange",
    "0676d8b1733589a869098b9980118644b3bade4f": "Yfilerename",
    "ee2ed56c9ad4563f5713ff0f572a5454af16901d": "Ybodychange",
    "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4": "Ybodychange",
    "9146c579dd9110d0028144c59515da9be1ce7108": "Ybodychange",
    "996e9c95bdcafd62e84c79c512d6ccac65c30758": "Yfilerename",
    "84184afdb26b42ff615896f9c0161157cc84ec73": "Ybodychange",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": "Ybodychange",
    "4831a8dc6577f762e0f21fd15dd9700fe824740d": "Ybodychange",
    "350c43b6fe02401a73f967d9ef322061638b372a": "Ybodychange",
    "37c01895cca5ec2bec26a3d381611f0938acd6d0": "Ybodychange",
    "a948ffce1eb2b9ec46069722f6744f252d6dbfc7": "Ybodychange",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": "Yfilerename",
    "7e7a3896df109ef442af9ec69423c33ec667c9f5": "Ybodychange",
    "6f6d959fdae64065521990413f86bc7ab038d7c1": "Ybodychange",
    "637783ce8ae3ffb9805c2f78b436703c29b2220a": "Ybodychange",
    "194290e5f3819bf91d87c5d08c152946b6aa3509": "Ybodychange",
    "689f66222bd8984dd69229a4ee9caf8da528ae12": "Yfilerename",
    "67604f618d96ae00318ce696ec29a66bec6aafa8": "Ybodychange",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": "Yfilerename",
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": "Ybodychange",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "aac684aeae32ff18e443799a3ccff6de9d68a684": {
      "type": "Ybodychange",
      "commitMessage": "Retain interrupted state when throwing InterruptedIOException\n\nThe drawbacks seem small; the callsite needs to handle interruption anyway\nbecause the thread is prone to interruption.\n\nAnd the upside is that a single interrupt should now be sufficient to break\nout an in-flight OkHttp call.\n\nNote that although we\u0027re fixing this, thread interruption is not well tested\nin OkHttp. Most users should prefer Call.cancel(), which is well tested and\ndoesn\u0027t rely on the caller to know which threads OkHttp is using to make\nthe actual HTTP request.\n\nCloses: https://github.com/square/okhttp/issues/3945\n",
      "commitDate": "2018-07-05, 10:37 p.m.",
      "commitName": "aac684aeae32ff18e443799a3ccff6de9d68a684",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2018-02-18, 6:57 a.m.",
      "commitNameOld": "2db8c41b3b0f0476c0e8735f4d57562d50f32ffa",
      "commitAuthorOld": "Eric Cochran",
      "daysBetweenCommits": 137.61,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response getResponse(boolean networkResponseOnError) throws IOException {\n    synchronized (lock) {\n      if (response !\u003d null) return response;\n      if (callFailure !\u003d null) {\n        if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null) return networkResponse;\n        throw propagate(callFailure);\n      }\n    }\n\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null) requestBody.outputStream().close();\n\n    if (executed) {\n      synchronized (lock) {\n        try {\n          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n            lock.wait(); // Wait until the response is returned or the call fails.\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt(); // Retain interrupted status.\n          throw new InterruptedIOException();\n        }\n      }\n    } else {\n      executed \u003d true;\n      try {\n        onResponse(call, call.execute());\n      } catch (IOException e) {\n        onFailure(call, e);\n      }\n    }\n\n    synchronized (lock) {\n      if (callFailure !\u003d null) throw propagate(callFailure);\n      if (response !\u003d null) return response;\n    }\n\n    throw new AssertionError();\n  }",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
      "functionStartLine": 427,
      "functionName": "getResponse",
      "diff": "@@ -1,41 +1,42 @@\n   private Response getResponse(boolean networkResponseOnError) throws IOException {\n     synchronized (lock) {\n       if (response !\u003d null) return response;\n       if (callFailure !\u003d null) {\n         if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null) return networkResponse;\n         throw propagate(callFailure);\n       }\n     }\n \n     Call call \u003d buildCall();\n     networkInterceptor.proceed();\n \n     OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n     if (requestBody !\u003d null) requestBody.outputStream().close();\n \n     if (executed) {\n       synchronized (lock) {\n         try {\n           while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n             lock.wait(); // Wait until the response is returned or the call fails.\n           }\n         } catch (InterruptedException e) {\n+          Thread.currentThread().interrupt(); // Retain interrupted status.\n           throw new InterruptedIOException();\n         }\n       }\n     } else {\n       executed \u003d true;\n       try {\n         onResponse(call, call.execute());\n       } catch (IOException e) {\n         onFailure(call, e);\n       }\n     }\n \n     synchronized (lock) {\n       if (callFailure !\u003d null) throw propagate(callFailure);\n       if (response !\u003d null) return response;\n     }\n \n     throw new AssertionError();\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2b8ad31b084af93ad202a1b835e5be63ac58a269": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
      "commitDate": "2016-11-21, 9:58 p.m.",
      "commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
          "commitDate": "2016-11-21, 9:58 p.m.",
          "commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016-07-24, 7:07 p.m.",
          "commitNameOld": "591d59556153555c9f5b56bf601780a817defc09",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 120.16,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "actualSource": "  private Response getResponse(boolean networkResponseOnError) throws IOException {\n    synchronized (lock) {\n      if (response !\u003d null) return response;\n      if (callFailure !\u003d null) {\n        if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null) return networkResponse;\n        throw propagate(callFailure);\n      }\n    }\n\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null) requestBody.outputStream().close();\n\n    if (executed) {\n      synchronized (lock) {\n        try {\n          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n            lock.wait(); // Wait until the response is returned or the call fails.\n          }\n        } catch (InterruptedException e) {\n          throw new InterruptedIOException();\n        }\n      }\n    } else {\n      executed \u003d true;\n      try {\n        onResponse(call, call.execute());\n      } catch (IOException e) {\n        onFailure(call, e);\n      }\n    }\n\n    synchronized (lock) {\n      if (callFailure !\u003d null) throw propagate(callFailure);\n      if (response !\u003d null) return response;\n    }\n\n    throw new AssertionError();\n  }",
          "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
          "functionStartLine": 408,
          "functionName": "getResponse",
          "diff": "@@ -1,41 +1,41 @@\n-  private Response getResponse() throws IOException {\n-    if (response !\u003d null) {\n-      return response;\n-    } else if (networkResponse !\u003d null) {\n-      return networkResponse;\n-    } else if (callFailure !\u003d null) {\n-      throw propagate(callFailure);\n+  private Response getResponse(boolean networkResponseOnError) throws IOException {\n+    synchronized (lock) {\n+      if (response !\u003d null) return response;\n+      if (callFailure !\u003d null) {\n+        if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null) return networkResponse;\n+        throw propagate(callFailure);\n+      }\n     }\n \n     Call call \u003d buildCall();\n     networkInterceptor.proceed();\n \n     OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n     if (requestBody !\u003d null) requestBody.outputStream().close();\n \n     if (executed) {\n       synchronized (lock) {\n         try {\n           while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n             lock.wait(); // Wait until the response is returned or the call fails.\n           }\n         } catch (InterruptedException e) {\n           throw new InterruptedIOException();\n         }\n       }\n     } else {\n       executed \u003d true;\n       try {\n         onResponse(call, call.execute());\n       } catch (IOException e) {\n         onFailure(call, e);\n       }\n     }\n \n     synchronized (lock) {\n       if (callFailure !\u003d null) throw propagate(callFailure);\n       if (response !\u003d null) return response;\n     }\n \n     throw new AssertionError();\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[networkResponseOnError-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix flakiness in authenticateWithChunkedStreaming().\n\nWe were prefering to return the networkResponse before the request\nhad completely failed. Instead we should return the network response\nonly on failure, and only for APIs that return failed responses.\n",
          "commitDate": "2016-11-21, 9:58 p.m.",
          "commitName": "2b8ad31b084af93ad202a1b835e5be63ac58a269",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016-07-24, 7:07 p.m.",
          "commitNameOld": "591d59556153555c9f5b56bf601780a817defc09",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 120.16,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "actualSource": "  private Response getResponse(boolean networkResponseOnError) throws IOException {\n    synchronized (lock) {\n      if (response !\u003d null) return response;\n      if (callFailure !\u003d null) {\n        if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null) return networkResponse;\n        throw propagate(callFailure);\n      }\n    }\n\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null) requestBody.outputStream().close();\n\n    if (executed) {\n      synchronized (lock) {\n        try {\n          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n            lock.wait(); // Wait until the response is returned or the call fails.\n          }\n        } catch (InterruptedException e) {\n          throw new InterruptedIOException();\n        }\n      }\n    } else {\n      executed \u003d true;\n      try {\n        onResponse(call, call.execute());\n      } catch (IOException e) {\n        onFailure(call, e);\n      }\n    }\n\n    synchronized (lock) {\n      if (callFailure !\u003d null) throw propagate(callFailure);\n      if (response !\u003d null) return response;\n    }\n\n    throw new AssertionError();\n  }",
          "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
          "functionStartLine": 408,
          "functionName": "getResponse",
          "diff": "@@ -1,41 +1,41 @@\n-  private Response getResponse() throws IOException {\n-    if (response !\u003d null) {\n-      return response;\n-    } else if (networkResponse !\u003d null) {\n-      return networkResponse;\n-    } else if (callFailure !\u003d null) {\n-      throw propagate(callFailure);\n+  private Response getResponse(boolean networkResponseOnError) throws IOException {\n+    synchronized (lock) {\n+      if (response !\u003d null) return response;\n+      if (callFailure !\u003d null) {\n+        if (networkResponseOnError \u0026\u0026 networkResponse !\u003d null) return networkResponse;\n+        throw propagate(callFailure);\n+      }\n     }\n \n     Call call \u003d buildCall();\n     networkInterceptor.proceed();\n \n     OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n     if (requestBody !\u003d null) requestBody.outputStream().close();\n \n     if (executed) {\n       synchronized (lock) {\n         try {\n           while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n             lock.wait(); // Wait until the response is returned or the call fails.\n           }\n         } catch (InterruptedException e) {\n           throw new InterruptedIOException();\n         }\n       }\n     } else {\n       executed \u003d true;\n       try {\n         onResponse(call, call.execute());\n       } catch (IOException e) {\n         onFailure(call, e);\n       }\n     }\n \n     synchronized (lock) {\n       if (callFailure !\u003d null) throw propagate(callFailure);\n       if (response !\u003d null) return response;\n     }\n \n     throw new AssertionError();\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2843933b4b4778451d1d43822db1a148bf2aa7ea": {
      "type": "Ybodychange",
      "commitMessage": "Fix OkHttpURLConnection to not swallow unexpected exceptions.\n\nPreviously we would sometimes delegate to the asynchronous implementation,\nand that would prevent exceptions from reaching their destination.\n",
      "commitDate": "2016-06-25, 6:04 p.m.",
      "commitName": "2843933b4b4778451d1d43822db1a148bf2aa7ea",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-06-25, 3:46 p.m.",
      "commitNameOld": "ec39c462324c0a54e6abf06cbf8079298056b7d5",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response getResponse() throws IOException {\n    if (response !\u003d null) {\n      return response;\n    } else if (networkResponse !\u003d null) {\n      return networkResponse;\n    } else if (callFailure !\u003d null) {\n      throw propagate(callFailure);\n    }\n\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null) requestBody.outputStream().close();\n\n    if (executed) {\n      synchronized (lock) {\n        try {\n          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n            lock.wait(); // Wait until the response is returned or the call fails.\n          }\n        } catch (InterruptedException e) {\n          throw new InterruptedIOException();\n        }\n      }\n    } else {\n      executed \u003d true;\n      try {\n        onResponse(call, call.execute());\n      } catch (IOException e) {\n        onFailure(call, e);\n      }\n    }\n\n    synchronized (lock) {\n      if (callFailure !\u003d null) throw propagate(callFailure);\n      if (response !\u003d null) return response;\n    }\n\n    throw new AssertionError();\n  }",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
      "functionStartLine": 406,
      "functionName": "getResponse",
      "diff": "@@ -1,41 +1,41 @@\n   private Response getResponse() throws IOException {\n     if (response !\u003d null) {\n       return response;\n     } else if (networkResponse !\u003d null) {\n       return networkResponse;\n     } else if (callFailure !\u003d null) {\n-      throw callFailure;\n+      throw propagate(callFailure);\n     }\n \n     Call call \u003d buildCall();\n     networkInterceptor.proceed();\n \n     OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n     if (requestBody !\u003d null) requestBody.outputStream().close();\n \n     if (executed) {\n       synchronized (lock) {\n         try {\n           while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n             lock.wait(); // Wait until the response is returned or the call fails.\n           }\n         } catch (InterruptedException e) {\n           throw new InterruptedIOException();\n         }\n       }\n     } else {\n       executed \u003d true;\n       try {\n         onResponse(call, call.execute());\n       } catch (IOException e) {\n         onFailure(call, e);\n       }\n     }\n \n     synchronized (lock) {\n-      if (callFailure !\u003d null) throw callFailure;\n+      if (callFailure !\u003d null) throw propagate(callFailure);\n       if (response !\u003d null) return response;\n     }\n \n     throw new AssertionError();\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec39c462324c0a54e6abf06cbf8079298056b7d5": {
      "type": "Yfilerename",
      "commitMessage": "Rename HttpURLConnectionImpl to OkHttpURLConnection.\n\nThis is an internal class so nobody should see the name. But having a\ncompletely different name will make it much easier to diagnose future\nstacktraces because the internal implementation has changed so much\nrecently.\n\nAlso share fewer internal details with the rest of OkHttp. In particular\nremove the OkHttp-Selected-Protocol and OkHttp-Response-Source headers\nfrom the core.\n",
      "commitDate": "2016-06-25, 3:46 p.m.",
      "commitName": "ec39c462324c0a54e6abf06cbf8079298056b7d5",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016-06-25, 1:57 p.m.",
      "commitNameOld": "3f282e8bf0b8af519cbf35833fdcf69d824661fc",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private Response getResponse() throws IOException {\n    if (response !\u003d null) {\n      return response;\n    } else if (networkResponse !\u003d null) {\n      return networkResponse;\n    } else if (callFailure !\u003d null) {\n      throw callFailure;\n    }\n\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null) requestBody.outputStream().close();\n\n    if (executed) {\n      synchronized (lock) {\n        try {\n          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n            lock.wait(); // Wait until the response is returned or the call fails.\n          }\n        } catch (InterruptedException e) {\n          throw new InterruptedIOException();\n        }\n      }\n    } else {\n      executed \u003d true;\n      try {\n        onResponse(call, call.execute());\n      } catch (IOException e) {\n        onFailure(call, e);\n      }\n    }\n\n    synchronized (lock) {\n      if (callFailure !\u003d null) throw callFailure;\n      if (response !\u003d null) return response;\n    }\n\n    throw new AssertionError();\n  }",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java",
      "functionStartLine": 405,
      "functionName": "getResponse",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
        "newPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java"
      }
    },
    "084b06b48bae2b566bb1be3415b6c847d8ea3682": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
      "commitDate": "2016-06-21, 2:30 p.m.",
      "commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
          "commitDate": "2016-06-21, 2:30 p.m.",
          "commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016-05-07, 9:08 p.m.",
          "commitNameOld": "4f24a30c12032b7033884a630696014afd3e77cb",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 44.72,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "actualSource": "  private Response getResponse() throws IOException {\n    if (response !\u003d null) {\n      return response;\n    } else if (networkResponse !\u003d null) {\n      return networkResponse;\n    } else if (callFailure !\u003d null) {\n      throw callFailure;\n    }\n\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null) requestBody.outputStream().close();\n\n    if (executed) {\n      synchronized (lock) {\n        try {\n          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n            lock.wait(); // Wait until the response is returned or the call fails.\n          }\n        } catch (InterruptedException e) {\n          throw new InterruptedIOException();\n        }\n      }\n    } else {\n      executed \u003d true;\n      try {\n        onResponse(call, call.execute());\n      } catch (IOException e) {\n        onFailure(call, e);\n      }\n    }\n\n    synchronized (lock) {\n      if (callFailure !\u003d null) throw callFailure;\n      if (response !\u003d null) return response;\n    }\n\n    throw new AssertionError();\n  }",
          "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
          "functionStartLine": 398,
          "functionName": "getResponse",
          "diff": "@@ -1,50 +1,41 @@\n-  private HttpEngine getResponse() throws IOException {\n-    initHttpEngine();\n-\n-    if (httpEngine.hasResponse()) {\n-      return httpEngine;\n+  private Response getResponse() throws IOException {\n+    if (response !\u003d null) {\n+      return response;\n+    } else if (networkResponse !\u003d null) {\n+      return networkResponse;\n+    } else if (callFailure !\u003d null) {\n+      throw callFailure;\n     }\n \n-    while (true) {\n-      if (!execute(true)) {\n-        continue;\n+    Call call \u003d buildCall();\n+    networkInterceptor.proceed();\n+\n+    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n+    if (requestBody !\u003d null) requestBody.outputStream().close();\n+\n+    if (executed) {\n+      synchronized (lock) {\n+        try {\n+          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n+            lock.wait(); // Wait until the response is returned or the call fails.\n+          }\n+        } catch (InterruptedException e) {\n+          throw new InterruptedIOException();\n+        }\n       }\n-\n-      Response response \u003d httpEngine.getResponse();\n-      Request followUp \u003d httpEngine.followUpRequest();\n-\n-      if (followUp \u003d\u003d null) {\n-        httpEngine.releaseStreamAllocation();\n-        return httpEngine;\n+    } else {\n+      executed \u003d true;\n+      try {\n+        onResponse(call, call.execute());\n+      } catch (IOException e) {\n+        onFailure(call, e);\n       }\n-\n-      if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n-        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n-      }\n-\n-      // The first request was insufficient. Prepare for another...\n-      url \u003d followUp.url().url();\n-      requestHeaders \u003d followUp.headers().newBuilder();\n-\n-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n-      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n-      // when following any redirect.\n-      Sink requestBody \u003d httpEngine.getRequestBody();\n-      if (!followUp.method().equals(method)) {\n-        requestBody \u003d null;\n-      }\n-\n-      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n-        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n-      }\n-\n-      StreamAllocation streamAllocation \u003d httpEngine.close();\n-      if (!httpEngine.sameConnection(followUp.url())) {\n-        streamAllocation.release();\n-        streamAllocation \u003d null;\n-      }\n-\n-      httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n-          response);\n     }\n+\n+    synchronized (lock) {\n+      if (callFailure !\u003d null) throw callFailure;\n+      if (response !\u003d null) return response;\n+    }\n+\n+    throw new AssertionError();\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "HttpEngine",
            "newValue": "Response"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Reimplement HttpURLConnection on the native OkHttp API.\n",
          "commitDate": "2016-06-21, 2:30 p.m.",
          "commitName": "084b06b48bae2b566bb1be3415b6c847d8ea3682",
          "commitAuthor": "jwilson",
          "commitDateOld": "2016-05-07, 9:08 p.m.",
          "commitNameOld": "4f24a30c12032b7033884a630696014afd3e77cb",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 44.72,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "actualSource": "  private Response getResponse() throws IOException {\n    if (response !\u003d null) {\n      return response;\n    } else if (networkResponse !\u003d null) {\n      return networkResponse;\n    } else if (callFailure !\u003d null) {\n      throw callFailure;\n    }\n\n    Call call \u003d buildCall();\n    networkInterceptor.proceed();\n\n    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n    if (requestBody !\u003d null) requestBody.outputStream().close();\n\n    if (executed) {\n      synchronized (lock) {\n        try {\n          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n            lock.wait(); // Wait until the response is returned or the call fails.\n          }\n        } catch (InterruptedException e) {\n          throw new InterruptedIOException();\n        }\n      }\n    } else {\n      executed \u003d true;\n      try {\n        onResponse(call, call.execute());\n      } catch (IOException e) {\n        onFailure(call, e);\n      }\n    }\n\n    synchronized (lock) {\n      if (callFailure !\u003d null) throw callFailure;\n      if (response !\u003d null) return response;\n    }\n\n    throw new AssertionError();\n  }",
          "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
          "functionStartLine": 398,
          "functionName": "getResponse",
          "diff": "@@ -1,50 +1,41 @@\n-  private HttpEngine getResponse() throws IOException {\n-    initHttpEngine();\n-\n-    if (httpEngine.hasResponse()) {\n-      return httpEngine;\n+  private Response getResponse() throws IOException {\n+    if (response !\u003d null) {\n+      return response;\n+    } else if (networkResponse !\u003d null) {\n+      return networkResponse;\n+    } else if (callFailure !\u003d null) {\n+      throw callFailure;\n     }\n \n-    while (true) {\n-      if (!execute(true)) {\n-        continue;\n+    Call call \u003d buildCall();\n+    networkInterceptor.proceed();\n+\n+    OutputStreamRequestBody requestBody \u003d (OutputStreamRequestBody) call.request().body();\n+    if (requestBody !\u003d null) requestBody.outputStream().close();\n+\n+    if (executed) {\n+      synchronized (lock) {\n+        try {\n+          while (response \u003d\u003d null \u0026\u0026 callFailure \u003d\u003d null) {\n+            lock.wait(); // Wait until the response is returned or the call fails.\n+          }\n+        } catch (InterruptedException e) {\n+          throw new InterruptedIOException();\n+        }\n       }\n-\n-      Response response \u003d httpEngine.getResponse();\n-      Request followUp \u003d httpEngine.followUpRequest();\n-\n-      if (followUp \u003d\u003d null) {\n-        httpEngine.releaseStreamAllocation();\n-        return httpEngine;\n+    } else {\n+      executed \u003d true;\n+      try {\n+        onResponse(call, call.execute());\n+      } catch (IOException e) {\n+        onFailure(call, e);\n       }\n-\n-      if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n-        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n-      }\n-\n-      // The first request was insufficient. Prepare for another...\n-      url \u003d followUp.url().url();\n-      requestHeaders \u003d followUp.headers().newBuilder();\n-\n-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n-      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n-      // when following any redirect.\n-      Sink requestBody \u003d httpEngine.getRequestBody();\n-      if (!followUp.method().equals(method)) {\n-        requestBody \u003d null;\n-      }\n-\n-      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n-        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n-      }\n-\n-      StreamAllocation streamAllocation \u003d httpEngine.close();\n-      if (!httpEngine.sameConnection(followUp.url())) {\n-        streamAllocation.release();\n-        streamAllocation \u003d null;\n-      }\n-\n-      httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n-          response);\n     }\n+\n+    synchronized (lock) {\n+      if (callFailure !\u003d null) throw callFailure;\n+      if (response !\u003d null) return response;\n+    }\n+\n+    throw new AssertionError();\n   }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Yfilerename",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015-12-16, 1:34 a.m.",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-12-15, 9:36 p.m.",
      "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseStreamAllocation();\n        return httpEngine;\n      }\n\n      if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url().url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      StreamAllocation streamAllocation \u003d httpEngine.close();\n      if (!httpEngine.sameConnection(followUp.url())) {\n        streamAllocation.release();\n        streamAllocation \u003d null;\n      }\n\n      httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n          response);\n    }\n  }",
      "path": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 391,
      "functionName": "getResponse",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
        "newPath": "okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java"
      }
    },
    "93d547dcdaecddfa456aee0571131db2342e5abb": {
      "type": "Ybodychange",
      "commitMessage": "Make HttpUrl the blessed URL method of Request.\n",
      "commitDate": "2015-12-14, 3:11 p.m.",
      "commitName": "93d547dcdaecddfa456aee0571131db2342e5abb",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015-12-13, 10:07 a.m.",
      "commitNameOld": "45260b51b1948abe139c568e2c400955870b9339",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseStreamAllocation();\n        return httpEngine;\n      }\n\n      if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url().url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      StreamAllocation streamAllocation \u003d httpEngine.close();\n      if (!httpEngine.sameConnection(followUp.url())) {\n        streamAllocation.release();\n        streamAllocation \u003d null;\n      }\n\n      httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n          response);\n    }\n  }",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 391,
      "functionName": "getResponse",
      "diff": "@@ -1,50 +1,50 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response \u003d httpEngine.getResponse();\n       Request followUp \u003d httpEngine.followUpRequest();\n \n       if (followUp \u003d\u003d null) {\n         httpEngine.releaseStreamAllocation();\n         return httpEngine;\n       }\n \n       if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n         throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n-      url \u003d followUp.url();\n+      url \u003d followUp.url().url();\n       requestHeaders \u003d followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody \u003d httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       StreamAllocation streamAllocation \u003d httpEngine.close();\n-      if (!httpEngine.sameConnection(followUp.httpUrl())) {\n+      if (!httpEngine.sameConnection(followUp.url())) {\n         streamAllocation.release();\n         streamAllocation \u003d null;\n       }\n \n       httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c358656c8799d30fd422448153e99a5dd37e298a": {
      "type": "Ybodychange",
      "commitMessage": "First draft of the new new stream allocations model.\n",
      "commitDate": "2015-11-28, 9:36 a.m.",
      "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-11-24, 10:03 p.m.",
      "commitNameOld": "6fff68b1e9be384ad134812d3e14af5ae7fef83f",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 3.48,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseStreamAllocation();\n        return httpEngine;\n      }\n\n      if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      StreamAllocation streamAllocation \u003d httpEngine.close();\n      if (!httpEngine.sameConnection(followUp.httpUrl())) {\n        streamAllocation.release();\n        streamAllocation \u003d null;\n      }\n\n      httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n          response);\n    }\n  }",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 391,
      "functionName": "getResponse",
      "diff": "@@ -1,49 +1,50 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response \u003d httpEngine.getResponse();\n       Request followUp \u003d httpEngine.followUpRequest();\n \n       if (followUp \u003d\u003d null) {\n-        httpEngine.releaseConnection();\n+        httpEngine.releaseStreamAllocation();\n         return httpEngine;\n       }\n \n       if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n         throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url \u003d followUp.url();\n       requestHeaders \u003d followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody \u003d httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n+      StreamAllocation streamAllocation \u003d httpEngine.close();\n       if (!httpEngine.sameConnection(followUp.httpUrl())) {\n-        httpEngine.releaseConnection();\n+        streamAllocation.release();\n+        streamAllocation \u003d null;\n       }\n \n-      Connection connection \u003d httpEngine.close();\n-      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n+      httpEngine \u003d newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4c90a2e04a83646597a506a80b5a885d5c515bf0": {
      "type": "Ybodychange",
      "commitMessage": "Use HttpUrl internally.\n",
      "commitDate": "2015-08-02, 9:01 p.m.",
      "commitName": "4c90a2e04a83646597a506a80b5a885d5c515bf0",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015-04-16, 8:20 p.m.",
      "commitNameOld": "80901a680a341a79f4bc4523b191eeb219941cd7",
      "commitAuthorOld": "",
      "daysBetweenCommits": 108.03,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (!httpEngine.sameConnection(followUp.httpUrl())) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n          response);\n    }\n  }",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 379,
      "functionName": "getResponse",
      "diff": "@@ -1,49 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response \u003d httpEngine.getResponse();\n       Request followUp \u003d httpEngine.followUpRequest();\n \n       if (followUp \u003d\u003d null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n         throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url \u003d followUp.url();\n       requestHeaders \u003d followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody \u003d httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n-      if (!httpEngine.sameConnection(followUp.url())) {\n+      if (!httpEngine.sameConnection(followUp.httpUrl())) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection \u003d httpEngine.close();\n       httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e49dd7a2f08deac92fab3de2b8a63e90b588f746": {
      "type": "Ybodychange",
      "commitMessage": "Limit 20 authorization attempts.\n\nWe use one count for both redirects and authorization attempts. This\nseems like good enough policy.\n\nCloses https://github.com/square/okhttp/issues/960\n",
      "commitDate": "2014-12-30, 12:14 p.m.",
      "commitName": "e49dd7a2f08deac92fab3de2b8a63e90b588f746",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-12-24, 2:33 p.m.",
      "commitNameOld": "15c81fdfc2ba4ecfbadac5a7ec73fcc61f6624bc",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 5.9,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (!httpEngine.sameConnection(followUp.url())) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n          response);\n    }\n  }",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 368,
      "functionName": "getResponse",
      "diff": "@@ -1,49 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response \u003d httpEngine.getResponse();\n       Request followUp \u003d httpEngine.followUpRequest();\n \n       if (followUp \u003d\u003d null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n-      if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n-        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n+      if (++followUpCount \u003e HttpEngine.MAX_FOLLOW_UPS) {\n+        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url \u003d followUp.url();\n       requestHeaders \u003d followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody \u003d httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (!httpEngine.sameConnection(followUp.url())) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection \u003d httpEngine.close();\n       httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ed70981925e64fd0cb593d09bdd401ea4ea19848": {
      "type": "Ybodychange",
      "commitMessage": "Strip auth headers when redirected to another host.\n\nThese are potentially private and we don\u0027t want to leak them to another\nhost, regardless of whether they\u0027re created by the calling application or\nby the Authenticator.\n",
      "commitDate": "2014-05-19, 11:18 p.m.",
      "commitName": "ed70981925e64fd0cb593d09bdd401ea4ea19848",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-05-17, 9:00 p.m.",
      "commitNameOld": "0676d8b1733589a869098b9980118644b3bade4f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (!httpEngine.sameConnection(followUp.url())) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n          response);\n    }\n  }",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 320,
      "functionName": "getResponse",
      "diff": "@@ -1,49 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response \u003d httpEngine.getResponse();\n       Request followUp \u003d httpEngine.followUpRequest();\n \n       if (followUp \u003d\u003d null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n         throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url \u003d followUp.url();\n       requestHeaders \u003d followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody \u003d httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n-      if (!httpEngine.sameConnection(followUp)) {\n+      if (!httpEngine.sameConnection(followUp.url())) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection \u003d httpEngine.close();\n       httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n           response);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0676d8b1733589a869098b9980118644b3bade4f": {
      "type": "Yfilerename",
      "commitMessage": "Move code to the urlconnection module.\n\nWe don\u0027t need this code for the core OkHttp API.\n",
      "commitDate": "2014-05-17, 9:00 p.m.",
      "commitName": "0676d8b1733589a869098b9980118644b3bade4f",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-05-17, 6:40 p.m.",
      "commitNameOld": "85a3e9bfc58040c9ffb2ee906b39702bb26a84a5",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (!httpEngine.sameConnection(followUp)) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n          response);\n    }\n  }",
      "path": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 320,
      "functionName": "getResponse",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
        "newPath": "okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java"
      }
    },
    "ee2ed56c9ad4563f5713ff0f572a5454af16901d": {
      "type": "Ybodychange",
      "commitMessage": "Track redirectedBy in HttpEngine.\n\nTracking it in Call meant we would need to duplicate code\nin HttpURLConnection if we wanted the same behavior.\n",
      "commitDate": "2014-05-05, 8:41 p.m.",
      "commitName": "ee2ed56c9ad4563f5713ff0f572a5454af16901d",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-04-30, 9:36 p.m.",
      "commitNameOld": "1044d9eea21d8be54c195fff75ca0a7b9bba79b3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 4.96,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (!httpEngine.sameConnection(followUp)) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n          response);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 320,
      "functionName": "getResponse",
      "diff": "@@ -1,48 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response \u003d httpEngine.getResponse();\n       Request followUp \u003d httpEngine.followUpRequest();\n \n       if (followUp \u003d\u003d null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n         throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n       url \u003d followUp.url();\n       requestHeaders \u003d followUp.headers().newBuilder();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n       // should keep the same method, Chrome, Firefox and the RI all issue GETs\n       // when following any redirect.\n       Sink requestBody \u003d httpEngine.getRequestBody();\n       if (!followUp.method().equals(method)) {\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (!httpEngine.sameConnection(followUp)) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection \u003d httpEngine.close();\n-      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);\n+      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,\n+          response);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4": {
      "type": "Ybodychange",
      "commitMessage": "Move more behavior into HttpEngine.followUpRequest\n",
      "commitDate": "2014-04-26, 1:02 p.m.",
      "commitName": "b7542587b8e90aa4472d4d9e4b74a72ca0c42cb4",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-04-22, 11:39 a.m.",
      "commitNameOld": "112dcc40900d503ea7e416e0da0a8fd9b08a9c17",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 4.06,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      url \u003d followUp.url();\n      requestHeaders \u003d followUp.headers().newBuilder();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n      // when following any redirect.\n      Sink requestBody \u003d httpEngine.getRequestBody();\n      if (!followUp.method().equals(method)) {\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (!httpEngine.sameConnection(followUp)) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 318,
      "functionName": "getResponse",
      "diff": "@@ -1,59 +1,48 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Response response \u003d httpEngine.getResponse();\n       Request followUp \u003d httpEngine.followUpRequest();\n \n       if (followUp \u003d\u003d null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n         throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n       }\n \n       // The first request was insufficient. Prepare for another...\n-      if (response.isRedirect()) {\n-        url \u003d followUp.url(); // Get the redirected URL.\n-      } else {\n-        requestHeaders \u003d followUp.headers().newBuilder(); // Get the follow-up\u0027s credentials!\n-      }\n+      url \u003d followUp.url();\n+      requestHeaders \u003d followUp.headers().newBuilder();\n \n-      String retryMethod \u003d method;\n+      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect\n+      // should keep the same method, Chrome, Firefox and the RI all issue GETs\n+      // when following any redirect.\n       Sink requestBody \u003d httpEngine.getRequestBody();\n-\n-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n-      // redirect should keep the same method, Chrome, Firefox and the\n-      // RI all issue GETs when following any redirect.\n-      int responseCode \u003d response.code();\n-      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n-          || responseCode \u003d\u003d HTTP_MOVED_PERM\n-          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n-          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n-        retryMethod \u003d \"GET\";\n-        requestHeaders.removeAll(\"Content-Length\");\n+      if (!followUp.method().equals(method)) {\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (!httpEngine.sameConnection(followUp)) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection \u003d httpEngine.close();\n-      httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n+      httpEngine \u003d newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9146c579dd9110d0028144c59515da9be1ce7108": {
      "type": "Ybodychange",
      "commitMessage": "Deduplicate followup request handling.\n\nThis code\u0027s currently both gnarly and subtle; there\u0027s a lot of\nnuance to the HTTP behavior, and a lot of state, but it isn\u0027t\nobvious in the state of the objects doing the work.\n\nDeduplicating work in HttpURLConnection with Job is a shy first\nstep. It also points out some potential problems with Job, where\nwe don\u0027t handle method changes or cookies correctly. That\u0027s\ncritical!\n",
      "commitDate": "2014-04-22, 12:14 a.m.",
      "commitName": "9146c579dd9110d0028144c59515da9be1ce7108",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014-04-21, 12:00 p.m.",
      "commitNameOld": "e920196fbd71822fc284ab76204bf75f95d3265a",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.51,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Response response \u003d httpEngine.getResponse();\n      Request followUp \u003d httpEngine.followUpRequest();\n\n      if (followUp \u003d\u003d null) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n      }\n\n      // The first request was insufficient. Prepare for another...\n      if (response.isRedirect()) {\n        url \u003d followUp.url(); // Get the redirected URL.\n      } else {\n        requestHeaders \u003d followUp.headers().newBuilder(); // Get the follow-up\u0027s credentials!\n      }\n\n      String retryMethod \u003d method;\n      Sink requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d response.code();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestHeaders.removeAll(\"Content-Length\");\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (!httpEngine.sameConnection(followUp)) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 321,
      "functionName": "getResponse",
      "diff": "@@ -1,47 +1,59 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n-      Retry retry \u003d processResponseHeaders();\n-      if (retry \u003d\u003d Retry.NONE) {\n+      Response response \u003d httpEngine.getResponse();\n+      Request followUp \u003d httpEngine.followUpRequest();\n+\n+      if (followUp \u003d\u003d null) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n+      if (response.isRedirect() \u0026\u0026 ++redirectionCount \u003e HttpEngine.MAX_REDIRECTS) {\n+        throw new ProtocolException(\"Too many redirects: \" + redirectionCount);\n+      }\n+\n       // The first request was insufficient. Prepare for another...\n+      if (response.isRedirect()) {\n+        url \u003d followUp.url(); // Get the redirected URL.\n+      } else {\n+        requestHeaders \u003d followUp.headers().newBuilder(); // Get the follow-up\u0027s credentials!\n+      }\n+\n       String retryMethod \u003d method;\n       Sink requestBody \u003d httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n-      int responseCode \u003d httpEngine.getResponse().code();\n+      int responseCode \u003d response.code();\n       if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n           || responseCode \u003d\u003d HTTP_MOVED_PERM\n           || responseCode \u003d\u003d HTTP_MOVED_TEMP\n           || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n         retryMethod \u003d \"GET\";\n         requestHeaders.removeAll(\"Content-Length\");\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n-      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n+      if (!httpEngine.sameConnection(followUp)) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection \u003d httpEngine.close();\n       httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "996e9c95bdcafd62e84c79c512d6ccac65c30758": {
      "type": "Yfilerename",
      "commitMessage": "Move HttpUrlConnection implementation to its own package.\n",
      "commitDate": "2014-04-20, 2:59 a.m.",
      "commitName": "996e9c95bdcafd62e84c79c512d6ccac65c30758",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014-04-19, 9:19 p.m.",
      "commitNameOld": "6486179b9d9c888a818c85384eed88fa0a8768a6",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      Sink requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d httpEngine.getResponse().code();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestHeaders.removeAll(\"Content-Length\");\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java",
      "functionStartLine": 332,
      "functionName": "getResponse",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java"
      }
    },
    "84184afdb26b42ff615896f9c0161157cc84ec73": {
      "type": "Ybodychange",
      "commitMessage": "Use Sink in HttpEngine.\n",
      "commitDate": "2014-02-23, 6:13 p.m.",
      "commitName": "84184afdb26b42ff615896f9c0161157cc84ec73",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-02-22, 2:23 p.m.",
      "commitNameOld": "2581c36905db13dcd1df9a602c6201e3a9f80965",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      Sink requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d httpEngine.getResponse().code();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestHeaders.removeAll(\"Content-Length\");\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 310,
      "functionName": "getResponse",
      "diff": "@@ -1,47 +1,47 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry \u003d processResponseHeaders();\n       if (retry \u003d\u003d Retry.NONE) {\n         httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod \u003d method;\n-      OutputStream requestBody \u003d httpEngine.getRequestBody();\n+      Sink requestBody \u003d httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n       int responseCode \u003d httpEngine.getResponse().code();\n       if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n           || responseCode \u003d\u003d HTTP_MOVED_PERM\n           || responseCode \u003d\u003d HTTP_MOVED_TEMP\n           || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n         retryMethod \u003d \"GET\";\n         requestHeaders.removeAll(\"Content-Length\");\n         requestBody \u003d null;\n       }\n \n-      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n+      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableSink)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n         httpEngine.releaseConnection();\n       }\n \n       Connection connection \u003d httpEngine.close();\n-      httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);\n+      httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
      "type": "Ybodychange",
      "commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit\u0027s told.\n",
      "commitDate": "2014-02-15, 6:44 p.m.",
      "commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014-01-26, 6:09 p.m.",
      "commitNameOld": "32a2b1d8d000a19d4a340cc1d77a68973a9d65dc",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 20.02,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.releaseConnection();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d httpEngine.getResponse().code();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestHeaders.removeAll(\"Content-Length\");\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.releaseConnection();\n      }\n\n      Connection connection \u003d httpEngine.close();\n      httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 308,
      "functionName": "getResponse",
      "diff": "@@ -1,48 +1,47 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry \u003d processResponseHeaders();\n       if (retry \u003d\u003d Retry.NONE) {\n-        httpEngine.automaticallyReleaseConnectionToPool();\n+        httpEngine.releaseConnection();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod \u003d method;\n       OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n       int responseCode \u003d httpEngine.getResponse().code();\n       if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n           || responseCode \u003d\u003d HTTP_MOVED_PERM\n           || responseCode \u003d\u003d HTTP_MOVED_TEMP\n           || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n         retryMethod \u003d \"GET\";\n         requestHeaders.removeAll(\"Content-Length\");\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n-        httpEngine.automaticallyReleaseConnectionToPool();\n+        httpEngine.releaseConnection();\n       }\n \n-      httpEngine.release(false);\n-      httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(),\n-          (RetryableOutputStream) requestBody);\n+      Connection connection \u003d httpEngine.close();\n+      httpEngine \u003d newHttpEngine(retryMethod, connection, (RetryableOutputStream) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4831a8dc6577f762e0f21fd15dd9700fe824740d": {
      "type": "Ybodychange",
      "commitMessage": "Rename RawHeaders to Headers.\n\nNow that Request and Response self-describe, I think the\nword Headers is sufficient. And it\u0027s a lot less ugly than\nRawHeaders.\n\nAlso move header serialization code to HttpTransport and\nSpdyTransport.\n",
      "commitDate": "2013-12-31, 1:58 a.m.",
      "commitName": "4831a8dc6577f762e0f21fd15dd9700fe824740d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-12-31, 1:15 a.m.",
      "commitNameOld": "60f20dc23cb08d598d605f51f7526725ec42abd9",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d httpEngine.getResponse().code();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestHeaders.removeAll(\"Content-Length\");\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n      }\n\n      httpEngine.release(false);\n      httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(),\n          (RetryableOutputStream) requestBody);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 293,
      "functionName": "getResponse",
      "diff": "@@ -1,48 +1,48 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry \u003d processResponseHeaders();\n       if (retry \u003d\u003d Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod \u003d method;\n       OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n-      int responseCode \u003d httpEngine.getResponseCode();\n+      int responseCode \u003d httpEngine.getResponse().code();\n       if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n           || responseCode \u003d\u003d HTTP_MOVED_PERM\n           || responseCode \u003d\u003d HTTP_MOVED_TEMP\n           || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n         retryMethod \u003d \"GET\";\n         requestHeaders.removeAll(\"Content-Length\");\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n       httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "350c43b6fe02401a73f967d9ef322061638b372a": {
      "type": "Ybodychange",
      "commitMessage": "Make RawHeaders, RequestHeaders and ResponseHeaders immutable.\n\nThis introduces a new, poorly-named class ResponseStrategy\nthat pulls some code out of ResponseHeaders. That was necessary\nbecause the old method mutated itself and its parameters in\nplace.\n\nObvious follow-up for this is to combine ResponseHeaders with\nResponse, and RequestHeaders with Response.\n",
      "commitDate": "2013-12-29, 9:17 p.m.",
      "commitName": "350c43b6fe02401a73f967d9ef322061638b372a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-12-29, 6:57 p.m.",
      "commitNameOld": "30ecba897fb624df201f0a014b54a604418a0e73",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d httpEngine.getResponseCode();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestHeaders.removeAll(\"Content-Length\");\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n      }\n\n      httpEngine.release(false);\n      httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(),\n          (RetryableOutputStream) requestBody);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 284,
      "functionName": "getResponse",
      "diff": "@@ -1,53 +1,48 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry \u003d processResponseHeaders();\n       if (retry \u003d\u003d Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod \u003d method;\n       OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n       int responseCode \u003d httpEngine.getResponseCode();\n       if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n           || responseCode \u003d\u003d HTTP_MOVED_PERM\n           || responseCode \u003d\u003d HTTP_MOVED_TEMP\n           || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n         retryMethod \u003d \"GET\";\n+        requestHeaders.removeAll(\"Content-Length\");\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n-\n-      httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n+      httpEngine \u003d newHttpEngine(retryMethod, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n-\n-      if (requestBody \u003d\u003d null) {\n-        // Drop the Content-Length header when redirected from POST to GET.\n-        httpEngine.getRequestHeaders().removeContentLength();\n-      }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "37c01895cca5ec2bec26a3d381611f0938acd6d0": {
      "type": "Ybodychange",
      "commitMessage": "Define async APIs and switch Job to use HttpEngine directly.\n\nUsing HttpEngine directly introduces some duplicated code with\nHttpURLConnection. It also breaks the response cache. I think\nthis is the best route going forward; and eventually we could\ninvert this relationship to have HttpURLConnection depending on\nJob directly rather than vice versa.\n",
      "commitDate": "2013-12-28, 8:24 p.m.",
      "commitName": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-10-31, 5:17 p.m.",
      "commitNameOld": "adec488f99795bcba135cbbdb1b9821880425b4c",
      "commitAuthorOld": "Jon Watson",
      "daysBetweenCommits": 58.17,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d httpEngine.getResponseCode();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n      }\n\n      httpEngine.release(false);\n\n      httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n          (RetryableOutputStream) requestBody);\n\n      if (requestBody \u003d\u003d null) {\n        // Drop the Content-Length header when redirected from POST to GET.\n        httpEngine.getRequestHeaders().removeContentLength();\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 289,
      "functionName": "getResponse",
      "diff": "@@ -1,54 +1,53 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry \u003d processResponseHeaders();\n       if (retry \u003d\u003d Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod \u003d method;\n       OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n-      int responseCode \u003d getResponseCode();\n+      int responseCode \u003d httpEngine.getResponseCode();\n       if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n           || responseCode \u003d\u003d HTTP_MOVED_PERM\n           || responseCode \u003d\u003d HTTP_MOVED_TEMP\n           || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n         retryMethod \u003d \"GET\";\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n-        throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n-            httpEngine.getResponseCode());\n+        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", responseCode);\n       }\n \n       if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n \n       httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n \n       if (requestBody \u003d\u003d null) {\n         // Drop the Content-Length header when redirected from POST to GET.\n         httpEngine.getRequestHeaders().removeContentLength();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a948ffce1eb2b9ec46069722f6744f252d6dbfc7": {
      "type": "Ybodychange",
      "commitMessage": "Drop Content-Length when redirected from POST to GET.\n\nhttps://github.com/square/okhttp/issues/296\n",
      "commitDate": "2013-08-24, 2:11 p.m.",
      "commitName": "a948ffce1eb2b9ec46069722f6744f252d6dbfc7",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-07-20, 11:13 a.m.",
      "commitNameOld": "de1b5f244df1e29c457fdd87e91b9919c2336da7",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 35.12,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d getResponseCode();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n            httpEngine.getResponseCode());\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n      }\n\n      httpEngine.release(false);\n\n      httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n          (RetryableOutputStream) requestBody);\n\n      if (requestBody \u003d\u003d null) {\n        // Drop the Content-Length header when redirected from POST to GET.\n        httpEngine.getRequestHeaders().removeContentLength();\n      }\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 287,
      "functionName": "getResponse",
      "diff": "@@ -1,49 +1,54 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry \u003d processResponseHeaders();\n       if (retry \u003d\u003d Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n       // The first request was insufficient. Prepare for another...\n       String retryMethod \u003d method;\n       OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n       // redirect should keep the same method, Chrome, Firefox and the\n       // RI all issue GETs when following any redirect.\n       int responseCode \u003d getResponseCode();\n       if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n           || responseCode \u003d\u003d HTTP_MOVED_PERM\n           || responseCode \u003d\u003d HTTP_MOVED_TEMP\n           || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n         retryMethod \u003d \"GET\";\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n             httpEngine.getResponseCode());\n       }\n \n       if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n \n       httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n+\n+      if (requestBody \u003d\u003d null) {\n+        // Drop the Content-Length header when redirected from POST to GET.\n+        httpEngine.getRequestHeaders().removeContentLength();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": {
      "type": "Yfilerename",
      "commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
      "commitDate": "2013-03-25, 11:04 p.m.",
      "commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2013-03-15, 10:39 a.m.",
      "commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d getResponseCode();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n            httpEngine.getResponseCode());\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n      }\n\n      httpEngine.release(false);\n\n      httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n          (RetryableOutputStream) requestBody);\n    }\n  }",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 293,
      "functionName": "getResponse",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java"
      }
    },
    "7e7a3896df109ef442af9ec69423c33ec667c9f5": {
      "type": "Ybodychange",
      "commitMessage": "Switch to Square style for comments.\n",
      "commitDate": "2013-02-01, 11:13 a.m.",
      "commitName": "7e7a3896df109ef442af9ec69423c33ec667c9f5",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-01-31, 5:36 p.m.",
      "commitNameOld": "2d45a13249943cafa73460b35c3c366e5742eb6f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "  private HttpEngine getResponse() throws IOException {\n    initHttpEngine();\n\n    if (httpEngine.hasResponse()) {\n      return httpEngine;\n    }\n\n    while (true) {\n      if (!execute(true)) {\n        continue;\n      }\n\n      Retry retry \u003d processResponseHeaders();\n      if (retry \u003d\u003d Retry.NONE) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n        return httpEngine;\n      }\n\n      // The first request was insufficient. Prepare for another...\n      String retryMethod \u003d method;\n      OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n      // redirect should keep the same method, Chrome, Firefox and the\n      // RI all issue GETs when following any redirect.\n      int responseCode \u003d getResponseCode();\n      if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n          || responseCode \u003d\u003d HTTP_MOVED_PERM\n          || responseCode \u003d\u003d HTTP_MOVED_TEMP\n          || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n        retryMethod \u003d \"GET\";\n        requestBody \u003d null;\n      }\n\n      if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n            httpEngine.getResponseCode());\n      }\n\n      if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n        httpEngine.automaticallyReleaseConnectionToPool();\n      }\n\n      httpEngine.release(false);\n\n      httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n          (RetryableOutputStream) requestBody);\n    }\n  }",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 277,
      "functionName": "getResponse",
      "diff": "@@ -1,53 +1,49 @@\n   private HttpEngine getResponse() throws IOException {\n     initHttpEngine();\n \n     if (httpEngine.hasResponse()) {\n       return httpEngine;\n     }\n \n     while (true) {\n       if (!execute(true)) {\n         continue;\n       }\n \n       Retry retry \u003d processResponseHeaders();\n       if (retry \u003d\u003d Retry.NONE) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n         return httpEngine;\n       }\n \n-            /*\n-             * The first request was insufficient. Prepare for another...\n-             */\n+      // The first request was insufficient. Prepare for another...\n       String retryMethod \u003d method;\n       OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n-            /*\n-             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n-             * redirect should keep the same method, Chrome, Firefox and the\n-             * RI all issue GETs when following any redirect.\n-             */\n+      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n+      // redirect should keep the same method, Chrome, Firefox and the\n+      // RI all issue GETs when following any redirect.\n       int responseCode \u003d getResponseCode();\n       if (responseCode \u003d\u003d HTTP_MULT_CHOICE\n           || responseCode \u003d\u003d HTTP_MOVED_PERM\n           || responseCode \u003d\u003d HTTP_MOVED_TEMP\n           || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n         retryMethod \u003d \"GET\";\n         requestBody \u003d null;\n       }\n \n       if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n         throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n             httpEngine.getResponseCode());\n       }\n \n       if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n         httpEngine.automaticallyReleaseConnectionToPool();\n       }\n \n       httpEngine.release(false);\n \n       httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),\n           (RetryableOutputStream) requestBody);\n     }\n   }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f6d959fdae64065521990413f86bc7ab038d7c1": {
      "type": "Ybodychange",
      "commitMessage": "Improvements to connection pool\n",
      "commitDate": "2013-01-31, 5:23 p.m.",
      "commitName": "6f6d959fdae64065521990413f86bc7ab038d7c1",
      "commitAuthor": "Marcelo Cortes",
      "commitDateOld": "2013-01-31, 12:55 a.m.",
      "commitNameOld": "83de4eb552994d30451f8a3481b5a00d6b457a2e",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private HttpEngine getResponse() throws IOException {\n        initHttpEngine();\n\n        if (httpEngine.hasResponse()) {\n            return httpEngine;\n        }\n\n        while (true) {\n            if (!execute(true)) {\n                continue;\n            }\n\n            Retry retry \u003d processResponseHeaders();\n            if (retry \u003d\u003d Retry.NONE) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n                return httpEngine;\n            }\n\n            /*\n             * The first request was insufficient. Prepare for another...\n             */\n            String retryMethod \u003d method;\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n            /*\n             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n             * redirect should keep the same method, Chrome, Firefox and the\n             * RI all issue GETs when following any redirect.\n             */\n            int responseCode \u003d getResponseCode();\n            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                retryMethod \u003d \"GET\";\n                requestBody \u003d null;\n            }\n\n            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                        httpEngine.getResponseCode());\n            }\n\n            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n            }\n\n            httpEngine.release(false);\n\n            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        }\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "diff": "@@ -1,53 +1,51 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n             if (!execute(true)) {\n                 continue;\n             }\n \n             Retry retry \u003d processResponseHeaders();\n             if (retry \u003d\u003d Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod \u003d method;\n             OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode \u003d getResponseCode();\n             if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                     || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                 retryMethod \u003d \"GET\";\n                 requestBody \u003d null;\n             }\n \n             if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n-            } else if (retry \u003d\u003d Retry.SAME_CONNECTION \u0026\u0026 httpEngine.getConnection() !\u003d null) {\n-                httpEngine.getConnection().setRecycled();\n             }\n \n             httpEngine.release(false);\n \n             httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "637783ce8ae3ffb9805c2f78b436703c29b2220a": {
      "type": "Ybodychange",
      "commitMessage": "Retry if a request fails after a redirect.\n\nhttps://code.google.com/p/android/issues/detail?id\u003d41576\n",
      "commitDate": "2013-01-31, 12:05 a.m.",
      "commitName": "637783ce8ae3ffb9805c2f78b436703c29b2220a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-01-22, 4:14 p.m.",
      "commitNameOld": "194290e5f3819bf91d87c5d08c152946b6aa3509",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 8.33,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private HttpEngine getResponse() throws IOException {\n        initHttpEngine();\n\n        if (httpEngine.hasResponse()) {\n            return httpEngine;\n        }\n\n        while (true) {\n            if (!execute(true)) {\n                continue;\n            }\n\n            Retry retry \u003d processResponseHeaders();\n            if (retry \u003d\u003d Retry.NONE) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n                return httpEngine;\n            }\n\n            /*\n             * The first request was insufficient. Prepare for another...\n             */\n            String retryMethod \u003d method;\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n            /*\n             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n             * redirect should keep the same method, Chrome, Firefox and the\n             * RI all issue GETs when following any redirect.\n             */\n            int responseCode \u003d getResponseCode();\n            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                retryMethod \u003d \"GET\";\n                requestBody \u003d null;\n            }\n\n            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                        httpEngine.getResponseCode());\n            }\n\n            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n            } else if (retry \u003d\u003d Retry.SAME_CONNECTION \u0026\u0026 httpEngine.getConnection() !\u003d null) {\n                httpEngine.getConnection().setRecycled();\n            }\n\n            httpEngine.release(false);\n\n            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        }\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "diff": "@@ -1,51 +1,53 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n             if (!execute(true)) {\n                 continue;\n             }\n \n             Retry retry \u003d processResponseHeaders();\n             if (retry \u003d\u003d Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod \u003d method;\n             OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode \u003d getResponseCode();\n             if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                     || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                 retryMethod \u003d \"GET\";\n                 requestBody \u003d null;\n             }\n \n             if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n+            } else if (retry \u003d\u003d Retry.SAME_CONNECTION \u0026\u0026 httpEngine.getConnection() !\u003d null) {\n+                httpEngine.getConnection().setRecycled();\n             }\n \n             httpEngine.release(false);\n \n             httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "194290e5f3819bf91d87c5d08c152946b6aa3509": {
      "type": "Ybodychange",
      "commitMessage": "Improve SPDY+HTTP integration.\n\nWriting tests shook out a few bugs:\n - Pooling wasn\u0027t working well. We were trying to connect\n   after already having been connected.\n - We weren\u0027t writing response bodies to the cache.\n - We weren\u0027t capturing the request time for the cache.\n - MockSpdyServer wasn\u0027t trimming headers.\n\nNew files in this change aren\u0027t new, they\u0027re just inner classes promoted\nto top-level classes for better sharing.\n",
      "commitDate": "2013-01-22, 4:14 p.m.",
      "commitName": "194290e5f3819bf91d87c5d08c152946b6aa3509",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-01-01, 10:50 p.m.",
      "commitNameOld": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 20.73,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    private HttpEngine getResponse() throws IOException {\n        initHttpEngine();\n\n        if (httpEngine.hasResponse()) {\n            return httpEngine;\n        }\n\n        while (true) {\n            if (!execute(true)) {\n                continue;\n            }\n\n            Retry retry \u003d processResponseHeaders();\n            if (retry \u003d\u003d Retry.NONE) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n                return httpEngine;\n            }\n\n            /*\n             * The first request was insufficient. Prepare for another...\n             */\n            String retryMethod \u003d method;\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n            /*\n             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n             * redirect should keep the same method, Chrome, Firefox and the\n             * RI all issue GETs when following any redirect.\n             */\n            int responseCode \u003d getResponseCode();\n            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                retryMethod \u003d \"GET\";\n                requestBody \u003d null;\n            }\n\n            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                        httpEngine.getResponseCode());\n            }\n\n            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n            }\n\n            httpEngine.release(false);\n\n            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        }\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "diff": "@@ -1,51 +1,51 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n             if (!execute(true)) {\n                 continue;\n             }\n \n             Retry retry \u003d processResponseHeaders();\n             if (retry \u003d\u003d Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod \u003d method;\n             OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode \u003d getResponseCode();\n             if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                     || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                 retryMethod \u003d \"GET\";\n                 requestBody \u003d null;\n             }\n \n             if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n             }\n \n-            httpEngine.release(true);\n+            httpEngine.release(false);\n \n             httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "689f66222bd8984dd69229a4ee9caf8da528ae12": {
      "type": "Yfilerename",
      "commitMessage": "Flatten internal packages and utility classes.\n\nThe previous structure had hierarchy that was useful\nfor libcore but overkill for OkHttp.\n",
      "commitDate": "2013-01-01, 10:50 p.m.",
      "commitName": "689f66222bd8984dd69229a4ee9caf8da528ae12",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013-01-01, 10:27 p.m.",
      "commitNameOld": "73516e6ab1d336ffd520e845e14f80cf08657bd0",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private HttpEngine getResponse() throws IOException {\n        initHttpEngine();\n\n        if (httpEngine.hasResponse()) {\n            return httpEngine;\n        }\n\n        while (true) {\n            if (!execute(true)) {\n                continue;\n            }\n\n            Retry retry \u003d processResponseHeaders();\n            if (retry \u003d\u003d Retry.NONE) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n                return httpEngine;\n            }\n\n            /*\n             * The first request was insufficient. Prepare for another...\n             */\n            String retryMethod \u003d method;\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n            /*\n             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n             * redirect should keep the same method, Chrome, Firefox and the\n             * RI all issue GETs when following any redirect.\n             */\n            int responseCode \u003d getResponseCode();\n            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                retryMethod \u003d \"GET\";\n                requestBody \u003d null;\n            }\n\n            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                        httpEngine.getResponseCode());\n            }\n\n            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n            }\n\n            httpEngine.release(true);\n\n            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        }\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java"
      }
    },
    "67604f618d96ae00318ce696ec29a66bec6aafa8": {
      "type": "Ybodychange",
      "commitMessage": "Clean up utility code for submission to AOSP.\n\nThis moves methods that will have Android-specific implementations\nto Platform.java; all other utility methods are in a junk drawer\nclass called Utils.java.\n\nThis also moves method names (like \"GET\") to compare with .equals\ninstead of \u0027\u003d\u003d\u0027. The old code took advantage of a hidden agreement\nbetween HttpURLConnection and HttpEngine; with these in separate\nprojects that behavior isn\u0027t as obvious and shouldn\u0027t be relied\nupon.\n",
      "commitDate": "2012-12-26, 1:31 p.m.",
      "commitName": "67604f618d96ae00318ce696ec29a66bec6aafa8",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012-12-24, 12:39 a.m.",
      "commitNameOld": "78c6624b11d5f33504dae8211b4592383468343e",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.54,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private HttpEngine getResponse() throws IOException {\n        initHttpEngine();\n\n        if (httpEngine.hasResponse()) {\n            return httpEngine;\n        }\n\n        while (true) {\n            if (!execute(true)) {\n                continue;\n            }\n\n            Retry retry \u003d processResponseHeaders();\n            if (retry \u003d\u003d Retry.NONE) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n                return httpEngine;\n            }\n\n            /*\n             * The first request was insufficient. Prepare for another...\n             */\n            String retryMethod \u003d method;\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n            /*\n             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n             * redirect should keep the same method, Chrome, Firefox and the\n             * RI all issue GETs when following any redirect.\n             */\n            int responseCode \u003d getResponseCode();\n            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                retryMethod \u003d \"GET\";\n                requestBody \u003d null;\n            }\n\n            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                        httpEngine.getResponseCode());\n            }\n\n            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n            }\n\n            httpEngine.release(true);\n\n            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        }\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java",
      "functionStartLine": 286,
      "functionName": "getResponse",
      "diff": "@@ -1,51 +1,51 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n             if (!execute(true)) {\n                 continue;\n             }\n \n             Retry retry \u003d processResponseHeaders();\n             if (retry \u003d\u003d Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod \u003d method;\n             OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode \u003d getResponseCode();\n             if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                     || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n-                retryMethod \u003d HttpEngine.GET;\n+                retryMethod \u003d \"GET\";\n                 requestBody \u003d null;\n             }\n \n             if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n             }\n \n             httpEngine.release(true);\n \n             httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
      "type": "Yfilerename",
      "commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we\u0027ll keep this package as-is\nand do the jarjar in Android instead.\n",
      "commitDate": "2012-12-15, 4:55 p.m.",
      "commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012-12-15, 4:17 p.m.",
      "commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private HttpEngine getResponse() throws IOException {\n        initHttpEngine();\n\n        if (httpEngine.hasResponse()) {\n            return httpEngine;\n        }\n\n        while (true) {\n            if (!execute(true)) {\n                continue;\n            }\n\n            Retry retry \u003d processResponseHeaders();\n            if (retry \u003d\u003d Retry.NONE) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n                return httpEngine;\n            }\n\n            /*\n             * The first request was insufficient. Prepare for another...\n             */\n            String retryMethod \u003d method;\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n            /*\n             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n             * redirect should keep the same method, Chrome, Firefox and the\n             * RI all issue GETs when following any redirect.\n             */\n            int responseCode \u003d getResponseCode();\n            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                retryMethod \u003d HttpEngine.GET;\n                requestBody \u003d null;\n            }\n\n            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                        httpEngine.getResponseCode());\n            }\n\n            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n            }\n\n            httpEngine.release(true);\n\n            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        }\n    }",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java",
      "functionStartLine": 275,
      "functionName": "getResponse",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/libcore/net/http/HttpURLConnectionImpl.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpURLConnectionImpl.java"
      }
    },
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": {
      "type": "Ybodychange",
      "commitMessage": "New route selector to support multiple routes.\n",
      "commitDate": "2012-11-10, 4:05 p.m.",
      "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2012-11-05, 11:25 p.m.",
      "commitNameOld": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 4.69,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private HttpEngine getResponse() throws IOException {\n        initHttpEngine();\n\n        if (httpEngine.hasResponse()) {\n            return httpEngine;\n        }\n\n        while (true) {\n            if (!execute(true)) {\n                continue;\n            }\n\n            Retry retry \u003d processResponseHeaders();\n            if (retry \u003d\u003d Retry.NONE) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n                return httpEngine;\n            }\n\n            /*\n             * The first request was insufficient. Prepare for another...\n             */\n            String retryMethod \u003d method;\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n            /*\n             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n             * redirect should keep the same method, Chrome, Firefox and the\n             * RI all issue GETs when following any redirect.\n             */\n            int responseCode \u003d getResponseCode();\n            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                retryMethod \u003d HttpEngine.GET;\n                requestBody \u003d null;\n            }\n\n            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                        httpEngine.getResponseCode());\n            }\n\n            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n            }\n\n            httpEngine.release(true);\n\n            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        }\n    }",
      "path": "src/main/java/libcore/net/http/HttpURLConnectionImpl.java",
      "functionStartLine": 272,
      "functionName": "getResponse",
      "diff": "@@ -1,67 +1,51 @@\n     private HttpEngine getResponse() throws IOException {\n         initHttpEngine();\n \n         if (httpEngine.hasResponse()) {\n             return httpEngine;\n         }\n \n         while (true) {\n-            try {\n-                httpEngine.sendRequest();\n-                httpEngine.readResponse();\n-            } catch (IOException e) {\n-                /*\n-                 * If the connection was recycled, its staleness may have caused\n-                 * the failure. Silently retry with a different connection.\n-                 */\n-                OutputStream requestBody \u003d httpEngine.getRequestBody();\n-                if (httpEngine.hasRecycledConnection()\n-                        \u0026\u0026 (requestBody \u003d\u003d null || requestBody instanceof RetryableOutputStream)) {\n-                    httpEngine.release(false);\n-                    httpEngine \u003d newHttpEngine(method, rawRequestHeaders, null,\n-                            (RetryableOutputStream) requestBody);\n-                    continue;\n-                }\n-                httpEngineFailure \u003d e;\n-                throw e;\n+            if (!execute(true)) {\n+                continue;\n             }\n \n             Retry retry \u003d processResponseHeaders();\n             if (retry \u003d\u003d Retry.NONE) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n                 return httpEngine;\n             }\n \n             /*\n              * The first request was insufficient. Prepare for another...\n              */\n             String retryMethod \u003d method;\n             OutputStream requestBody \u003d httpEngine.getRequestBody();\n \n             /*\n              * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n              * redirect should keep the same method, Chrome, Firefox and the\n              * RI all issue GETs when following any redirect.\n              */\n             int responseCode \u003d getResponseCode();\n             if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                     || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                 retryMethod \u003d HttpEngine.GET;\n                 requestBody \u003d null;\n             }\n \n             if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                 throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                         httpEngine.getResponseCode());\n             }\n \n             if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                 httpEngine.automaticallyReleaseConnectionToPool();\n             }\n \n             httpEngine.release(true);\n \n             httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                     httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
      "type": "Yintroduced",
      "commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI\u0027m moving it to Github since that\u0027s where my code reviewers\nare. I\u0027ve renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
      "commitDate": "2012-07-23, 10:02 a.m.",
      "commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,67 @@\n+    private HttpEngine getResponse() throws IOException {\n+        initHttpEngine();\n+\n+        if (httpEngine.hasResponse()) {\n+            return httpEngine;\n+        }\n+\n+        while (true) {\n+            try {\n+                httpEngine.sendRequest();\n+                httpEngine.readResponse();\n+            } catch (IOException e) {\n+                /*\n+                 * If the connection was recycled, its staleness may have caused\n+                 * the failure. Silently retry with a different connection.\n+                 */\n+                OutputStream requestBody \u003d httpEngine.getRequestBody();\n+                if (httpEngine.hasRecycledConnection()\n+                        \u0026\u0026 (requestBody \u003d\u003d null || requestBody instanceof RetryableOutputStream)) {\n+                    httpEngine.release(false);\n+                    httpEngine \u003d newHttpEngine(method, rawRequestHeaders, null,\n+                            (RetryableOutputStream) requestBody);\n+                    continue;\n+                }\n+                httpEngineFailure \u003d e;\n+                throw e;\n+            }\n+\n+            Retry retry \u003d processResponseHeaders();\n+            if (retry \u003d\u003d Retry.NONE) {\n+                httpEngine.automaticallyReleaseConnectionToPool();\n+                return httpEngine;\n+            }\n+\n+            /*\n+             * The first request was insufficient. Prepare for another...\n+             */\n+            String retryMethod \u003d method;\n+            OutputStream requestBody \u003d httpEngine.getRequestBody();\n+\n+            /*\n+             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n+             * redirect should keep the same method, Chrome, Firefox and the\n+             * RI all issue GETs when following any redirect.\n+             */\n+            int responseCode \u003d getResponseCode();\n+            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n+                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n+                retryMethod \u003d HttpEngine.GET;\n+                requestBody \u003d null;\n+            }\n+\n+            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n+                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n+                        httpEngine.getResponseCode());\n+            }\n+\n+            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n+                httpEngine.automaticallyReleaseConnectionToPool();\n+            }\n+\n+            httpEngine.release(true);\n+\n+            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n+                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private HttpEngine getResponse() throws IOException {\n        initHttpEngine();\n\n        if (httpEngine.hasResponse()) {\n            return httpEngine;\n        }\n\n        while (true) {\n            try {\n                httpEngine.sendRequest();\n                httpEngine.readResponse();\n            } catch (IOException e) {\n                /*\n                 * If the connection was recycled, its staleness may have caused\n                 * the failure. Silently retry with a different connection.\n                 */\n                OutputStream requestBody \u003d httpEngine.getRequestBody();\n                if (httpEngine.hasRecycledConnection()\n                        \u0026\u0026 (requestBody \u003d\u003d null || requestBody instanceof RetryableOutputStream)) {\n                    httpEngine.release(false);\n                    httpEngine \u003d newHttpEngine(method, rawRequestHeaders, null,\n                            (RetryableOutputStream) requestBody);\n                    continue;\n                }\n                httpEngineFailure \u003d e;\n                throw e;\n            }\n\n            Retry retry \u003d processResponseHeaders();\n            if (retry \u003d\u003d Retry.NONE) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n                return httpEngine;\n            }\n\n            /*\n             * The first request was insufficient. Prepare for another...\n             */\n            String retryMethod \u003d method;\n            OutputStream requestBody \u003d httpEngine.getRequestBody();\n\n            /*\n             * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM\n             * redirect should keep the same method, Chrome, Firefox and the\n             * RI all issue GETs when following any redirect.\n             */\n            int responseCode \u003d getResponseCode();\n            if (responseCode \u003d\u003d HTTP_MULT_CHOICE || responseCode \u003d\u003d HTTP_MOVED_PERM\n                    || responseCode \u003d\u003d HTTP_MOVED_TEMP || responseCode \u003d\u003d HTTP_SEE_OTHER) {\n                retryMethod \u003d HttpEngine.GET;\n                requestBody \u003d null;\n            }\n\n            if (requestBody !\u003d null \u0026\u0026 !(requestBody instanceof RetryableOutputStream)) {\n                throw new HttpRetryException(\"Cannot retry streamed HTTP body\",\n                        httpEngine.getResponseCode());\n            }\n\n            if (retry \u003d\u003d Retry.DIFFERENT_CONNECTION) {\n                httpEngine.automaticallyReleaseConnectionToPool();\n            }\n\n            httpEngine.release(true);\n\n            httpEngine \u003d newHttpEngine(retryMethod, rawRequestHeaders,\n                    httpEngine.getConnection(), (RetryableOutputStream) requestBody);\n        }\n    }",
      "path": "src/main/java/libcore/net/http/HttpURLConnectionImpl.java",
      "functionStartLine": 271,
      "functionName": "getResponse"
    }
  }
}