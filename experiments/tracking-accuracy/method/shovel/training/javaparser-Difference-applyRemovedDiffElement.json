{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "Difference.java",
  "functionName": "applyRemovedDiffElement",
  "functionId": "applyRemovedDiffElement___removedGroup-RemovedGroup__removed-Removed__originalElement-TextElement__originalElementIsChild-boolean__originalElementIsToken-boolean",
  "sourceFilePath": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
  "functionStartLine": 339,
  "functionEndLine": 393,
  "numCommitsSeen": 168,
  "timeTaken": 449,
  "changeHistory": [
    "4f9e0c67e6f11738be45155bd5606f18445fcec7",
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38"
  ],
  "changeHistoryShort": {
    "4f9e0c67e6f11738be45155bd5606f18445fcec7": "Ybodychange",
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632": "Ymultichange(Yparameterchange,Ybodychange)",
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4f9e0c67e6f11738be45155bd5606f18445fcec7": {
      "type": "Ybodychange",
      "commitMessage": "combined logics to clean the line and added new unit test\n",
      "commitDate": "2018-06-07, 4:54 p.m.",
      "commitName": "4f9e0c67e6f11738be45155bd5606f18445fcec7",
      "commitAuthor": "Thomas Leu",
      "commitDateOld": "2018-06-07, 4:54 p.m.",
      "commitNameOld": "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
      "commitAuthorOld": "Thomas Leu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n            ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment \u003d (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n\n                if ((diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added))\n                        \u0026\u0026 !removedGroup.isACompleteLine()) {\n                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let\u0027s drop one space\n                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace()\n                            \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n\n                diffIndex++;\n            }\n        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (isPrimitiveType(originalElement)) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace()) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n\n        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 326,
      "functionName": "applyRemovedDiffElement",
      "diff": "@@ -1,66 +1,55 @@\n     private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n             ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n             if (originalElementChild.isComment()) {\n                 // We expected to remove a proper node but we found a comment in between.\n                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                 Comment comment \u003d (Comment) originalElementChild.getChild();\n                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                     nodeText.removeElement(originalIndex);\n                 } else {\n                     originalIndex++;\n                 }\n             } else {\n                 nodeText.removeElement(originalIndex);\n \n                 if ((diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added))\n                         \u0026\u0026 !removedGroup.isACompleteLine()) {\n                     originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                 }\n                 // If in front we have one space and before also we had space let\u0027s drop one space\n                 if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                     if (originalElements.get(originalIndex).isWhiteSpace()\n                             \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                         // However we do not want to do that when we are about to adding or removing elements\n                         if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                             originalElements.remove(originalIndex--);\n                         }\n                     }\n                 }\n \n                 diffIndex++;\n             }\n         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                 \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n             nodeText.removeElement(originalIndex);\n             diffIndex++;\n         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n             originalIndex++;\n         } else if (removed.isPrimitiveType()) {\n             if (isPrimitiveType(originalElement)) {\n                 nodeText.removeElement(originalIndex);\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n             }\n         } else if (removed.isWhiteSpace()) {\n             diffIndex++;\n         } else if (originalElement.isWhiteSpace()) {\n             originalIndex++;\n         } else {\n             throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n         }\n \n-        if (removedGroup.isACompleteLine() \u0026\u0026 removedGroup.getLastElement() \u003d\u003d removed) {\n-            Integer lastElementIndex \u003d removedGroup.getLastElementIndex();\n-            Optional\u003cInteger\u003e indentation \u003d removedGroup.getIndentation();\n-\n-            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n-                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n-            } else if (!isReplaced(lastElementIndex) \u0026\u0026 indentation.isPresent()) {\n-                for (int i \u003d 0; i \u003c indentation.get(); i++) {\n-                    nodeText.removeElement(originalIndex);\n-                }\n-            }\n-        }\n+        cleanTheLineOfLeftOverSpace(removedGroup, removed);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2d3f5e219af9d1ba916f1dc21a6169a41a254632": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "built RemovedGroup into Difference class to be able to handle indentations better for removed elements\n",
      "commitDate": "2018-06-07, 4:54 p.m.",
      "commitName": "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
      "commitAuthor": "Thomas Leu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "built RemovedGroup into Difference class to be able to handle indentations better for removed elements\n",
          "commitDate": "2018-06-07, 4:54 p.m.",
          "commitName": "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
          "commitAuthor": "Thomas Leu",
          "commitDateOld": "2018-06-07, 4:54 p.m.",
          "commitNameOld": "996b78486d0db86dece4457a7faa9b314dc3b847",
          "commitAuthorOld": "Thomas Leu",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n            ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment \u003d (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n\n                if ((diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added))\n                        \u0026\u0026 !removedGroup.isACompleteLine()) {\n                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let\u0027s drop one space\n                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace()\n                            \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n\n                diffIndex++;\n            }\n        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (isPrimitiveType(originalElement)) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace()) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n\n        if (removedGroup.isACompleteLine() \u0026\u0026 removedGroup.getLastElement() \u003d\u003d removed) {\n            Integer lastElementIndex \u003d removedGroup.getLastElementIndex();\n            Optional\u003cInteger\u003e indentation \u003d removedGroup.getIndentation();\n\n            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n            } else if (!isReplaced(lastElementIndex) \u0026\u0026 indentation.isPresent()) {\n                for (int i \u003d 0; i \u003c indentation.get(); i++) {\n                    nodeText.removeElement(originalIndex);\n                }\n            }\n        }\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 334,
          "functionName": "applyRemovedDiffElement",
          "diff": "@@ -1,54 +1,66 @@\n-    private void applyRemovedDiffElement(Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n+    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n-            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n+            ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n             if (originalElementChild.isComment()) {\n                 // We expected to remove a proper node but we found a comment in between.\n                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n-                Comment comment \u003d (Comment)originalElementChild.getChild();\n+                Comment comment \u003d (Comment) originalElementChild.getChild();\n                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                     nodeText.removeElement(originalIndex);\n                 } else {\n                     originalIndex++;\n                 }\n             } else {\n                 nodeText.removeElement(originalIndex);\n-                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n-                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n-                } else {\n-                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n-                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n-                    }\n-                    // If in front we have one space and before also we had space let\u0027s drop one space\n-                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n-                        if (originalElements.get(originalIndex).isWhiteSpace()\n-                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n-                            // However we do not want to do that when we are about to adding or removing elements\n-                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                originalElements.remove(originalIndex--);\n-                            }\n+\n+                if ((diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added))\n+                        \u0026\u0026 !removedGroup.isACompleteLine()) {\n+                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n+                }\n+                // If in front we have one space and before also we had space let\u0027s drop one space\n+                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n+                    if (originalElements.get(originalIndex).isWhiteSpace()\n+                            \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n+                        // However we do not want to do that when we are about to adding or removing elements\n+                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                            originalElements.remove(originalIndex--);\n                         }\n                     }\n                 }\n+\n                 diffIndex++;\n             }\n         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n-                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n+                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n             nodeText.removeElement(originalIndex);\n             diffIndex++;\n         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n             originalIndex++;\n         } else if (removed.isPrimitiveType()) {\n             if (isPrimitiveType(originalElement)) {\n                 nodeText.removeElement(originalIndex);\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n             }\n         } else if (removed.isWhiteSpace()) {\n             diffIndex++;\n         } else if (originalElement.isWhiteSpace()) {\n             originalIndex++;\n         } else {\n             throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n         }\n+\n+        if (removedGroup.isACompleteLine() \u0026\u0026 removedGroup.getLastElement() \u003d\u003d removed) {\n+            Integer lastElementIndex \u003d removedGroup.getLastElementIndex();\n+            Optional\u003cInteger\u003e indentation \u003d removedGroup.getIndentation();\n+\n+            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n+                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n+            } else if (!isReplaced(lastElementIndex) \u0026\u0026 indentation.isPresent()) {\n+                for (int i \u003d 0; i \u003c indentation.get(); i++) {\n+                    nodeText.removeElement(originalIndex);\n+                }\n+            }\n+        }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[removed-Removed, originalElement-TextElement, originalElementIsChild-boolean, originalElementIsToken-boolean]",
            "newValue": "[removedGroup-RemovedGroup, removed-Removed, originalElement-TextElement, originalElementIsChild-boolean, originalElementIsToken-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "built RemovedGroup into Difference class to be able to handle indentations better for removed elements\n",
          "commitDate": "2018-06-07, 4:54 p.m.",
          "commitName": "2d3f5e219af9d1ba916f1dc21a6169a41a254632",
          "commitAuthor": "Thomas Leu",
          "commitDateOld": "2018-06-07, 4:54 p.m.",
          "commitNameOld": "996b78486d0db86dece4457a7faa9b314dc3b847",
          "commitAuthorOld": "Thomas Leu",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n            ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment \u003d (Comment) originalElementChild.getChild();\n                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n\n                if ((diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added))\n                        \u0026\u0026 !removedGroup.isACompleteLine()) {\n                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                }\n                // If in front we have one space and before also we had space let\u0027s drop one space\n                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                    if (originalElements.get(originalIndex).isWhiteSpace()\n                            \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                        // However we do not want to do that when we are about to adding or removing elements\n                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                            originalElements.remove(originalIndex--);\n                        }\n                    }\n                }\n\n                diffIndex++;\n            }\n        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (isPrimitiveType(originalElement)) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace()) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n\n        if (removedGroup.isACompleteLine() \u0026\u0026 removedGroup.getLastElement() \u003d\u003d removed) {\n            Integer lastElementIndex \u003d removedGroup.getLastElementIndex();\n            Optional\u003cInteger\u003e indentation \u003d removedGroup.getIndentation();\n\n            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n            } else if (!isReplaced(lastElementIndex) \u0026\u0026 indentation.isPresent()) {\n                for (int i \u003d 0; i \u003c indentation.get(); i++) {\n                    nodeText.removeElement(originalIndex);\n                }\n            }\n        }\n    }",
          "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
          "functionStartLine": 334,
          "functionName": "applyRemovedDiffElement",
          "diff": "@@ -1,54 +1,66 @@\n-    private void applyRemovedDiffElement(Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n+    private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n         if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n-            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n+            ChildTextElement originalElementChild \u003d (ChildTextElement) originalElement;\n             if (originalElementChild.isComment()) {\n                 // We expected to remove a proper node but we found a comment in between.\n                 // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n-                Comment comment \u003d (Comment)originalElementChild.getChild();\n+                Comment comment \u003d (Comment) originalElementChild.getChild();\n                 if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                     nodeText.removeElement(originalIndex);\n                 } else {\n                     originalIndex++;\n                 }\n             } else {\n                 nodeText.removeElement(originalIndex);\n-                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n-                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n-                } else {\n-                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n-                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n-                    }\n-                    // If in front we have one space and before also we had space let\u0027s drop one space\n-                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n-                        if (originalElements.get(originalIndex).isWhiteSpace()\n-                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n-                            // However we do not want to do that when we are about to adding or removing elements\n-                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n-                                originalElements.remove(originalIndex--);\n-                            }\n+\n+                if ((diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added))\n+                        \u0026\u0026 !removedGroup.isACompleteLine()) {\n+                    originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n+                }\n+                // If in front we have one space and before also we had space let\u0027s drop one space\n+                if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n+                    if (originalElements.get(originalIndex).isWhiteSpace()\n+                            \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n+                        // However we do not want to do that when we are about to adding or removing elements\n+                        if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                            originalElements.remove(originalIndex--);\n                         }\n                     }\n                 }\n+\n                 diffIndex++;\n             }\n         } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n-                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n+                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement) originalElement).getTokenKind())) {\n             nodeText.removeElement(originalIndex);\n             diffIndex++;\n         } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n             originalIndex++;\n         } else if (removed.isPrimitiveType()) {\n             if (isPrimitiveType(originalElement)) {\n                 nodeText.removeElement(originalIndex);\n                 diffIndex++;\n             } else {\n                 throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n             }\n         } else if (removed.isWhiteSpace()) {\n             diffIndex++;\n         } else if (originalElement.isWhiteSpace()) {\n             originalIndex++;\n         } else {\n             throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n         }\n+\n+        if (removedGroup.isACompleteLine() \u0026\u0026 removedGroup.getLastElement() \u003d\u003d removed) {\n+            Integer lastElementIndex \u003d removedGroup.getLastElementIndex();\n+            Optional\u003cInteger\u003e indentation \u003d removedGroup.getIndentation();\n+\n+            if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n+                originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n+            } else if (!isReplaced(lastElementIndex) \u0026\u0026 indentation.isPresent()) {\n+                for (int i \u003d 0; i \u003c indentation.get(); i++) {\n+                    nodeText.removeElement(originalIndex);\n+                }\n+            }\n+        }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b7bd15d12e107c85e29912960f7b4e48aac4dc38": {
      "type": "Yintroduced",
      "commitMessage": "Reduced cognitive complexity by extracting some methods\n",
      "commitDate": "2018-05-18, 9:34 p.m.",
      "commitName": "b7bd15d12e107c85e29912960f7b4e48aac4dc38",
      "commitAuthor": "Thomas Leu",
      "diff": "@@ -0,0 +1,54 @@\n+    private void applyRemovedDiffElement(Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n+        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n+            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n+            if (originalElementChild.isComment()) {\n+                // We expected to remove a proper node but we found a comment in between.\n+                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n+                Comment comment \u003d (Comment)originalElementChild.getChild();\n+                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n+                    nodeText.removeElement(originalIndex);\n+                } else {\n+                    originalIndex++;\n+                }\n+            } else {\n+                nodeText.removeElement(originalIndex);\n+                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n+                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n+                } else {\n+                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n+                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n+                    }\n+                    // If in front we have one space and before also we had space let\u0027s drop one space\n+                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n+                        if (originalElements.get(originalIndex).isWhiteSpace()\n+                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n+                            // However we do not want to do that when we are about to adding or removing elements\n+                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n+                                originalElements.remove(originalIndex--);\n+                            }\n+                        }\n+                    }\n+                }\n+                diffIndex++;\n+            }\n+        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n+                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n+            nodeText.removeElement(originalIndex);\n+            diffIndex++;\n+        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n+            originalIndex++;\n+        } else if (removed.isPrimitiveType()) {\n+            if (isPrimitiveType(originalElement)) {\n+                nodeText.removeElement(originalIndex);\n+                diffIndex++;\n+            } else {\n+                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n+            }\n+        } else if (removed.isWhiteSpace()) {\n+            diffIndex++;\n+        } else if (originalElement.isWhiteSpace()) {\n+            originalIndex++;\n+        } else {\n+            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void applyRemovedDiffElement(Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken) {\n        if (removed.isChild() \u0026\u0026 originalElementIsChild) {\n            ChildTextElement originalElementChild \u003d (ChildTextElement)originalElement;\n            if (originalElementChild.isComment()) {\n                // We expected to remove a proper node but we found a comment in between.\n                // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it\n                Comment comment \u003d (Comment)originalElementChild.getChild();\n                if (!comment.isOrphan() \u0026\u0026 comment.getCommentedNode().isPresent() \u0026\u0026 comment.getCommentedNode().get().equals(removed.getChild())) {\n                    nodeText.removeElement(originalIndex);\n                } else {\n                    originalIndex++;\n                }\n            } else {\n                nodeText.removeElement(originalIndex);\n                if (originalIndex \u003c originalElements.size() \u0026\u0026 originalElements.get(originalIndex).isNewline()) {\n                    originalIndex \u003d considerCleaningTheLine(nodeText, originalIndex);\n                } else {\n                    if (diffIndex + 1 \u003e\u003d diffElements.size() || !(diffElements.get(diffIndex + 1) instanceof Added)) {\n                        originalIndex \u003d considerEnforcingIndentation(nodeText, originalIndex);\n                    }\n                    // If in front we have one space and before also we had space let\u0027s drop one space\n                    if (originalElements.size() \u003e originalIndex \u0026\u0026 originalIndex \u003e 0) {\n                        if (originalElements.get(originalIndex).isWhiteSpace()\n                                \u0026\u0026 originalElements.get(originalIndex - 1).isWhiteSpace()) {\n                            // However we do not want to do that when we are about to adding or removing elements\n                            if ((diffIndex + 1) \u003d\u003d diffElements.size() || (diffElements.get(diffIndex + 1) instanceof Kept)) {\n                                originalElements.remove(originalIndex--);\n                            }\n                        }\n                    }\n                }\n                diffIndex++;\n            }\n        } else if (removed.isToken() \u0026\u0026 originalElementIsToken\n                \u0026\u0026 (removed.getTokenType() \u003d\u003d ((TokenTextElement)originalElement).getTokenKind())) {\n            nodeText.removeElement(originalIndex);\n            diffIndex++;\n        } else if (originalElementIsToken \u0026\u0026 originalElement.isWhiteSpaceOrComment()) {\n            originalIndex++;\n        } else if (removed.isPrimitiveType()) {\n            if (isPrimitiveType(originalElement)) {\n                nodeText.removeElement(originalIndex);\n                diffIndex++;\n            } else {\n                throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n            }\n        } else if (removed.isWhiteSpace()) {\n            diffIndex++;\n        } else if (originalElement.isWhiteSpace()) {\n            originalIndex++;\n        } else {\n            throw new UnsupportedOperationException(\"removed \" + removed.getElement() + \" vs \" + originalElement);\n        }\n    }",
      "path": "javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java",
      "functionStartLine": 267,
      "functionName": "applyRemovedDiffElement"
    }
  }
}