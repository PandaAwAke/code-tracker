{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "H:\\Projects\\spring-projects\\spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "AbstractNestablePropertyAccessor.java",
  "functionName": "setPropertyValue",
  "functionId": "setPropertyValue___tokens-PropertyTokenHolder__pv-PropertyValue",
  "sourceFilePath": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
  "functionStartLine": 273,
  "functionEndLine": 280,
  "numCommitsSeen": 115,
  "timeTaken": 7917,
  "changeHistory": [
    "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89",
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
    "2dc674f356fbe941b98301f89494767f80d55e6a",
    "6fb31903536c0a41dd4fbe153c81494ccfd4d405",
    "3d86f15a847d4567c3b08b21a21500398a394e31",
    "595cdf05e962299c19c34bbfb370316636d074f2",
    "e377fc003d675a61a9643d149b0745314ad02d7d",
    "aa213396b4aa73501d44927d3fe016571bba7555",
    "1708a8a10d17b9c3dc203b90f181c1d55ad5facb",
    "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3",
    "d004b634a5215635d01234ca72ac1a60079f055d",
    "c2b56c07e59aeb123fbe63b282c0ef98d7380f56",
    "59002f245623d758765b72d598cd78c326c6f5fa",
    "94685481162a93666fc2f39b66223833a6bcb418",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "569426dfdfec186e98a6ae4bd8ebf946720206b1",
    "22939b6d05bc226f47e4714f9ebcdc709de3ab16",
    "b8f7d324afe9891f7ba812eae431a7e38b254944",
    "b9fe1b325081f4ec7a5c1e905da00d3ed5223091",
    "c09227a71265578a15bbf516abc523716490d1ac",
    "6f146737f475828b6d765784017773378c2c4922",
    "2fcab44de08bd09159fb7adea2531b16dea3e69b",
    "34fbd5affa10eb73cd82f32f1d6d1718950fc35e",
    "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f",
    "90d8dade254b4f34fd28d498ce529efd2177c606",
    "5d6840e8770b441ae0676b309ba2021704e55a77",
    "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044",
    "1ed03fc6caec159db6fe4a27f085f4effa130a1a",
    "c6c782df59c09a6a36c8283cbd725e9aef20e0e8",
    "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8",
    "01c98c3bfb6fc3f970dc66055b8435a47a876e31",
    "cc91efecaee777604828669b1b14ff9ee6468dfe",
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
    "66abad25400aab7e6211f75449ec6bde08cae659",
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
    "1c33206042c09a4344e5e4a1c6b759eb6180274c",
    "61f23710ebed6d7feb1e7b477d301d952d3cde5f",
    "ac490114aee005a66eeb0fba6c3c853552fc6a94",
    "ad492e906e4c9c994cad733d366ec9c30950ed92",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
    "af8af8c633ba016eca671bc9468eba006e8834b1",
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
    "eca1cad7e1e78714d22681554474f887d9046632",
    "bf7a947559d8f9918cc738780bf04caf8ea46962",
    "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
    "b0790bf5e7b6091552ccf17a2e707ab438d129d7",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3"
  ],
  "changeHistoryShort": {
    "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89": "Ybodychange",
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a": "Ybodychange",
    "2dc674f356fbe941b98301f89494767f80d55e6a": "Ymovefromfile",
    "6fb31903536c0a41dd4fbe153c81494ccfd4d405": "Ybodychange",
    "3d86f15a847d4567c3b08b21a21500398a394e31": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "595cdf05e962299c19c34bbfb370316636d074f2": "Ybodychange",
    "e377fc003d675a61a9643d149b0745314ad02d7d": "Ybodychange",
    "aa213396b4aa73501d44927d3fe016571bba7555": "Ybodychange",
    "1708a8a10d17b9c3dc203b90f181c1d55ad5facb": "Ybodychange",
    "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3": "Ybodychange",
    "d004b634a5215635d01234ca72ac1a60079f055d": "Ybodychange",
    "c2b56c07e59aeb123fbe63b282c0ef98d7380f56": "Ybodychange",
    "59002f245623d758765b72d598cd78c326c6f5fa": "Ybodychange",
    "94685481162a93666fc2f39b66223833a6bcb418": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "569426dfdfec186e98a6ae4bd8ebf946720206b1": "Ybodychange",
    "22939b6d05bc226f47e4714f9ebcdc709de3ab16": "Ybodychange",
    "b8f7d324afe9891f7ba812eae431a7e38b254944": "Ybodychange",
    "b9fe1b325081f4ec7a5c1e905da00d3ed5223091": "Ybodychange",
    "c09227a71265578a15bbf516abc523716490d1ac": "Ybodychange",
    "6f146737f475828b6d765784017773378c2c4922": "Ybodychange",
    "2fcab44de08bd09159fb7adea2531b16dea3e69b": "Ybodychange",
    "34fbd5affa10eb73cd82f32f1d6d1718950fc35e": "Ybodychange",
    "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f": "Ybodychange",
    "90d8dade254b4f34fd28d498ce529efd2177c606": "Ybodychange",
    "5d6840e8770b441ae0676b309ba2021704e55a77": "Ybodychange",
    "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044": "Ybodychange",
    "1ed03fc6caec159db6fe4a27f085f4effa130a1a": "Ybodychange",
    "c6c782df59c09a6a36c8283cbd725e9aef20e0e8": "Ybodychange",
    "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8": "Ybodychange",
    "01c98c3bfb6fc3f970dc66055b8435a47a876e31": "Ybodychange",
    "cc91efecaee777604828669b1b14ff9ee6468dfe": "Ybodychange",
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": "Ybodychange",
    "66abad25400aab7e6211f75449ec6bde08cae659": "Ybodychange",
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": "Ybodychange",
    "1c33206042c09a4344e5e4a1c6b759eb6180274c": "Ybodychange",
    "61f23710ebed6d7feb1e7b477d301d952d3cde5f": "Ybodychange",
    "ac490114aee005a66eeb0fba6c3c853552fc6a94": "Ybodychange",
    "ad492e906e4c9c994cad733d366ec9c30950ed92": "Ybodychange",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": "Ybodychange",
    "af8af8c633ba016eca671bc9468eba006e8834b1": "Ybodychange",
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209": "Ybodychange",
    "eca1cad7e1e78714d22681554474f887d9046632": "Ybodychange",
    "bf7a947559d8f9918cc738780bf04caf8ea46962": "Ybodychange",
    "9dd70ca9fe3775f7459e66695d6e21e112ff9611": "Ybodychange",
    "b0790bf5e7b6091552ccf17a2e707ab438d129d7": "Ybodychange",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": "Ybodychange",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89": {
      "type": "Ybodychange",
      "commitMessage": "AbstractNestablePropertyAccessor\u0027s setPropertyValue refactored into several delegate methods\n\nIssue: SPR-15053\n",
      "commitDate": "2016-12-26, 1:47 p.m.",
      "commitName": "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-09-13, 3:55 p.m.",
      "commitNameOld": "c69e6a36f7322d52d2989ea9136c7aff33f199c9",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 103.95,
      "commitsBetweenForRepo": 562,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tif (tokens.keys !\u003d null) {\n\t\t\tprocessKeyedProperty(tokens, pv);\n\t\t}\n\t\telse {\n\t\t\tprocessLocalProperty(tokens, pv);\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
      "functionStartLine": 269,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,193 +1,8 @@\n \tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n-\t\tString propertyName \u003d tokens.canonicalName;\n-\t\tString actualName \u003d tokens.actualName;\n-\n \t\tif (tokens.keys !\u003d null) {\n-\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n-\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n-\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n-\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n-\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n-\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n-\t\t\tObject propValue;\n-\t\t\ttry {\n-\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n-\t\t\t}\n-\t\t\tcatch (NotReadablePropertyException ex) {\n-\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n-\t\t\t}\n-\t\t\t// Set value for last key.\n-\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n-\t\t\tif (propValue \u003d\u003d null) {\n-\t\t\t\t// null map value case\n-\t\t\t\tif (isAutoGrowNestedPaths()) {\n-\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n-\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n-\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n-\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (propValue.getClass().isArray()) {\n-\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n-\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n-\t\t\t\tObject oldValue \u003d null;\n-\t\t\t\ttry {\n-\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n-\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n-\t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n-\t\t\t\t\tint length \u003d Array.getLength(propValue);\n-\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n-\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n-\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n-\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n-\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n-\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n-\t\t\t\t\t}\n-\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n-\t\t\t\t}\n-\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n-\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (propValue instanceof List) {\n-\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n-\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n-\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n-\t\t\t\tint index \u003d Integer.parseInt(key);\n-\t\t\t\tObject oldValue \u003d null;\n-\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n-\t\t\t\t\toldValue \u003d list.get(index);\n-\t\t\t\t}\n-\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n-\t\t\t\tint size \u003d list.size();\n-\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n-\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tlist.add(null);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcatch (NullPointerException ex) {\n-\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tlist.add(convertedValue);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tlist.set(index, convertedValue);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n-\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if (propValue instanceof Map) {\n-\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n-\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n-\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n-\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n-\t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n-\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n-\t\t\t\tObject oldValue \u003d null;\n-\t\t\t\tif (isExtractOldValueForEditor()) {\n-\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n-\t\t\t\t}\n-\t\t\t\t// Pass full property name and old value in here, since we want full\n-\t\t\t\t// conversion ability for map values.\n-\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n-\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n-\t\t\t}\n+\t\t\tprocessKeyedProperty(tokens, pv);\n \t\t}\n-\n \t\telse {\n-\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n-\t\t\t\tif (pv.isOptional()) {\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n-\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-\t\t\t\t\t}\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tObject oldValue \u003d null;\n-\t\t\ttry {\n-\t\t\t\tObject originalValue \u003d pv.getValue();\n-\t\t\t\tObject valueToApply \u003d originalValue;\n-\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n-\t\t\t\t\tif (pv.isConverted()) {\n-\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n-\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n-\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n-\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n-\t\t\t\t\t}\n-\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n-\t\t\t\t}\n-\t\t\t\tph.setValue(this.wrappedObject, valueToApply);\n-\t\t\t}\n-\t\t\tcatch (TypeMismatchException ex) {\n-\t\t\t\tthrow ex;\n-\t\t\t}\n-\t\t\tcatch (InvocationTargetException ex) {\n-\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n-\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n-\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n-\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n-\t\t\t\t\t\tcause \u003d cause.getCause();\n-\t\t\t\t\t}\n-\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (Exception ex) {\n-\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new MethodInvocationException(pce, ex);\n-\t\t\t}\n+\t\t\tprocessLocalProperty(tokens, pv);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a": {
      "type": "Ybodychange",
      "commitMessage": "BeanFactory does not unwrap java.util.Optional for top-level bean\n\nIssue: SPR-14121\n",
      "commitDate": "2016-04-07, 8:18 a.m.",
      "commitName": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-12-09, 6:28 a.m.",
      "commitNameOld": "11806b921541ba225008937d9054d08ab06524ae",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 120.03,
      "commitsBetweenForRepo": 538,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tph.setValue(this.wrappedObject, valueToApply);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n\t\t\t\t\t\tcause \u003d cause.getCause();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
      "functionStartLine": 288,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,193 +1,193 @@\n \tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n+\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length \u003d Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n+\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n \t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n \t\t\t\t}\n \t\t\t}\n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n-\t\t\t\tph.setValue(object, valueToApply);\n+\t\t\t\tph.setValue(this.wrappedObject, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause \u003d cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dc674f356fbe941b98301f89494767f80d55e6a": {
      "type": "Ymovefromfile",
      "commitMessage": "Restore AbstractPropertyAccessor\n\nCommit 3d86f15 added a lot of new feature in AbstractPropertyAccessor\nshared by both DirectFieldAccessor and BeanWrapperImpl. This makes this\nabstract class harder to implement for others having simpler use cases.\n\nIt turns that Spring Data has such use case; this commit split these new\nfeatures in a dedicated new base class, leaving AbstractPropertyAccessor\nuntouched.\n\nIssue: SPR-12805\n",
      "commitDate": "2015-05-22, 4:33 a.m.",
      "commitName": "2dc674f356fbe941b98301f89494767f80d55e6a",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2015-05-22, 4:28 a.m.",
      "commitNameOld": "27c435c4eae6502ba068a5da8c19d626c28316c3",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tph.setValue(object, valueToApply);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n\t\t\t\t\t\tcause \u003d cause.getCause();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
      "functionStartLine": 286,
      "functionName": "setPropertyValue",
      "diff": "",
      "extendedDetails": {
        "oldPath": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
        "newPath": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
        "oldMethodName": "setPropertyValue",
        "newMethodName": "setPropertyValue"
      }
    },
    "6fb31903536c0a41dd4fbe153c81494ccfd4d405": {
      "type": "Ybodychange",
      "commitMessage": "Fix regression with binding and validation\n\nPreviously, the binding may have to call the getter first to retrieve the\nold value of a property before actually setting it. This was guarded by\na catch block that was accidentally removed in 3d86f15\n\nRestore that catch block and add a test to cover it.\n\nIssue: SPR-12805\n",
      "commitDate": "2015-05-21, 11:48 a.m.",
      "commitName": "6fb31903536c0a41dd4fbe153c81494ccfd4d405",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2015-05-21, 7:49 a.m.",
      "commitNameOld": "3d86f15a847d4567c3b08b21a21500398a394e31",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tph.setValue(object, valueToApply);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n\t\t\t\t\t\tcause \u003d cause.getCause();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
      "functionStartLine": 379,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,182 +1,193 @@\n \tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length \u003d Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n \t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n \t\t\t\t}\n \t\t\t}\n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n-\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n+\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n+\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tph.setValue(object, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause \u003d cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d86f15a847d4567c3b08b21a21500398a394e31": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
      "commitDate": "2015-05-21, 7:49 a.m.",
      "commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
      "commitAuthor": "Stephane Nicoll",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
          "commitDate": "2015-05-21, 7:49 a.m.",
          "commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
          "commitAuthor": "Stephane Nicoll",
          "commitDateOld": "2015-05-20, 5:06 p.m.",
          "commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tph.setValue(object, valueToApply);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n\t\t\t\t\t\tcause \u003d cause.getCause();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
          "path": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
          "functionStartLine": 378,
          "functionName": "setPropertyValue",
          "diff": "@@ -1,262 +1,182 @@\n-\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n+\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length \u003d Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n+\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n+\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n+\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n-\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n-\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n-\t\t\t\t\tif (pv.isOptional()) {\n+\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n+\t\t\t\tif (pv.isOptional()) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-\t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n-\t\t\t\t\t\tthrow new NotWritablePropertyException(\n-\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n-\t\t\t\t\t}\n+\t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n+\t\t\t\telse {\n+\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n+\t\t\t\t}\n \t\t\t}\n-\n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n-\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n-\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n-\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n-\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t});\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n-\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n-\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n-\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n+\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n-\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n-\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n-\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n-\t\t\t\t\t\tpd.getWriteMethod());\n-\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n-\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tfinal Object value \u003d valueToApply;\n-\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (PrivilegedActionException ex) {\n-\t\t\t\t\t\tthrow ex.getException();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\twriteMethod.invoke(this.object, value);\n-\t\t\t\t}\n+\t\t\t\tph.setValue(object, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n-\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause \u003d cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
            "newPath": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
            "oldMethodName": "setPropertyValue",
            "newMethodName": "setPropertyValue"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
          "commitDate": "2015-05-21, 7:49 a.m.",
          "commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
          "commitAuthor": "Stephane Nicoll",
          "commitDateOld": "2015-05-20, 5:06 p.m.",
          "commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tph.setValue(object, valueToApply);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n\t\t\t\t\t\tcause \u003d cause.getCause();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
          "path": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
          "functionStartLine": 378,
          "functionName": "setPropertyValue",
          "diff": "@@ -1,262 +1,182 @@\n-\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n+\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length \u003d Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n+\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n+\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n+\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n-\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n-\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n-\t\t\t\t\tif (pv.isOptional()) {\n+\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n+\t\t\t\tif (pv.isOptional()) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-\t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n-\t\t\t\t\t\tthrow new NotWritablePropertyException(\n-\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n-\t\t\t\t\t}\n+\t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n+\t\t\t\telse {\n+\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n+\t\t\t\t}\n \t\t\t}\n-\n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n-\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n-\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n-\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n-\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t});\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n-\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n-\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n-\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n+\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n-\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n-\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n-\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n-\t\t\t\t\t\tpd.getWriteMethod());\n-\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n-\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tfinal Object value \u003d valueToApply;\n-\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (PrivilegedActionException ex) {\n-\t\t\t\t\t\tthrow ex.getException();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\twriteMethod.invoke(this.object, value);\n-\t\t\t\t}\n+\t\t\t\tph.setValue(object, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n-\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause \u003d cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
          "commitDate": "2015-05-21, 7:49 a.m.",
          "commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
          "commitAuthor": "Stephane Nicoll",
          "commitDateOld": "2015-05-20, 5:06 p.m.",
          "commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tph.setValue(object, valueToApply);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n\t\t\t\t\t\tcause \u003d cause.getCause();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
          "path": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
          "functionStartLine": 378,
          "functionName": "setPropertyValue",
          "diff": "@@ -1,262 +1,182 @@\n-\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+\tprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n+\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+\t\t\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\t\tint length \u003d Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph \u003d getPropertyHandler(actualName);\n+\t\t\t\tClass\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\trequiredType, ph.nested(tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n-\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n-\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+\t\t\t\tClass\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n+\t\t\t\tClass\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n-\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\t\tmapValueType, ph.nested(tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n+\t\t\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n-\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n-\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n-\t\t\t\t\tif (pv.isOptional()) {\n+\t\t\tPropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+\t\t\tif (ph \u003d\u003d null || !ph.isWritable()) {\n+\t\t\t\tif (pv.isOptional()) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-\t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n-\t\t\t\t\t\tthrow new NotWritablePropertyException(\n-\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n-\t\t\t\t\t}\n+\t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n+\t\t\t\telse {\n+\t\t\t\t\tthrow createNotWritablePropertyException(propertyName);\n+\t\t\t\t}\n \t\t\t}\n-\n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n-\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n-\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n-\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n-\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t});\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n-\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (Exception ex) {\n-\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n-\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n-\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n+\t\t\t\t\t\t\toldValue \u003d ph.getValue();\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n-\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, ph.toTypeDescriptor());\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n-\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n-\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n-\t\t\t\t\t\tpd.getWriteMethod());\n-\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n-\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() {\n-\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\twriteMethod.setAccessible(true);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tfinal Object value \u003d valueToApply;\n-\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic Object run() throws Exception {\n-\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n-\t\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}, acc);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (PrivilegedActionException ex) {\n-\t\t\t\t\t\tthrow ex.getException();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\twriteMethod.invoke(this.object, value);\n-\t\t\t\t}\n+\t\t\t\tph.setValue(object, valueToApply);\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n-\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n \t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n \t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n \t\t\t\t\t\tcause \u003d cause.getCause();\n \t\t\t\t\t}\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "595cdf05e962299c19c34bbfb370316636d074f2": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2015-04-03, 6:23 p.m.",
      "commitName": "595cdf05e962299c19c34bbfb370316636d074f2",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-03-31, 4:03 a.m.",
      "commitNameOld": "e377fc003d675a61a9643d149b0745314ad02d7d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.6,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n\t\t\t\t\t\tcause \u003d cause.getCause();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 936,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,257 +1,262 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tint length \u003d Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n+\t\t\t\t\tThrowable cause \u003d ex.getTargetException();\n+\t\t\t\t\tif (cause instanceof UndeclaredThrowableException) {\n+\t\t\t\t\t\t// May happen e.g. with Groovy-generated methods\n+\t\t\t\t\t\tcause \u003d cause.getCause();\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, cause);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e377fc003d675a61a9643d149b0745314ad02d7d": {
      "type": "Ybodychange",
      "commitMessage": "BeanWrapperImpl.setPropertyValue throws InvalidPropertyException with correct property value for nested collection case\n\nIssue: SPR-12866\n",
      "commitDate": "2015-03-31, 4:03 a.m.",
      "commitName": "e377fc003d675a61a9643d149b0745314ad02d7d",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-02-11, 5:29 a.m.",
      "commitNameOld": "aa213396b4aa73501d44927d3fe016571bba7555",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 47.9,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 935,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,257 +1,257 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tint length \u003d Array.getLength(propValue);\n \t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n \t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n \t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n \t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n \t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n \t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n+\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aa213396b4aa73501d44927d3fe016571bba7555": {
      "type": "Ybodychange",
      "commitMessage": "BeanWrapper auto-grows arrays if necessary\n\nPreviously, only indexed access for collections were supported. When\nattempting to access the element of an array that had not the requested\nsize, the call would fail with an IndexOutOfBoundException\n\nThis commit harmonize the binding support so that the array is updated\naccording to the requested index if necessary.\n\nIssue: SPR-12706\n",
      "commitDate": "2015-02-11, 5:29 a.m.",
      "commitName": "aa213396b4aa73501d44927d3fe016571bba7555",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2014-11-29, 2:49 p.m.",
      "commitNameOld": "bfbd25a0e94ab789171d331a121812468cbeb154",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 73.61,
      "commitsBetweenForRepo": 203,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tint length \u003d Array.getLength(propValue);\n\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n\t\t\t\t\t}\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 935,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,249 +1,257 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\tint length \u003d Array.getLength(propValue);\n+\t\t\t\t\tif (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n+\t\t\t\t\t\tClass\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n+\t\t\t\t\t\tObject newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n+\t\t\t\t\t\tSystem.arraycopy(propValue, 0, newArray, 0, length);\n+\t\t\t\t\t\tsetPropertyValue(actualName, newArray);\n+\t\t\t\t\t\tpropValue \u003d getPropertyValue(actualName);\n+\t\t\t\t\t}\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1708a8a10d17b9c3dc203b90f181c1d55ad5facb": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary null check\n\nIssue: SPR-12378\n",
      "commitDate": "2014-10-27, 4:32 a.m.",
      "commitName": "1708a8a10d17b9c3dc203b90f181c1d55ad5facb",
      "commitAuthor": "Seo, Kyung-Seok",
      "commitDateOld": "2014-09-25, 11:00 a.m.",
      "commitNameOld": "cfc821d1799ca7c64b1bbc53811b712fdaa4776c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 31.73,
      "commitsBetweenForRepo": 168,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 930,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,250 +1,249 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n-\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n+\t\t\t\tTypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3": {
      "type": "Ybodychange",
      "commitMessage": "Support for nested path using field access\n\nThis commit adds a nested path support for DirectFieldAccessor that is\nsimilar to what BeanWrapper provides. It is now possible to use\nexpressions such as \"person.address.city.name\" to access the name of\nthe city that a given person lives in using fields to traverse the\ngraph.\n\nDirectFieldAccessor also now supports an auto-grow option to create\na default instance for a \"null\" intermediate path. This option is\nfalse by default and leads to a NullValueInNestedPathException in such\na case.\n\nThis commit also harmonizes part of the tests suite so that core tests\nare shared between BeanWrapperImpl and DirectFieldAccessor.\n\nNote that map and list access is not implemented as part of this\ncommit.\n\nIssue: SPR-9705\n",
      "commitDate": "2014-06-26, 1:22 p.m.",
      "commitName": "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2014-01-27, 7:25 p.m.",
      "commitNameOld": "fcbd3b121ba0d6fa8378fd0f0773ef2a652f1426",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 149.71,
      "commitsBetweenForRepo": 764,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (isAutoGrowNestedPaths()) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 910,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,250 +1,250 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n-\t\t\t\tif (this.autoGrowNestedPaths) {\n+\t\t\t\tif (isAutoGrowNestedPaths()) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n \t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d004b634a5215635d01234ca72ac1a60079f055d": {
      "type": "Ybodychange",
      "commitMessage": "Fixed type resolution in case of inconsistencies between read and write method\n\nIssue: SPR-11361\n",
      "commitDate": "2014-01-27, 6:46 p.m.",
      "commitName": "d004b634a5215635d01234ca72ac1a60079f055d",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-01-24, 10:22 a.m.",
      "commitNameOld": "8543b91c508d0eaf86212d148e63041eb38eeb3b",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.35,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 929,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,249 +1,250 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd, new TypeDescriptor(property(pd)));\n+\t\t\t\t\t\tvalueToApply \u003d convertForProperty(\n+\t\t\t\t\t\t\t\tpropertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c2b56c07e59aeb123fbe63b282c0ef98d7380f56": {
      "type": "Ybodychange",
      "commitMessage": "Cache property TypeDescriptors\n\nAttempt to improve performance by caching TypeDescriptors against bean\nPropertyDescriptors in CachedIntrospectionResults.\n\nThis change is an attempt to fix the failing performance test case\n`testPrototypeCreationWithOverriddenResourcePropertiesIsFastEnough` in\n`AnnotationProcessorPerformanceTests`.\n",
      "commitDate": "2013-12-03, 12:55 a.m.",
      "commitName": "c2b56c07e59aeb123fbe63b282c0ef98d7380f56",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-11-25, 3:52 p.m.",
      "commitNameOld": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 7.38,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd, new TypeDescriptor(property(pd)));\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 926,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,249 +1,249 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n+\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd, new TypeDescriptor(property(pd)));\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59002f245623d758765b72d598cd78c326c6f5fa": {
      "type": "Ybodychange",
      "commitMessage": "Fix remaining compiler warnings\n\nFix remaining Java compiler warnings, mainly around missing\ngenerics or deprecated code.\n\nAlso add the `-Werror` compiler option to ensure that any future\nwarnings will fail the build.\n\nIssue: SPR-11064\n",
      "commitDate": "2013-11-25, 3:52 p.m.",
      "commitName": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-05-13, 6:04 p.m.",
      "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthorOld": "Rob Winch",
      "daysBetweenCommits": 195.95,
      "commitsBetweenForRepo": 742,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 921,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,249 +1,249 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n+\t\t\t\tClass\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n+\t\t\t\tClass\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tList list \u003d (List) propValue;\n+\t\t\t\tList\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n+\t\t\t\tClass\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n+\t\t\t\tClass\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\tMap map \u003d (Map) propValue;\n+\t\t\t\tMap\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "94685481162a93666fc2f39b66223833a6bcb418": {
      "type": "Ybodychange",
      "commitMessage": "Add @Override to remaining source files\n\nIssue: SPR-10130\n",
      "commitDate": "2013-05-13, 6:04 p.m.",
      "commitName": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthor": "Rob Winch",
      "commitDateOld": "2013-02-04, 1:35 p.m.",
      "commitNameOld": "f464a45ba481ff3e960ad3dd8b5edd4464a46289",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 98.15,
      "commitsBetweenForRepo": 366,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 923,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,245 +1,249 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n \t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n \t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n+\t\t\t\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n+\t\t\t\t\t\t\t@Override\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012-01-31, 8:37 a.m.",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012-01-31, 8:37 a.m.",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 932,
      "functionName": "setPropertyValue",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
        "newPath": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java"
      }
    },
    "569426dfdfec186e98a6ae4bd8ebf946720206b1": {
      "type": "Ybodychange",
      "commitMessage": "restored DataBinder\u0027s ability to bind to an auto-growing List with unknown element type (SPR-8828)\n",
      "commitDate": "2011-12-07, 4:27 p.m.",
      "commitName": "569426dfdfec186e98a6ae4bd8ebf946720206b1",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011-07-03, 4:24 p.m.",
      "commitNameOld": "22939b6d05bc226f47e4714f9ebcdc709de3ab16",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 157.04,
      "commitsBetweenForRepo": 543,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 932,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,242 +1,245 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n+\t\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n-\t\t\t\tint size \u003d list.size();\n \t\t\t\tObject oldValue \u003d null;\n-\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n+\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n-\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n+\t\t\t\t\t\trequiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\tint size \u003d list.size();\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n+\t\t\t\tTypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ?\n+\t\t\t\t\t\tTypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n-\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n-\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(),\n+\t\t\t\t\t\tmapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22939b6d05bc226f47e4714f9ebcdc709de3ab16": {
      "type": "Ybodychange",
      "commitMessage": "properly wrap IndexOutOfBoundsException even for List\n",
      "commitDate": "2011-07-03, 4:24 p.m.",
      "commitName": "22939b6d05bc226f47e4714f9ebcdc709de3ab16",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011-07-03, 4:12 p.m.",
      "commitNameOld": "b8f7d324afe9891f7ba812eae431a7e38b254944",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 928,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,236 +1,242 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tlist.set(index, convertedValue);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tlist.set(index, convertedValue);\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n+\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\t\"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b8f7d324afe9891f7ba812eae431a7e38b254944": {
      "type": "Ybodychange",
      "commitMessage": "regular IndexOutOfBoundsException if index beyond auto-grow limit\n",
      "commitDate": "2011-07-03, 4:12 p.m.",
      "commitName": "b8f7d324afe9891f7ba812eae431a7e38b254944",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011-07-03, 4:05 p.m.",
      "commitNameOld": "b9fe1b325081f4ec7a5c1e905da00d3ed5223091",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 928,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,236 +1,236 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tint size \u003d list.size();\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-\t\t\t\tif (index \u003c size) {\n-\t\t\t\t\tlist.set(index, convertedValue);\n-\t\t\t\t}\n-\t\t\t\telse if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n+\t\t\t\tif (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n \t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tlist.set(index, convertedValue);\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b9fe1b325081f4ec7a5c1e905da00d3ed5223091": {
      "type": "Ybodychange",
      "commitMessage": "restored original array behavior (no default growth of arrays)\n",
      "commitDate": "2011-07-03, 4:05 p.m.",
      "commitName": "b9fe1b325081f4ec7a5c1e905da00d3ed5223091",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011-07-03, 3:26 p.m.",
      "commitNameOld": "4c75054f9041279423f31754aa23f9ca781e9d43",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tint size \u003d list.size();\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tif (index \u003c size) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 928,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,237 +1,236 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-\t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n-\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n+\t\t\t\tint size \u003d list.size();\n \t\t\t\tObject oldValue \u003d null;\n-\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n+\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-\t\t\t\tif (index \u003c list.size()) {\n+\t\t\t\tif (index \u003c size) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n-\t\t\t\telse if (index \u003e\u003d list.size()) {\n-\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n+\t\t\t\telse if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n+\t\t\t\t\tfor (int i \u003d size; i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n+\t\t\t\t\t\t\t\t\tsize + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c09227a71265578a15bbf516abc523716490d1ac": {
      "type": "Ybodychange",
      "commitMessage": "removed dependency on java.beans\n",
      "commitDate": "2011-06-05, 4:29 a.m.",
      "commitName": "c09227a71265578a15bbf516abc523716490d1ac",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-06-02, 7:37 p.m.",
      "commitNameOld": "6f146737f475828b6d765784017773378c2c4922",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 2.37,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 907,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,237 +1,237 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n-\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n-\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f146737f475828b6d765784017773378c2c4922": {
      "type": "Ybodychange",
      "commitMessage": "simplified TypeDescriptor usage and updated use of the API across BeanWrapper and SpEL; collapsed PropertyTypeDescriptor into TypeDescriptor for simplicity and ease of use; improved docs\n",
      "commitDate": "2011-06-02, 7:37 p.m.",
      "commitName": "6f146737f475828b6d765784017773378c2c4922",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-07, 4:25 p.m.",
      "commitNameOld": "2fcab44de08bd09159fb7adea2531b16dea3e69b",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 146.09,
      "commitsBetweenForRepo": 388,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n\t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 906,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,240 +1,237 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n \t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n-\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n-\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2fcab44de08bd09159fb7adea2531b16dea3e69b": {
      "type": "Ybodychange",
      "commitMessage": "remove addressed TODO\n",
      "commitDate": "2011-01-07, 4:25 p.m.",
      "commitName": "2fcab44de08bd09159fb7adea2531b16dea3e69b",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-07, 4:13 p.m.",
      "commitNameOld": "34fbd5affa10eb73cd82f32f1d6d1718950fc35e",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 917,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,241 +1,240 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n-\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34fbd5affa10eb73cd82f32f1d6d1718950fc35e": {
      "type": "Ybodychange",
      "commitMessage": "typo\n",
      "commitDate": "2011-01-07, 4:13 p.m.",
      "commitName": "34fbd5affa10eb73cd82f32f1d6d1718950fc35e",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-07, 2:22 p.m.",
      "commitNameOld": "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 917,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,241 +1,241 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\t// null map value case\n \t\t\t\tif (this.autoGrowNestedPaths) {\n \t\t\t\t\t// TODO: cleanup, this is pretty hacky\n \t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n \t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n \t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n-\t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n+\t\t\t\t\t// TODO review this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f": {
      "type": "Ybodychange",
      "commitMessage": "sp7839 - map autogrow, including auto-grow support for map values\n",
      "commitDate": "2011-01-07, 2:22 p.m.",
      "commitName": "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-07, 12:54 p.m.",
      "commitNameOld": "90d8dade254b4f34fd28d498ce529efd2177c606",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\t// null map value case\n\t\t\t\tif (this.autoGrowNestedPaths) {\n\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 917,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,232 +1,241 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n-\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n-\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+\t\t\t\t// null map value case\n+\t\t\t\tif (this.autoGrowNestedPaths) {\n+\t\t\t\t\t// TODO: cleanup, this is pretty hacky\n+\t\t\t\t\tint lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n+\t\t\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n+\t\t\t\t\tpropValue \u003d setDefaultValue(getterTokens);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n+\t\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+\t\t\t\t}\n \t\t\t}\n-\t\t\telse if (propValue.getClass().isArray()) {\n+\t\t\tif (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "90d8dade254b4f34fd28d498ce529efd2177c606": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug related to array autogrow\n",
      "commitDate": "2011-01-07, 12:54 p.m.",
      "commitName": "90d8dade254b4f34fd28d498ce529efd2177c606",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-07, 12:28 p.m.",
      "commitNameOld": "5d6840e8770b441ae0676b309ba2021704e55a77",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 916,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,236 +1,232 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n \t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n-\t\t\t\t\tPropertyValue newValue \u003d new PropertyValue(actualName, propValue);\n-\t\t\t\t\tnewValue.resolvedDescriptor \u003d pd;\n-\t\t\t\t\tnewValue.conversionNecessary \u003d false;\n-\t\t\t\t\tsetPropertyValue(newValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d6840e8770b441ae0676b309ba2021704e55a77": {
      "type": "Ybodychange",
      "commitMessage": "array autogrow on set e.g. array[0]\u003dfoo\n",
      "commitDate": "2011-01-07, 12:28 p.m.",
      "commitName": "5d6840e8770b441ae0676b309ba2021704e55a77",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-07, 11:18 a.m.",
      "commitNameOld": "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t\tPropertyValue newValue \u003d new PropertyValue(actualName, propValue);\n\t\t\t\t\tnewValue.resolvedDescriptor \u003d pd;\n\t\t\t\t\tnewValue.conversionNecessary \u003d false;\n\t\t\t\t\tsetPropertyValue(newValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 915,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,230 +1,236 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n-\t\t\t\t\tif (isExtractOldValueForEditor()) {\n+\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+\t\t\t\t\t// TODO reduce this grow algorithm along side the null gap algorithm for setting lists below ... the two are inconsistent\n+\t\t\t\t\tpropValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n+\t\t\t\t\tPropertyValue newValue \u003d new PropertyValue(actualName, propValue);\n+\t\t\t\t\tnewValue.resolvedDescriptor \u003d pd;\n+\t\t\t\t\tnewValue.conversionNecessary \u003d false;\n+\t\t\t\t\tsetPropertyValue(newValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044": {
      "type": "Ybodychange",
      "commitMessage": "removed accidental system.out commit\n",
      "commitDate": "2011-01-07, 11:18 a.m.",
      "commitName": "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-07, 11:16 a.m.",
      "commitNameOld": "1ed03fc6caec159db6fe4a27f085f4effa130a1a",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 916,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,231 +1,230 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n-\t\t\t\t\tSystem.out.println(list);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ed03fc6caec159db6fe4a27f085f4effa130a1a": {
      "type": "Ybodychange",
      "commitMessage": "fetch property value again after setting default value to protect against object copy\n",
      "commitDate": "2011-01-07, 11:16 a.m.",
      "commitName": "1ed03fc6caec159db6fe4a27f085f4effa130a1a",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-06, 9:51 p.m.",
      "commitNameOld": "42403a37c3fcf159bdc574a7200396825d55fecf",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\tSystem.out.println(list);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 916,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,230 +1,231 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n+\t\t\t\t\tSystem.out.println(list);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6c782df59c09a6a36c8283cbd725e9aef20e0e8": {
      "type": "Ybodychange",
      "commitMessage": "forNestedType usage clarification\n",
      "commitDate": "2011-01-06, 1:33 p.m.",
      "commitName": "c6c782df59c09a6a36c8283cbd725e9aef20e0e8",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-06, 7:00 a.m.",
      "commitNameOld": "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 901,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,231 +1,230 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n-\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8": {
      "type": "Ybodychange",
      "commitMessage": "temp added ignore on 2 new failing tests until time to investigate\n",
      "commitDate": "2011-01-06, 7:00 a.m.",
      "commitName": "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-06, 12:14 a.m.",
      "commitNameOld": "01c98c3bfb6fc3f970dc66055b8435a47a876e31",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 901,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,229 +1,231 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n+\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n+\t\t\t\t// TODO method parameter nesting level should be token.keys.length + 1\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01c98c3bfb6fc3f970dc66055b8435a47a876e31": {
      "type": "Ybodychange",
      "commitMessage": "added initial support for handling unknown nested type values when converting collections; now favor factory method for constructing nested type descriptors for clarity (made constructor private); improved javadoc\n",
      "commitDate": "2011-01-06, 12:14 a.m.",
      "commitName": "01c98c3bfb6fc3f970dc66055b8435a47a876e31",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-05, 2:18 p.m.",
      "commitNameOld": "cc91efecaee777604828669b1b14ff9ee6468dfe",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.41,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 901,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,235 +1,229 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n-\t\t\t\t\tmethodParameter.increaseNestingLevel();\t\t\t\t\t\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n+\t\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n-\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n-\t\t\t\tmethodParameter.increaseNestingLevel();\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n+\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n-\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n-\t\t\t\tmethodParameter.increaseNestingLevel();\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(mapValueType, methodParameter, pd));\n+\t\t\t\t\t\tPropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc91efecaee777604828669b1b14ff9ee6468dfe": {
      "type": "Ybodychange",
      "commitMessage": "Fixed bugs in bean wrapper related to nesting levels on method parameters\n",
      "commitDate": "2011-01-05, 2:18 p.m.",
      "commitName": "cc91efecaee777604828669b1b14ff9ee6468dfe",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011-01-05, 12:49 a.m.",
      "commitNameOld": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n\t\t\t\t\tmethodParameter.increaseNestingLevel();\t\t\t\t\t\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n\t\t\t\tmethodParameter.increaseNestingLevel();\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n\t\t\t\tmethodParameter.increaseNestingLevel();\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tnew PropertyTypeDescriptor(mapValueType, methodParameter, pd));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 902,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,229 +1,235 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n+\t\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n+\t\t\t\t\tmethodParameter.increaseNestingLevel();\t\t\t\t\t\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n+\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n+\t\t\t\tmethodParameter.increaseNestingLevel();\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, methodParameter, pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(mapKeyType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+\t\t\t\tTypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n+\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n+\t\t\t\tMethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n+\t\t\t\tmethodParameter.increaseNestingLevel();\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(mapValueType, methodParameter, pd));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": {
      "type": "Ybodychange",
      "commitMessage": "TypeDescriptor cleanup and general polishing; fixed a number of bugs related to TypeDescriptor usage in client code across beans and spel packages\n",
      "commitDate": "2011-01-05, 12:49 a.m.",
      "commitName": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2010-10-13, 8:14 p.m.",
      "commitNameOld": "0195b0da3c28b3a48b8f1fc8b0b5a354f1a56265",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 83.23,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType,\n\t\t\t\t\t\tnew PropertyTypeDescriptor(mapKeyType, new MethodParameter(pd.getReadMethod(), -1), pd));\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 902,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,229 +1,229 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n+\t\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType,\n-\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(mapKeyType, new MethodParameter(pd.getReadMethod(), -1), pd));\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "66abad25400aab7e6211f75449ec6bde08cae659": {
      "type": "Ybodychange",
      "commitMessage": "BeanWrapper preserves annotation information for individual array/list/map elements (SPR-7348)\n",
      "commitDate": "2010-07-12, 4:56 p.m.",
      "commitName": "66abad25400aab7e6211f75449ec6bde08cae659",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-06-23, 1:27 p.m.",
      "commitNameOld": "7f91153bba5a76099889f83d411adc6a40e8276e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 19.14,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType,\n\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 922,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,225 +1,229 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n+\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n+\t\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n \t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n-\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n \t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n \t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType);\n+\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType,\n+\t\t\t\t\t\tnew PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t// conversion ability for map values.\n \t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n \t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n \t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (TypeMismatchException ex) {\n \t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": {
      "type": "Ybodychange",
      "commitMessage": "revised BeanWrapper\u0027s exception wrapping to consistently handle ConversionExceptions (SPR-7177)\n",
      "commitDate": "2010-05-17, 5:59 p.m.",
      "commitName": "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010-03-24, 1:40 p.m.",
      "commitNameOld": "53b6e1c1b0a9dc60dae2f495751e71cfff401b7e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 54.18,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t}\n\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t// conversion ability for map values.\n\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(this.object, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 904,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,282 +1,225 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n-\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n-\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n-\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalStateException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n+\t\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\t\tArray.set(propValue, arrayIndex, convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n-\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n-\t\t\t\t\tif (index \u003c list.size()) {\n-\t\t\t\t\t\tlist.set(index, convertedValue);\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n-\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tlist.add(null);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n-\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n-\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n-\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tlist.add(convertedValue);\n-\t\t\t\t\t}\n+\t\t\t\tObject convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\tif (index \u003c list.size()) {\n+\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n+\t\t\t\telse if (index \u003e\u003d list.size()) {\n+\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tlist.add(null);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcatch (NullPointerException ex) {\n+\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n+\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n-\t\t\t\tObject convertedMapKey;\n-\t\t\t\tObject convertedMapValue;\n-\t\t\t\ttry {\n-\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n-\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n-\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n-\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n-\t\t\t\t}\n+\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n+\t\t\t\t// must not kick in for map keys but rather only for map values.\n+\t\t\t\tObject convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\t// Pass full property name and old value in here, since we want full\n-\t\t\t\t\t// conversion ability for map values.\n-\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n-\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n-\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n-\t\t\t\t}\n+\t\t\t\t// Pass full property name and old value in here, since we want full\n+\t\t\t\t// conversion ability for map values.\n+\t\t\t\tObject convertedMapValue \u003d convertIfNecessary(\n+\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n+\t\t\t\t\t\tnew TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n+\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026\n+\t\t\t\t\t\t\t\t\t!readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t},acc);\n+\t\t\t\t\t\t\t\t\t}, acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n+\t\t\t\t\t\tvalueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n-\t\t\t\t\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n-\t\t\t\t\t} catch (PrivilegedActionException ex) {\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\twriteMethod.invoke(object, value);\n+\t\t\t\t\twriteMethod.invoke(this.object, value);\n \t\t\t\t}\n-\t\t\t\t\t\n+\t\t\t}\n+\t\t\tcatch (TypeMismatchException ex) {\n+\t\t\t\tthrow ex;\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcatch (ConverterNotFoundException ex) {\n-\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n-\t\t\t}\n-\t\t\tcatch (ConversionException ex) {\n-\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n-\t\t\t}\n-\t\t\tcatch (IllegalStateException ex) {\n-\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n-\t\t\t}\n-\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n-\t\t\t}\n-\t\t\tcatch (IllegalAccessException ex) {\n-\t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new MethodInvocationException(pce, ex);\n-\t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n-\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c33206042c09a4344e5e4a1c6b759eb6180274c": {
      "type": "Ybodychange",
      "commitMessage": "catch ConversionException and ConvertedNotFoundException in BeanWrapper\u0027s convertIfNecessary as well, in order to support constructor resolution (SPR-6563)\n",
      "commitDate": "2009-12-15, 7:53 a.m.",
      "commitName": "1c33206042c09a4344e5e4a1c6b759eb6180274c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-12-07, 1:57 p.m.",
      "commitNameOld": "61f23710ebed6d7feb1e7b477d301d952d3cde5f",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 7.75,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\t\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t} catch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ConverterNotFoundException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (ConversionException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 865,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,277 +1,282 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n \t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n \t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcatch (ConversionException ex) {\n+\t\t\tcatch (ConverterNotFoundException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n-\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\tcatch (ConversionException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n+\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+\t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "61f23710ebed6d7feb1e7b477d301d952d3cde5f": {
      "type": "Ybodychange",
      "commitMessage": "relaxed warning about ambiguous setters to only be logged in case of actual write access (SPR-6399)\n",
      "commitDate": "2009-12-07, 1:57 p.m.",
      "commitName": "61f23710ebed6d7feb1e7b477d301d952d3cde5f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-12-03, 7:34 p.m.",
      "commitNameOld": "e161c93f8dd9fdf7d7685e3ae7a31de03331ae86",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n\t\t\t\t\t\tpd.getWriteMethod());\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\t\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t} catch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ConversionException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 858,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,275 +1,277 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n-\t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n+\t\t\t\tfinal Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ?\n+\t\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :\n+\t\t\t\t\t\tpd.getWriteMethod());\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (ConversionException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ac490114aee005a66eeb0fba6c3c853552fc6a94": {
      "type": "Ybodychange",
      "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
      "commitDate": "2009-11-26, 8:43 p.m.",
      "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-10-18, 9:06 p.m.",
      "commitNameOld": "e4f50f5b7396a88471869c387f2a7fbf2c424a65",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 39.03,
      "commitsBetweenForRepo": 368,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\t\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t} catch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ConversionException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 855,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,275 +1,275 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n-\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n+\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tif (pv.isOptional()) {\n \t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n \t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (ConversionException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad492e906e4c9c994cad733d366ec9c30950ed92": {
      "type": "Ybodychange",
      "commitMessage": "PropertyOverrideConfigurer\u0027s \"ignoreInvalidKeys\" ignores invalid property names as well (SPR-5792)\n",
      "commitDate": "2009-09-24, 10:40 a.m.",
      "commitName": "ad492e906e4c9c994cad733d366ec9c30950ed92",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-09-18, 10:07 a.m.",
      "commitNameOld": "99753f0d1c40c6de81bd4bdcf446c2b6ebed4788",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.02,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tif (pv.isOptional()) {\n\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\t\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, acc);\n\t\t\t\t\t} catch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ConversionException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 730,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,268 +1,275 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n-\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n-\t\t\t\t\tthrow new NotWritablePropertyException(\n-\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n-\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n+\t\t\t\t\tif (pv.isOptional()) {\n+\t\t\t\t\t\tlogger.debug(\"Ignoring optional value for property \u0027\" + actualName +\n+\t\t\t\t\t\t\t\t\"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n+\t\t\t\t\t\tthrow new NotWritablePropertyException(\n+\t\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}, acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (ConversionException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": {
      "type": "Ybodychange",
      "commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
      "commitDate": "2009-08-08, 8:46 p.m.",
      "commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-08-06, 6:31 p.m.",
      "commitNameOld": "af8af8c633ba016eca671bc9468eba006e8834b1",
      "commitAuthorOld": "Costin Leau",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\t\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},acc);\n\t\t\t\t\t} catch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ConversionException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 709,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,263 +1,268 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n \t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() {\n \t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t},acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n+\t\t\tcatch (ConversionException ex) {\n+\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+\t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af8af8c633ba016eca671bc9468eba006e8834b1": {
      "type": "Ybodychange",
      "commitMessage": "+ added fine grained privileged blocks to preserve the caller security stack when invoking the callee\n",
      "commitDate": "2009-08-06, 6:31 p.m.",
      "commitName": "af8af8c633ba016eca671bc9468eba006e8834b1",
      "commitAuthor": "Costin Leau",
      "commitDateOld": "2009-08-06, 12:34 p.m.",
      "commitNameOld": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
      "commitAuthorOld": "Costin Leau",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() {\n\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\t\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},acc);\n\t\t\t\t\t} catch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 707,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,243 +1,263 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n-\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n-\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n+\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n+\t\t\t\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n+\t\t\t\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\t\t\t\t\t\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n+\t\t\t\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t},acc);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\telse {\n \t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n \t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n-\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n-\t\t\t\t\twriteMethod.setAccessible(true);\n+\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n+\t\t\t\t\tif (System.getSecurityManager()!\u003d null) {\n+\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\t\t\t\t\t\t\tpublic Object run() {\n+\t\t\t\t\t\t\t\twriteMethod.setAccessible(true);\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\twriteMethod.setAccessible(true);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tfinal Object value \u003d valueToApply;\n \t\t\t\t\n \t\t\t\tif (System.getSecurityManager() !\u003d null) {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \t\t\t\t\t\t\tpublic Object run() throws Exception {\n \t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t},acc);\n \t\t\t\t\t} catch (PrivilegedActionException ex) {\n \t\t\t\t\t\tthrow ex.getException();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\twriteMethod.invoke(object, value);\n \t\t\t\t}\n \t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t\tcatch (Exception ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209": {
      "type": "Ybodychange",
      "commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
      "commitDate": "2009-08-06, 12:34 p.m.",
      "commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
      "commitAuthor": "Costin Leau",
      "commitDateOld": "2009-05-12, 4:26 a.m.",
      "commitNameOld": "eca1cad7e1e78714d22681554474f887d9046632",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 86.34,
      "commitsBetweenForRepo": 550,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},acc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\tfinal Object value \u003d valueToApply;\n\t\t\t\t\n\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\t\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},acc);\n\t\t\t\t\t} catch (PrivilegedActionException ex) {\n\t\t\t\t\t\tthrow ex.getException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twriteMethod.invoke(object, value);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 696,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,209 +1,243 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalStateException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n-\t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n+\t\t\t\t\t\t\tfinal Method readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n+\t\t\t\t\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n+\t\t\t\t\t\t\t\t\toldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n+\t\t\t\t\t\t\t\t\t\tpublic Object run() throws Exception {\n+\t\t\t\t\t\t\t\t\t\t\treturn readMethod.invoke(object);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t},acc);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(object);\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\t\tif (ex instanceof PrivilegedActionException) {\n+\t\t\t\t\t\t\t\t\tex \u003d ((PrivilegedActionException) ex).getException();\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n-\t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n+\t\t\t\tfinal Method writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n-\t\t\t\twriteMethod.invoke(this.object, valueToApply);\n+\t\t\t\tfinal Object value \u003d valueToApply;\n+\t\t\t\t\n+\t\t\t\tif (System.getSecurityManager() !\u003d null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n+\t\t\t\t\t\t\tpublic Object run() throws Exception {\n+\t\t\t\t\t\t\t\twriteMethod.invoke(object, value);\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t},acc);\n+\t\t\t\t\t} catch (PrivilegedActionException ex) {\n+\t\t\t\t\t\tthrow ex.getException();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\twriteMethod.invoke(object, value);\n+\t\t\t\t}\n+\t\t\t\t\t\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n+\t\t\tcatch (Exception ex) {\n+\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new MethodInvocationException(pce, ex);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eca1cad7e1e78714d22681554474f887d9046632": {
      "type": "Ybodychange",
      "commitMessage": "Fixing build.\n",
      "commitDate": "2009-05-12, 4:26 a.m.",
      "commitName": "eca1cad7e1e78714d22681554474f887d9046632",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2009-05-11, 10:52 a.m.",
      "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\twriteMethod.invoke(this.object, valueToApply);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 658,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,204 +1,209 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n+\t\t\t\tcatch (IllegalStateException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\tthrow new ConversionNotSupportedException(pce, requiredType, ex);\n+\t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n \t\t\t\twriteMethod.invoke(this.object, valueToApply);\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalStateException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bf7a947559d8f9918cc738780bf04caf8ea46962": {
      "type": "Ybodychange",
      "commitMessage": "SPR-5732 - When no type conversion strategy is found on a @Controller handler method bind target, a 500 error code should be returned not a 400.\n\n",
      "commitDate": "2009-05-11, 10:52 a.m.",
      "commitName": "bf7a947559d8f9918cc738780bf04caf8ea46962",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2009-03-31, 4:34 p.m.",
      "commitNameOld": "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 40.76,
      "commitsBetweenForRepo": 240,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\twriteMethod.invoke(this.object, valueToApply);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 658,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,199 +1,204 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey;\n \t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n \t\t\t\twriteMethod.invoke(this.object, valueToApply);\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n+\t\t\tcatch (IllegalStateException ex) {\n+\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n+\t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9dd70ca9fe3775f7459e66695d6e21e112ff9611": {
      "type": "Ybodychange",
      "commitMessage": "polishing\n",
      "commitDate": "2009-03-31, 4:34 p.m.",
      "commitName": "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008-11-27, 12:35 p.m.",
      "commitNameOld": "85661c688218e09dbce629ba7880ee6d9617aa90",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 124.12,
      "commitsBetweenForRepo": 557,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey;\n\t\t\t\tObject convertedMapValue;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\twriteMethod.invoke(this.object, valueToApply);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 651,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,199 +1,199 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n-\t\t\tObject propValue \u003d null;\n+\t\t\tObject propValue;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n-\t\t\t\tObject convertedMapKey \u003d null;\n-\t\t\t\tObject convertedMapValue \u003d null;\n+\t\t\t\tObject convertedMapKey;\n+\t\t\t\tObject convertedMapValue;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n \t\t\t\twriteMethod.invoke(this.object, valueToApply);\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b0790bf5e7b6091552ccf17a2e707ab438d129d7": {
      "type": "Ybodychange",
      "commitMessage": "Java 5 code style\n",
      "commitDate": "2008-11-26, 7:27 p.m.",
      "commitName": "b0790bf5e7b6091552ccf17a2e707ab438d129d7",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008-11-19, 9:10 p.m.",
      "commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue \u003d null;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey \u003d null;\n\t\t\t\tObject convertedMapValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\twriteMethod.invoke(this.object, valueToApply);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 650,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,199 +1,199 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue \u003d null;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n \t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey \u003d null;\n \t\t\t\tObject convertedMapValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object, new Object[0]);\n+\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n-\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n+\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n-\t\t\t\twriteMethod.invoke(this.object, new Object[] {valueToApply});\n+\t\t\t\twriteMethod.invoke(this.object, valueToApply);\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
      "type": "Ybodychange",
      "commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
      "commitDate": "2008-11-19, 9:10 p.m.",
      "commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008-10-27, 7:30 p.m.",
      "commitNameOld": "c8e5aa07a543d8213f96194fea59fb9a1cc7e0e3",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 23.11,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue \u003d null;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey \u003d null;\n\t\t\t\tObject convertedMapValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object, new Object[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\twriteMethod.invoke(this.object, new Object[] {valueToApply});\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 650,
      "functionName": "setPropertyValue",
      "diff": "@@ -1,206 +1,199 @@\n \tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n \t\tString propertyName \u003d tokens.canonicalName;\n \t\tString actualName \u003d tokens.actualName;\n \n \t\tif (tokens.keys !\u003d null) {\n \t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n \t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n \t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n \t\t\tgetterTokens.actualName \u003d tokens.actualName;\n \t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n \t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n \t\t\tObject propValue \u003d null;\n \t\t\ttry {\n \t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n \t\t\t}\n \t\t\tcatch (NotReadablePropertyException ex) {\n \t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t}\n \t\t\t// Set value for last key.\n \t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n \t\t\tif (propValue \u003d\u003d null) {\n \t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n \t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n \t\t\t}\n \t\t\telse if (propValue.getClass().isArray()) {\n \t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n \t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n \t\t\t\t\t}\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t\tcatch (IndexOutOfBoundsException ex) {\n \t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof List) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass requiredType \u003d null;\n-\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n-\t\t\t\t\trequiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n-\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\t}\n+\t\t\t\tClass requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n+\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tList list \u003d (List) propValue;\n \t\t\t\tint index \u003d Integer.parseInt(key);\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n \t\t\t\t\toldValue \u003d list.get(index);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n \t\t\t\t\tif (index \u003c list.size()) {\n \t\t\t\t\t\tlist.set(index, convertedValue);\n \t\t\t\t\t}\n \t\t\t\t\telse if (index \u003e\u003d list.size()) {\n \t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\tlist.add(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (NullPointerException ex) {\n \t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n \t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n \t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tlist.add(convertedValue);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (propValue instanceof Map) {\n \t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-\t\t\t\tClass mapKeyType \u003d null;\n-\t\t\t\tClass mapValueType \u003d null;\n-\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n-\t\t\t\t\tmapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n-\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\t\tmapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n-\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n-\t\t\t\t}\n+\t\t\t\tClass mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n+\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\tClass mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n+\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n \t\t\t\tMap map \u003d (Map) propValue;\n \t\t\t\tObject convertedMapKey \u003d null;\n \t\t\t\tObject convertedMapValue \u003d null;\n \t\t\t\ttry {\n \t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n \t\t\t\t\t// must not kick in for map keys but rather only for map values.\n \t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n \t\t\t\t}\n \t\t\t\tObject oldValue \u003d null;\n \t\t\t\tif (isExtractOldValueForEditor()) {\n \t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n \t\t\t\t}\n \t\t\t\ttry {\n \t\t\t\t\t// Pass full property name and old value in here, since we want full\n \t\t\t\t\t// conversion ability for map values.\n \t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n \t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n \t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n \t\t\t\t}\n \t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n \t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n \t\t\t}\n \t\t}\n \n \t\telse {\n \t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n \t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n \t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n \t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n \t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n \t\t\t\t\tthrow new NotWritablePropertyException(\n \t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n \t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n \t\t\t\t}\n \t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n \t\t\t}\n \n \t\t\tObject oldValue \u003d null;\n \t\t\ttry {\n \t\t\t\tObject originalValue \u003d pv.getValue();\n \t\t\t\tObject valueToApply \u003d originalValue;\n \t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n \t\t\t\t\tif (pv.isConverted()) {\n \t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n \t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n \t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\ttry {\n \t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object, new Object[0]);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcatch (Exception ex) {\n \t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n \t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n \t\t\t\t\t}\n \t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n \t\t\t\t}\n \t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n \t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n \t\t\t\t\twriteMethod.setAccessible(true);\n \t\t\t\t}\n \t\t\t\twriteMethod.invoke(this.object, new Object[] {valueToApply});\n \t\t\t}\n \t\t\tcatch (InvocationTargetException ex) {\n \t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n \t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n \t\t\t}\n \t\t\tcatch (IllegalAccessException ex) {\n \t\t\t\tPropertyChangeEvent pce \u003d\n \t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n \t\t\t\tthrow new MethodInvocationException(pce, ex);\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
      "type": "Yintroduced",
      "commitMessage": "Moved over initial version of beans bundle\n",
      "commitDate": "2008-10-22, 12:13 p.m.",
      "commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthor": "Arjen Poutsma",
      "diff": "@@ -0,0 +1,206 @@\n+\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+\t\tString propertyName \u003d tokens.canonicalName;\n+\t\tString actualName \u003d tokens.actualName;\n+\n+\t\tif (tokens.keys !\u003d null) {\n+\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n+\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n+\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n+\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n+\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n+\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n+\t\t\tObject propValue \u003d null;\n+\t\t\ttry {\n+\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n+\t\t\t}\n+\t\t\tcatch (NotReadablePropertyException ex) {\n+\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n+\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n+\t\t\t}\n+\t\t\t// Set value for last key.\n+\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n+\t\t\tif (propValue \u003d\u003d null) {\n+\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n+\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+\t\t\t}\n+\t\t\telse if (propValue.getClass().isArray()) {\n+\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n+\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n+\t\t\t\tObject oldValue \u003d null;\n+\t\t\t\ttry {\n+\t\t\t\t\tif (isExtractOldValueForEditor()) {\n+\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n+\t\t\t\t\t}\n+\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n+\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n+\t\t\t\t}\n+\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n+\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (propValue instanceof List) {\n+\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tClass requiredType \u003d null;\n+\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n+\t\t\t\t\trequiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n+\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\t}\n+\t\t\t\tList list \u003d (List) propValue;\n+\t\t\t\tint index \u003d Integer.parseInt(key);\n+\t\t\t\tObject oldValue \u003d null;\n+\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n+\t\t\t\t\toldValue \u003d list.get(index);\n+\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n+\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n+\t\t\t\t\tif (index \u003c list.size()) {\n+\t\t\t\t\t\tlist.set(index, convertedValue);\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n+\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\tlist.add(null);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n+\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n+\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n+\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tlist.add(convertedValue);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (propValue instanceof Map) {\n+\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tClass mapKeyType \u003d null;\n+\t\t\t\tClass mapValueType \u003d null;\n+\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n+\t\t\t\t\tmapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n+\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\t\tmapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n+\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n+\t\t\t\t}\n+\t\t\t\tMap map \u003d (Map) propValue;\n+\t\t\t\tObject convertedMapKey \u003d null;\n+\t\t\t\tObject convertedMapValue \u003d null;\n+\t\t\t\ttry {\n+\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n+\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n+\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n+\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n+\t\t\t\t}\n+\t\t\t\tObject oldValue \u003d null;\n+\t\t\t\tif (isExtractOldValueForEditor()) {\n+\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n+\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\t// Pass full property name and old value in here, since we want full\n+\t\t\t\t\t// conversion ability for map values.\n+\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n+\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n+\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n+\t\t\t\t}\n+\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n+\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n+\t\t\t}\n+\t\t}\n+\n+\t\telse {\n+\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n+\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n+\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n+\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n+\t\t\t\t\tthrow new NotWritablePropertyException(\n+\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n+\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n+\t\t\t\t}\n+\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n+\t\t\t}\n+\n+\t\t\tObject oldValue \u003d null;\n+\t\t\ttry {\n+\t\t\t\tObject originalValue \u003d pv.getValue();\n+\t\t\t\tObject valueToApply \u003d originalValue;\n+\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n+\t\t\t\t\tif (pv.isConverted()) {\n+\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n+\t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n+\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n+\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object, new Object[0]);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcatch (Exception ex) {\n+\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n+\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n+\t\t\t\t\t}\n+\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n+\t\t\t\t}\n+\t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n+\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n+\t\t\t\t\twriteMethod.setAccessible(true);\n+\t\t\t\t}\n+\t\t\t\twriteMethod.invoke(this.object, new Object[] {valueToApply});\n+\t\t\t}\n+\t\t\tcatch (InvocationTargetException ex) {\n+\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n+\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+\t\t\t}\n+\t\t\tcatch (IllegalAccessException ex) {\n+\t\t\t\tPropertyChangeEvent pce \u003d\n+\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+\t\t\t\tthrow new MethodInvocationException(pce, ex);\n+\t\t\t}\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n\t\tString propertyName \u003d tokens.canonicalName;\n\t\tString actualName \u003d tokens.actualName;\n\n\t\tif (tokens.keys !\u003d null) {\n\t\t\t// Apply indexes and map keys: fetch value for all keys but the last one.\n\t\t\tPropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n\t\t\tgetterTokens.canonicalName \u003d tokens.canonicalName;\n\t\t\tgetterTokens.actualName \u003d tokens.actualName;\n\t\t\tgetterTokens.keys \u003d new String[tokens.keys.length - 1];\n\t\t\tSystem.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n\t\t\tObject propValue \u003d null;\n\t\t\ttry {\n\t\t\t\tpropValue \u003d getPropertyValue(getterTokens);\n\t\t\t}\n\t\t\tcatch (NotReadablePropertyException ex) {\n\t\t\t\tthrow new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t}\n\t\t\t// Set value for last key.\n\t\t\tString key \u003d tokens.keys[tokens.keys.length - 1];\n\t\t\tif (propValue \u003d\u003d null) {\n\t\t\t\tthrow new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Cannot access indexed value in property referenced \" +\n\t\t\t\t\t\t\"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n\t\t\t}\n\t\t\telse if (propValue.getClass().isArray()) {\n\t\t\t\tClass requiredType \u003d propValue.getClass().getComponentType();\n\t\t\t\tint arrayIndex \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\t\toldValue \u003d Array.get(propValue, arrayIndex);\n\t\t\t\t\t}\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tArray.set(propValue, Integer.parseInt(key), convertedValue);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t\tcatch (IndexOutOfBoundsException ex) {\n\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof List) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass requiredType \u003d null;\n\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n\t\t\t\t\trequiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(\n\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\t}\n\t\t\t\tList list \u003d (List) propValue;\n\t\t\t\tint index \u003d Integer.parseInt(key);\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n\t\t\t\t\toldValue \u003d list.get(index);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), requiredType);\n\t\t\t\t\tif (index \u003c list.size()) {\n\t\t\t\t\t\tlist.set(index, convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\telse if (index \u003e\u003d list.size()) {\n\t\t\t\t\t\tfor (int i \u003d list.size(); i \u003c index; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlist.add(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (NullPointerException ex) {\n\t\t\t\t\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\t\t\t\t\"Cannot set element with index \" + index + \" in List of size \" +\n\t\t\t\t\t\t\t\t\t\tlist.size() + \", accessed using property path \u0027\" + propertyName +\n\t\t\t\t\t\t\t\t\t\t\"\u0027: List does not support filling up gaps with null elements\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, requiredType, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (propValue instanceof Map) {\n\t\t\t\tPropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tClass mapKeyType \u003d null;\n\t\t\t\tClass mapValueType \u003d null;\n\t\t\t\tif (JdkVersion.isAtLeastJava15()) {\n\t\t\t\t\tmapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(\n\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\t\tmapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(\n\t\t\t\t\t\t\tpd.getReadMethod(), tokens.keys.length);\n\t\t\t\t}\n\t\t\t\tMap map \u003d (Map) propValue;\n\t\t\t\tObject convertedMapKey \u003d null;\n\t\t\t\tObject convertedMapValue \u003d null;\n\t\t\t\ttry {\n\t\t\t\t\t// IMPORTANT: Do not pass full property name in here - property editors\n\t\t\t\t\t// must not kick in for map keys but rather only for map values.\n\t\t\t\t\tconvertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapKeyType, ex);\n\t\t\t\t}\n\t\t\t\tObject oldValue \u003d null;\n\t\t\t\tif (isExtractOldValueForEditor()) {\n\t\t\t\t\toldValue \u003d map.get(convertedMapKey);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// Pass full property name and old value in here, since we want full\n\t\t\t\t\t// conversion ability for map values.\n\t\t\t\t\tconvertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(\n\t\t\t\t\t\t\tpropertyName, oldValue, pv.getValue(), mapValueType, null,\n\t\t\t\t\t\t\tnew MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\t\tthrow new TypeMismatchException(pce, mapValueType, ex);\n\t\t\t\t}\n\t\t\t\tmap.put(convertedMapKey, convertedMapValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\"Property referenced in indexed property path \u0027\" + propertyName +\n\t\t\t\t\t\t\"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tPropertyDescriptor pd \u003d pv.resolvedDescriptor;\n\t\t\tif (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n\t\t\t\tpd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n\t\t\t\tif (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n\t\t\t\t\tPropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n\t\t\t\t\tthrow new NotWritablePropertyException(\n\t\t\t\t\t\t\tgetRootClass(), this.nestedPath + propertyName,\n\t\t\t\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t\t\t\t}\n\t\t\t\tpv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n\t\t\t}\n\n\t\t\tObject oldValue \u003d null;\n\t\t\ttry {\n\t\t\t\tObject originalValue \u003d pv.getValue();\n\t\t\t\tObject valueToApply \u003d originalValue;\n\t\t\t\tif (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n\t\t\t\t\tif (pv.isConverted()) {\n\t\t\t\t\t\tvalueToApply \u003d pv.getConvertedValue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n\t\t\t\t\t\t\tMethod readMethod \u003d pd.getReadMethod();\n\t\t\t\t\t\t\tif (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\t\t\treadMethod.setAccessible(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toldValue \u003d readMethod.invoke(this.object, new Object[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Could not read previous value of property \u0027\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.nestedPath + propertyName + \"\u0027\", ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n\t\t\t\t\t}\n\t\t\t\t\tpv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n\t\t\t\t}\n\t\t\t\tMethod writeMethod \u003d pd.getWriteMethod();\n\t\t\t\tif (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\twriteMethod.setAccessible(true);\n\t\t\t\t}\n\t\t\t\twriteMethod.invoke(this.object, new Object[] {valueToApply});\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tPropertyChangeEvent propertyChangeEvent \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tif (ex.getTargetException() instanceof ClassCastException) {\n\t\t\t\t\tthrow new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new TypeMismatchException(pce, pd.getPropertyType(), ex);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException ex) {\n\t\t\t\tPropertyChangeEvent pce \u003d\n\t\t\t\t\t\tnew PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n\t\t\t\tthrow new MethodInvocationException(pce, ex);\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 658,
      "functionName": "setPropertyValue"
    }
  }
}