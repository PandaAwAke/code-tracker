{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "H:\\Projects\\javaparser\\javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "MethodCallExprContext.java",
  "functionName": "solveMethodAsUsage",
  "functionId": "solveMethodAsUsage___name-String__argumentsTypes-List__ResolvedType____typeSolver-TypeSolver",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
  "functionStartLine": 76,
  "functionEndLine": 121,
  "numCommitsSeen": 198,
  "timeTaken": 1095,
  "changeHistory": [
    "791449a6ab0696f4c0109908a4a0925e514b10d9",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "5d8d0cb7947efcf2282f7d056302dd905f348532",
    "dd5c0a00fb9cbd9995d9141907848ec5a3342760",
    "acdac6790f4424f8097b3aa6c888e825cac485f9",
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
    "03055f925053b3970b9d14cce3a3b9a0d002366d",
    "a1c7c58143a592965f8378767adc69709e4c0043",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
    "d017fb8caf6ccb3343da0062eb2c85262712772c",
    "2082034e8c3eb434e3df25dd420c98cae5a6d518",
    "13d789de30e6c3d29efb17a2acdff443f8c48db1",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "03e407957d600a18ef0a4a83224c17d155ef8645",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
    "8d234965b572759181da7787fead07b225e9e5ca",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "38d780df85a22c9baffb1f772a45b063cad73aab",
    "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "ead147279ca0b84d2f479a714943b20cd689e7c7",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "e21fca16e413a8bf31d613aa97a744d075c374dd",
    "0e81f51c40996b42cb262dc2397126cee8f60965",
    "b36f33050149a62a5b3c8c7451ae93f736715029",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
    "1ae290f6f5e0c7ba62eab797aba22308957b9257",
    "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
    "46aefdd68f2f2597a19b72da36681123cb3090e6",
    "6c297529e31036058837adbaa57cee652d4cc918",
    "7b2a0b366461674aa6320b11a38a17909d8a74a3",
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
    "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731",
    "627b56302d259409e9bc50b20d77803484f18b5c",
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606"
  ],
  "changeHistoryShort": {
    "791449a6ab0696f4c0109908a4a0925e514b10d9": "Ybodychange",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "5d8d0cb7947efcf2282f7d056302dd905f348532": "Ymultichange(Yparameterchange,Ybodychange)",
    "dd5c0a00fb9cbd9995d9141907848ec5a3342760": "Ybodychange",
    "acdac6790f4424f8097b3aa6c888e825cac485f9": "Ybodychange",
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": "Ybodychange",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": "Ybodychange",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": "Ybodychange",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": "Ybodychange",
    "03055f925053b3970b9d14cce3a3b9a0d002366d": "Ybodychange",
    "a1c7c58143a592965f8378767adc69709e4c0043": "Ybodychange",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": "Ybodychange",
    "d017fb8caf6ccb3343da0062eb2c85262712772c": "Ybodychange",
    "2082034e8c3eb434e3df25dd420c98cae5a6d518": "Ybodychange",
    "13d789de30e6c3d29efb17a2acdff443f8c48db1": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "03e407957d600a18ef0a4a83224c17d155ef8645": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": "Ymultichange(Yparameterchange,Ybodychange)",
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d": "Ybodychange",
    "8d234965b572759181da7787fead07b225e9e5ca": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "38d780df85a22c9baffb1f772a45b063cad73aab": "Ybodychange",
    "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "ead147279ca0b84d2f479a714943b20cd689e7c7": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "e21fca16e413a8bf31d613aa97a744d075c374dd": "Ybodychange",
    "0e81f51c40996b42cb262dc2397126cee8f60965": "Ybodychange",
    "b36f33050149a62a5b3c8c7451ae93f736715029": "Yfilerename",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": "Ybodychange",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": "Ybodychange",
    "1ae290f6f5e0c7ba62eab797aba22308957b9257": "Ybodychange",
    "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30": "Ybodychange",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": "Ybodychange",
    "46aefdd68f2f2597a19b72da36681123cb3090e6": "Ybodychange",
    "6c297529e31036058837adbaa57cee652d4cc918": "Ybodychange",
    "7b2a0b366461674aa6320b11a38a17909d8a74a3": "Ybodychange",
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd": "Ybodychange",
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08": "Ybodychange",
    "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731": "Ybodychange",
    "627b56302d259409e9bc50b20d77803484f18b5c": "Ybodychange",
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606": "Yintroduced"
  },
  "changeHistoryDetails": {
    "791449a6ab0696f4c0109908a4a0925e514b10d9": {
      "type": "Ybodychange",
      "commitMessage": "fixing failing tests by considering the context of calls within ObjectCreationExpr\n",
      "commitDate": "2018-06-06, 9:52 a.m.",
      "commitName": "791449a6ab0696f4c0109908a4a0925e514b10d9",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018-03-30, 9:12 a.m.",
      "commitNameOld": "7df79507310cc762c732281053961e6a89078f80",
      "commitAuthorOld": "daans",
      "daysBetweenCommits": 68.03,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className \u003d ((NameExpr) scope).getName().getId();\n                SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n                ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext || parentContext instanceof ObjectCreationContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 76,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,46 +1,46 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className \u003d ((NameExpr) scope).getName().getId();\n                 SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n                 ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n-            while (parentContext instanceof MethodCallExprContext) {\n+            while (parentContext instanceof MethodCallExprContext || parentContext instanceof ObjectCreationContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018-01-10, 7:52 a.m.",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018-01-10, 3:01 a.m.",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className \u003d ((NameExpr) scope).getName().getId();\n                SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n                ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 74,
      "functionName": "solveMethodAsUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "5d8d0cb7947efcf2282f7d056302dd905f348532": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "more work on converting to moved classes\n",
      "commitDate": "2017-09-28, 4:36 p.m.",
      "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017-09-28, 4:36 p.m.",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-08-28, 5:15 a.m.",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className \u003d ((NameExpr) scope).getName().getId();\n                SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n                ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 73,
          "functionName": "solveMethodAsUsage",
          "diff": "@@ -1,46 +1,46 @@\n-    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n+    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className \u003d ((NameExpr) scope).getName().getId();\n-                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+                SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n+            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n-            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n+            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n-                Type originalArgumentType \u003d argumentsTypes.get(i);\n-                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+                ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n+                ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+                ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cResolvedType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017-09-28, 4:36 p.m.",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017-08-28, 5:15 a.m.",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className \u003d ((NameExpr) scope).getName().getId();\n                SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n                ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 73,
          "functionName": "solveMethodAsUsage",
          "diff": "@@ -1,46 +1,46 @@\n-    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n+    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className \u003d ((NameExpr) scope).getName().getId();\n-                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+                SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n+            ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n-            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n+            Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n-                Type originalArgumentType \u003d argumentsTypes.get(i);\n-                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+                ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n+                ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+                ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "dd5c0a00fb9cbd9995d9141907848ec5a3342760": {
      "type": "Ybodychange",
      "commitMessage": "Make the MethodUsage type param map correct in more cases\n",
      "commitDate": "2017-04-17, 5:28 p.m.",
      "commitName": "dd5c0a00fb9cbd9995d9141907848ec5a3342760",
      "commitAuthor": "Max Bolingbroke",
      "commitDateOld": "2017-03-22, 9:31 p.m.",
      "commitNameOld": "63c7f0fb4247e490bdd05d2779c6983c892fe570",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 25.83,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className \u003d ((NameExpr) scope).getName().getId();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 79,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,45 +1,46 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className \u003d ((NameExpr) scope).getName().getId();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n+                        methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "acdac6790f4424f8097b3aa6c888e825cac485f9": {
      "type": "Ybodychange",
      "commitMessage": "Fixes for type inference\n",
      "commitDate": "2017-03-09, 8:22 p.m.",
      "commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-03-08, 10:31 p.m.",
      "commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className \u003d ((NameExpr) scope).getName().getId();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 75,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className \u003d ((NameExpr) scope).getName().getId();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n+                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": {
      "type": "Ybodychange",
      "commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
      "commitDate": "2017-03-08, 10:31 p.m.",
      "commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-03-08, 4:40 p.m.",
      "commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className \u003d ((NameExpr) scope).getName().getId();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 75,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope \u003d wrappedNode.getScope().get();\n             // Consider static method calls\n             if (scope instanceof NameExpr) {\n                 String className \u003d ((NameExpr) scope).getName().getId();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
      "type": "Ybodychange",
      "commitMessage": "Update for JavaParser 3.0.0\n",
      "commitDate": "2017-01-11, 7:45 p.m.",
      "commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017-01-06, 4:11 a.m.",
      "commitNameOld": "860a4c0c034e1b8232e3d1ec17e7f11879850470",
      "commitAuthorOld": "",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n            Expression scope \u003d wrappedNode.getScope().get();\n            // Consider static method calls\n            if (scope instanceof NameExpr) {\n                String className \u003d ((NameExpr) scope).getName().getId();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 75,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope() !\u003d null) {\n-\n+        if (wrappedNode.getScope().isPresent()) {\n+            Expression scope \u003d wrappedNode.getScope().get();\n             // Consider static method calls\n-            if (wrappedNode.getScope() instanceof NameExpr) {\n-                String className \u003d ((NameExpr) wrappedNode.getScope()).getName().getId();\n+            if (scope instanceof NameExpr) {\n+                String className \u003d ((NameExpr) scope).getName().getId();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
      "type": "Ybodychange",
      "commitMessage": "adapt to alpha.10\n",
      "commitDate": "2016-11-21, 1:58 p.m.",
      "commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-09, 12:15 p.m.",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n\n            // Consider static method calls\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName().getId();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 66,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n \n             // Consider static method calls\n             if (wrappedNode.getScope() instanceof NameExpr) {\n-                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n+                String className \u003d ((NameExpr) wrappedNode.getScope()).getName().getId();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
      "type": "Ybodychange",
      "commitMessage": "changes necessary to support jpalpha8\n",
      "commitDate": "2016-11-09, 12:15 p.m.",
      "commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-06, 8:49 a.m.",
      "commitNameOld": "03055f925053b3970b9d14cce3a3b9a0d002366d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.14,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n\n            // Consider static method calls\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 66,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,45 +1,45 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope().isPresent()) {\n+        if (wrappedNode.getScope() !\u003d null) {\n \n             // Consider static method calls\n-            if (wrappedNode.getScope().get() instanceof NameExpr) {\n-                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n+            if (wrappedNode.getScope() instanceof NameExpr) {\n+                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                 \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03055f925053b3970b9d14cce3a3b9a0d002366d": {
      "type": "Ybodychange",
      "commitMessage": "add AbstractMethodLikeDeclarationContext\n",
      "commitDate": "2016-11-06, 8:49 a.m.",
      "commitName": "03055f925053b3970b9d14cce3a3b9a0d002366d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-06, 3:57 a.m.",
      "commitNameOld": "27f0f20ee38a85d0d7a476f9a49d15325d4d660e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope().isPresent()) {\n\n            // Consider static method calls\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 66,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,44 +1,45 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-        // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n+            // Consider static method calls\n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n-                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n+                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(),\n+                                \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1c7c58143a592965f8378767adc69709e4c0043": {
      "type": "Ybodychange",
      "commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
      "commitDate": "2016-11-05, 11:22 a.m.",
      "commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-05, 11:08 a.m.",
      "commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope().isPresent()) {\n\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 256,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,44 +1,44 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n-                SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
      "type": "Ybodychange",
      "commitMessage": "creating ReferenceTypeDeclaration\n",
      "commitDate": "2016-11-05, 11:08 a.m.",
      "commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-11-02, 4:08 p.m.",
      "commitNameOld": "effd4c172ad6e4d60d68a749121a0960040edd63",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 2.79,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope().isPresent()) {\n\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 256,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,44 +1,44 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n-                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+                SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                 Type originalArgumentType \u003d argumentsTypes.get(i);\n                 Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                 argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d017fb8caf6ccb3343da0062eb2c85262712772c": {
      "type": "Ybodychange",
      "commitMessage": "avoid issue with recursive generic type replacement\n",
      "commitDate": "2016-10-27, 1:31 p.m.",
      "commitName": "d017fb8caf6ccb3343da0062eb2c85262712772c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-27, 1:53 a.m.",
      "commitNameOld": "901bca148f3256e176bd7c22b159917b6926b5b7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.48,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope().isPresent()) {\n\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                Type originalArgumentType \u003d argumentsTypes.get(i);\n                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n                argumentsTypes.set(i, updatedArgumentType);\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 259,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,41 +1,44 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n             Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 // by replacing types I can also find new equivalences\n                 // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n-                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n+                Type originalArgumentType \u003d argumentsTypes.get(i);\n+                Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+                argumentsTypes.set(i, updatedArgumentType);\n             }\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-                argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n+                Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+                argumentsTypes.set(i, updatedArgumentType);\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2082034e8c3eb434e3df25dd420c98cae5a6d518": {
      "type": "Ybodychange",
      "commitMessage": "type inference\n",
      "commitDate": "2016-10-24, 1:19 p.m.",
      "commitName": "2082034e8c3eb434e3df25dd420c98cae5a6d518",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-23, 2:00 p.m.",
      "commitNameOld": "cf0045ad73d15502e16c6de02334d39383dfee78",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope().isPresent()) {\n\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                // by replacing types I can also find new equivalences\n                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n            }\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 264,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,35 +1,41 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n \n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 }\n             }\n \n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             // we can replace the parameter types from the scope into the typeParametersValues\n \n+            Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n+                // by replacing types I can also find new equivalences\n+                // for example if I replace T\u003dU with String because I know that T\u003dString I can derive that also U equal String\n+                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n+            }\n+            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n+                argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n             }\n \n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13d789de30e6c3d29efb17a2acdff443f8c48db1": {
      "type": "Ybodychange",
      "commitMessage": "handling static calls\n",
      "commitDate": "2016-10-23, 4:58 a.m.",
      "commitName": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-22, 12:40 p.m.",
      "commitNameOld": "b26a4c591ec4cf8e25847b987610c65a22f60589",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.68,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope().isPresent()) {\n\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                }\n            }\n\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            // we can replace the parameter types from the scope into the typeParametersValues\n\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 189,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,41 +1,35 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope().isPresent()) {\n-            try {\n-                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n-                // we can replace the parameter types from the scope into the typeParametersValues\n \n-                for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n-                }\n-\n-                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n-            } catch (UnsolvedSymbolException e) {\n-                // ok, maybe it was instead a static access, so let\u0027s look for a type\n-                if (wrappedNode.getScope().get() instanceof NameExpr) {\n-                    String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n-                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n-                    if (ref.isSolved()) {\n-                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n-                        if (m.isSolved()) {\n-                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n-                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n-                            return Optional.of(methodUsage);\n-                        } else {\n-                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n-                        }\n+            if (wrappedNode.getScope().get() instanceof NameExpr) {\n+                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n+                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+                if (ref.isSolved()) {\n+                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                    if (m.isSolved()) {\n+                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n+                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n+                        return Optional.of(methodUsage);\n                     } else {\n-                        throw e;\n+                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n-                } else {\n-                    throw e;\n                 }\n             }\n+\n+            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+            // we can replace the parameter types from the scope into the typeParametersValues\n+\n+            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n+                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n+            }\n+\n+            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016-10-20, 2:39 a.m.",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-20, 2:32 a.m.",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope().isPresent()) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n                // we can replace the parameter types from the scope into the typeParametersValues\n\n                for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope().get() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 189,
      "functionName": "solveMethodAsUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "03e407957d600a18ef0a4a83224c17d155ef8645": {
      "type": "Ybodychange",
      "commitMessage": "fixing a few more tests\n",
      "commitDate": "2016-10-19, 1:34 p.m.",
      "commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 1:33 p.m.",
      "commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope().isPresent()) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n                // we can replace the parameter types from the scope into the typeParametersValues\n\n                for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope().get() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 191,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,41 +1,41 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n-        if (wrappedNode.getScope() !\u003d null) {\n+        if (wrappedNode.getScope().isPresent()) {\n             try {\n                 Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n                 for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n                     argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope().get() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                             methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016-10-19, 1:33 p.m.",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-19, 11:04 a.m.",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n                // we can replace the parameter types from the scope into the typeParametersValues\n\n                for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope().get() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 191,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,41 +1,41 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n-                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n                 for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n                     argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n-                if (wrappedNode.getScope() instanceof NameExpr) {\n-                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n+                if (wrappedNode.getScope().get() instanceof NameExpr) {\n+                    String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                             methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
      "commitDate": "2016-10-17, 1:25 p.m.",
      "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016-10-17, 1:25 p.m.",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-16, 12:48 p.m.",
          "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.03,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                // we can replace the parameter types from the scope into the typeParametersValues\n\n                for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 175,
          "functionName": "solveMethodAsUsage",
          "diff": "@@ -1,41 +1,41 @@\n-    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n+    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n-                for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n-                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+                for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n+                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                 }\n \n-                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n+                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n+                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n-                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n-                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n+                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n-            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cType\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016-10-17, 1:25 p.m.",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-16, 12:48 p.m.",
          "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.03,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                // we can replace the parameter types from the scope into the typeParametersValues\n\n                for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 175,
          "functionName": "solveMethodAsUsage",
          "diff": "@@ -1,41 +1,41 @@\n-    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n+    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n-                for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n-                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+                for (int i \u003d 0; i\u003c argumentsTypes.size(); i++) {\n+                    argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n                 }\n \n-                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n+                return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n+                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n-                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n-                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n+                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n-            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeDeclaration.solveMethod\n",
      "commitDate": "2016-10-16, 12:13 p.m.",
      "commitName": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 4:57 p.m.",
      "commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                // we can replace the parameter types from the scope into the typeParametersValues\n\n                for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 183,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,41 +1,41 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the typeParametersValues\n \n                 for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                     parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n+                        SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                             methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d234965b572759181da7787fead07b225e9e5ca": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeSolver from MethodUsage\n",
      "commitDate": "2016-10-14, 2:36 a.m.",
      "commitName": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-14, 2:19 a.m.",
      "commitNameOld": "6b50c90daa764492e074198460c807d83d52325e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                // we can replace the parameter types from the scope into the parameters\n\n                for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 182,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,41 +1,41 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the parameters\n \n                 for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                     parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n-                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n+                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                             methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016-10-13, 4:11 p.m.",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-12, 5:43 p.m.",
          "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                // we can replace the parameter types from the scope into the parameters\n\n                for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 181,
          "functionName": "solveMethodAsUsage",
          "diff": "@@ -1,41 +1,41 @@\n-    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n-                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the parameters\n \n                 for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                     parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                             methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, parameterTypes-List\u003cType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016-10-13, 4:11 p.m.",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016-10-12, 5:43 p.m.",
          "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                // we can replace the parameter types from the scope into the parameters\n\n                for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 181,
          "functionName": "solveMethodAsUsage",
          "diff": "@@ -1,41 +1,41 @@\n-    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n-                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 // we can replace the parameter types from the scope into the parameters\n \n                 for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                     parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                 }\n \n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                             methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "38d780df85a22c9baffb1f772a45b063cad73aab": {
      "type": "Ybodychange",
      "commitMessage": "issue80: replace type parameters in parameters using values from scope\n",
      "commitDate": "2016-10-12, 4:53 p.m.",
      "commitName": "38d780df85a22c9baffb1f772a45b063cad73aab",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016-10-11, 1:37 p.m.",
      "commitNameOld": "acf74024c2d341bf4009af7173c9b1b972f19c32",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.14,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                // we can replace the parameter types from the scope into the parameters\n\n                for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n                }\n\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 180,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,35 +1,41 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                // we can replace the parameter types from the scope into the parameters\n+\n+                for (int i\u003d0;i\u003cparameterTypes.size();i++) {\n+                    parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+                }\n+\n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                             methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             Context parentContext \u003d getParent();\n             while (parentContext instanceof MethodCallExprContext) {\n                 parentContext \u003d parentContext.getParent();\n             }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76": {
      "type": "Ybodychange",
      "commitMessage": "fixed StackOverflowError when solving call on method return type as described in issue #43 and implemented test for this case.\n",
      "commitDate": "2016-09-26, 1:15 p.m.",
      "commitName": "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016-09-23, 6:10 a.m.",
      "commitNameOld": "2c3f615e6b24358b86d6453e24dac35849ffde26",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 3.29,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            Context parentContext \u003d getParent();\n            while (parentContext instanceof MethodCallExprContext) {\n                parentContext \u003d parentContext.getParent();\n            }\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 154,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,39 +1,35 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                             methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                             return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n-\n                 }\n             }\n         } else {\n-            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n-                if (parent.getScope() \u003d\u003d wrappedNode) {\n-                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n-                }\n-            }\n             Context parentContext \u003d getParent();\n+            while (parentContext instanceof MethodCallExprContext) {\n+                parentContext \u003d parentContext.getParent();\n+            }\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015-11-22, 5:45 a.m.",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-22, 5:03 a.m.",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext \u003d getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 149,
      "functionName": "solveMethodAsUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "ead147279ca0b84d2f479a714943b20cd689e7c7": {
      "type": "Ybodychange",
      "commitMessage": "issue7: consider type parameters and varargs combinations\n",
      "commitDate": "2015-11-20, 11:04 a.m.",
      "commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 8:55 a.m.",
      "commitNameOld": "5aca9bfacfba18bfd16d17b16c8e5ef5c7609af4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 7.09,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                            return Optional.of(methodUsage);\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext \u003d getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 139,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,36 +1,39 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e) {\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr) {\n                     String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n-                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                            MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n+                            methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                            return Optional.of(methodUsage);\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n+\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                 if (parent.getScope() \u003d\u003d wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             Context parentContext \u003d getParent();\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015-11-13, 4:12 a.m.",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-13, 3:53 a.m.",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e) {\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr) {\n                    String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext \u003d getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 79,
      "functionName": "solveMethodAsUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
      }
    },
    "e21fca16e413a8bf31d613aa97a744d075c374dd": {
      "type": "Ybodychange",
      "commitMessage": "add AbstractTypeDeclaration\n",
      "commitDate": "2015-11-02, 3:11 p.m.",
      "commitName": "e21fca16e413a8bf31d613aa97a744d075c374dd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-11-01, 9:57 a.m.",
      "commitNameOld": "965ab8585c3e8be1dff784e749e37dad31151ec8",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.22,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext \u003d getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 80,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,36 +1,36 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n+                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() \u003d\u003d wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             Context parentContext \u003d getParent();\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e81f51c40996b42cb262dc2397126cee8f60965": {
      "type": "Ybodychange",
      "commitMessage": "embedding TypeSolver\n",
      "commitDate": "2015-10-30, 6:37 p.m.",
      "commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 9:30 a.m.",
      "commitNameOld": "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.38,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext \u003d getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 77,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,36 +1,36 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+                return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() \u003d\u003d wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             Context parentContext \u003d getParent();\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36f33050149a62a5b3c8c7451ae93f736715029": {
      "type": "Yfilerename",
      "commitMessage": "reorganize packages\n",
      "commitDate": "2015-10-30, 5:53 a.m.",
      "commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-10-30, 5:29 a.m.",
      "commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext \u003d getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
      }
    },
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
      "type": "Ybodychange",
      "commitMessage": "remove noise\n",
      "commitDate": "2015-08-24, 5:05 p.m.",
      "commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 4:42 p.m.",
      "commitNameOld": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            Context parentContext \u003d getParent();\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,42 +1,36 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n-        if (name.equals(\"cloneNodes\")) {\n-            System.out.println(\"FOO\");\n-        }\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() \u003d\u003d wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n-            //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext \u003d getParent();\n-            //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": {
      "type": "Ybodychange",
      "commitMessage": "considering method type parameters\n",
      "commitDate": "2015-08-24, 4:42 p.m.",
      "commitName": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 3:37 p.m.",
      "commitNameOld": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (name.equals(\"cloneNodes\")) {\n            System.out.println(\"FOO\");\n        }\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            Context parentContext \u003d getParent();\n            //System.out.println(\"NAME \"+name);\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,42 +1,42 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+        if (name.equals(\"cloneNodes\")) {\n+            System.out.println(\"FOO\");\n+        }\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n-                        if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()){\n-                            System.out.println(\"FOO\");\n-                        }\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() \u003d\u003d wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext \u003d getParent();\n             //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ae290f6f5e0c7ba62eab797aba22308957b9257": {
      "type": "Ybodychange",
      "commitMessage": "consider method values of Enum\n",
      "commitDate": "2015-08-24, 3:37 p.m.",
      "commitName": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 2:56 p.m.",
      "commitNameOld": "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()){\n                            System.out.println(\"FOO\");\n                        }\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            Context parentContext \u003d getParent();\n            //System.out.println(\"NAME \"+name);\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,42 +1,42 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()){\n                             System.out.println(\"FOO\");\n                         }\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n-                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \"+name+\" with parameterTypes \"+parameterTypes);\n+                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\"+name+\"\u0027 with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() \u003d\u003d wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext \u003d getParent();\n             //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30": {
      "type": "Ybodychange",
      "commitMessage": "improving how the parent context is determined\n",
      "commitDate": "2015-08-24, 2:56 p.m.",
      "commitName": "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-24, 2:45 p.m.",
      "commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()){\n                            System.out.println(\"FOO\");\n                        }\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \"+name+\" with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            Context parentContext \u003d getParent();\n            //System.out.println(\"NAME \"+name);\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,39 +1,42 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n+                        if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()){\n+                            System.out.println(\"FOO\");\n+                        }\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         } else {\n                             throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \"+name+\" with parameterTypes \"+parameterTypes);\n                         }\n                     } else {\n                         throw e;\n                     }\n                 } else {\n                     throw e;\n                 }\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() \u003d\u003d wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext \u003d getParent();\n             //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": {
      "type": "Ybodychange",
      "commitMessage": "add test on switch on enum value\n",
      "commitDate": "2015-08-24, 12:29 p.m.",
      "commitName": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 6:34 a.m.",
      "commitNameOld": "46aefdd68f2f2597a19b72da36681123cb3090e6",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.25,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        } else {\n                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \"+name+\" with parameterTypes \"+parameterTypes);\n                        }\n                    } else {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            Context parentContext \u003d getParent();\n            //System.out.println(\"NAME \"+name);\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,34 +1,39 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                        } else {\n+                            throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \"+name+\" with parameterTypes \"+parameterTypes);\n                         }\n+                    } else {\n+                        throw e;\n                     }\n+                } else {\n+                    throw e;\n                 }\n-                throw e;\n             }\n         } else {\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                 MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                 if (parent.getScope() \u003d\u003d wrappedNode) {\n                     return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                 }\n             }\n             //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             Context parentContext \u003d getParent();\n             //System.out.println(\"NAME \"+name);\n             return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46aefdd68f2f2597a19b72da36681123cb3090e6": {
      "type": "Ybodychange",
      "commitMessage": "improve resolution of calls to static methods\n",
      "commitDate": "2015-08-23, 6:34 a.m.",
      "commitName": "46aefdd68f2f2597a19b72da36681123cb3090e6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 5:38 a.m.",
      "commitNameOld": "6c297529e31036058837adbaa57cee652d4cc918",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        }\n                    }\n                }\n                throw e;\n            }\n        } else {\n            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n                if (parent.getScope() \u003d\u003d wrappedNode) {\n                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n                }\n            }\n            //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            Context parentContext \u003d getParent();\n            //System.out.println(\"NAME \"+name);\n            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,26 +1,34 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         }\n                     }\n                 }\n                 throw e;\n             }\n         } else {\n+            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n+                MethodCallExpr parent \u003d (MethodCallExpr)wrappedNode.getParentNode();\n+                if (parent.getScope() \u003d\u003d wrappedNode) {\n+                    return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n+                }\n+            }\n             //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n-            return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            Context parentContext \u003d getParent();\n+            //System.out.println(\"NAME \"+name);\n+            return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c297529e31036058837adbaa57cee652d4cc918": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-23, 5:38 a.m.",
      "commitName": "6c297529e31036058837adbaa57cee652d4cc918",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 4:24 a.m.",
      "commitNameOld": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        }\n                    }\n                }\n                throw e;\n            }\n        } else {\n            //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,25 +1,26 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             try {\n                 TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                 return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n             } catch (UnsolvedSymbolException e){\n                 // ok, maybe it was instead a static access, so let\u0027s look for a type\n                 if (wrappedNode.getScope() instanceof NameExpr){\n                     String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                     SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                     if (ref.isSolved()) {\n                         SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                         if (m.isSolved()) {\n                             return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                         }\n                     }\n                 }\n                 throw e;\n             }\n         } else {\n-            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            //TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            //return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b2a0b366461674aa6320b11a38a17909d8a74a3": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-23, 4:24 a.m.",
      "commitName": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-23, 3:50 a.m.",
      "commitNameOld": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            try {\n                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n            } catch (UnsolvedSymbolException e){\n                // ok, maybe it was instead a static access, so let\u0027s look for a type\n                if (wrappedNode.getScope() instanceof NameExpr){\n                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                    if (ref.isSolved()) {\n                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                        if (m.isSolved()) {\n                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                        }\n                    }\n                }\n                throw e;\n            }\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,10 +1,25 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n-            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            try {\n+                TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            } catch (UnsolvedSymbolException e){\n+                // ok, maybe it was instead a static access, so let\u0027s look for a type\n+                if (wrappedNode.getScope() instanceof NameExpr){\n+                    String className \u003d ((NameExpr)wrappedNode.getScope()).getName();\n+                    SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+                    if (ref.isSolved()) {\n+                        SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n+                        if (m.isSolved()) {\n+                            return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                        }\n+                    }\n+                }\n+                throw e;\n+            }\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-23, 3:50 a.m.",
      "commitName": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-19, 5:58 a.m.",
      "commitNameOld": "c1e95efcb4b0a373530aa107edb2164bf6c21ac7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.91,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        // TODO consider call of static methods\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 35,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,9 +1,10 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+        // TODO consider call of static methods\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } else {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015-08-17, 12:43 p.m.",
      "commitName": "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-17, 12:43 p.m.",
      "commitNameOld": "d393205e2ee874242b73e4fe819d1bc874587d8a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } else {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 35,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,9 +1,9 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } else {\n-            throw new UnsupportedOperationException();\n-            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731": {
      "type": "Ybodychange",
      "commitMessage": "playing with passing the invokation context\n",
      "commitDate": "2015-08-14, 11:16 a.m.",
      "commitName": "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-05, 10:25 a.m.",
      "commitNameOld": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 9.04,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } else {\n            throw new UnsupportedOperationException();\n            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 26,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,9 +1,9 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } else {\n             throw new UnsupportedOperationException();\n             //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "627b56302d259409e9bc50b20d77803484f18b5c": {
      "type": "Ybodychange",
      "commitMessage": "introduce cache in JavaParserFacade\n",
      "commitDate": "2015-08-05, 10:25 a.m.",
      "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015-08-05, 9:30 a.m.",
      "commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        } else {\n            throw new UnsupportedOperationException();\n            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 26,
      "functionName": "solveMethodAsUsage",
      "diff": "@@ -1,9 +1,9 @@\n     public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() !\u003d null) {\n-            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n         } else {\n             throw new UnsupportedOperationException();\n             //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606": {
      "type": "Yintroduced",
      "commitMessage": "fix resolveReferenceToMethodWithLambda\n",
      "commitDate": "2015-08-05, 9:30 a.m.",
      "commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,9 @@\n+    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+        if (wrappedNode.getScope() !\u003d null) {\n+            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+        } else {\n+            throw new UnsupportedOperationException();\n+            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n        if (wrappedNode.getScope() !\u003d null) {\n            TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n        } else {\n            throw new UnsupportedOperationException();\n            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n        }\n    }",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 26,
      "functionName": "solveMethodAsUsage"
    }
  }
}