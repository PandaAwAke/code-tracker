{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "H:\\Projects\\apache\\commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "DateUtils.java",
  "functionName": "modify",
  "functionId": "modify___val-Calendar(modifiers-final)__field-int(modifiers-final)__modType-ModifyType(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
  "functionStartLine": 958,
  "functionEndLine": 1096,
  "numCommitsSeen": 222,
  "timeTaken": 4530,
  "changeHistory": [
    "b610707cd072f07efb816074a4844bb1b31e482c",
    "35f1cc00274122c0274b522d0b544a06faaba931",
    "52e854e3bda9f1b92471884888f430345f73eca2",
    "d6a556dad71a7d785b9c40608d0bf56062b134a5",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "14373ad1b11e5dc3a26457647ddee4e8ada97430",
    "fab64bbdc726cf06c5993b7b8f50557882086002",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
    "a6a2d04877d91a4c7cfff889bb64e2627ca60994",
    "db5c7106a44107b94332ee6844514b003f538a51",
    "050fe8e916507c9716983868284d64e58c1b56d2",
    "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61",
    "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d",
    "4a453bd132aa147607c14a036d23fc1fe524006f",
    "d19d4a852154ef1d38a842d88c34cac6505e5f01",
    "0c40162c2feef6cd17a553a5506666e1f43a7380",
    "c4df48e565253ed75b1a3070b1f01f1d58087a1f",
    "402c8e0846d5ad865226a7488c4bbc803e685719",
    "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
    "9c4166dbb25e1a0b53e0d776cddc9feececccc78",
    "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5"
  ],
  "changeHistoryShort": {
    "b610707cd072f07efb816074a4844bb1b31e482c": "Ybodychange",
    "35f1cc00274122c0274b522d0b544a06faaba931": "Ybodychange",
    "52e854e3bda9f1b92471884888f430345f73eca2": "Ymultichange(Yparameterchange,Ybodychange)",
    "d6a556dad71a7d785b9c40608d0bf56062b134a5": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "14373ad1b11e5dc3a26457647ddee4e8ada97430": "Ybodychange",
    "fab64bbdc726cf06c5993b7b8f50557882086002": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6": "Ymultichange(Yparameterchange,Ybodychange)",
    "a6a2d04877d91a4c7cfff889bb64e2627ca60994": "Ybodychange",
    "db5c7106a44107b94332ee6844514b003f538a51": "Ybodychange",
    "050fe8e916507c9716983868284d64e58c1b56d2": "Ybodychange",
    "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61": "Ybodychange",
    "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d": "Ybodychange",
    "4a453bd132aa147607c14a036d23fc1fe524006f": "Ybodychange",
    "d19d4a852154ef1d38a842d88c34cac6505e5f01": "Ybodychange",
    "0c40162c2feef6cd17a553a5506666e1f43a7380": "Ybodychange",
    "c4df48e565253ed75b1a3070b1f01f1d58087a1f": "Ybodychange",
    "402c8e0846d5ad865226a7488c4bbc803e685719": "Ybodychange",
    "73ee6c3d270a91bd447f732b24c4d65169b0c8d6": "Ymultichange(Ymovefromfile,Ybodychange)",
    "9c4166dbb25e1a0b53e0d776cddc9feececccc78": "Yfilerename",
    "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b610707cd072f07efb816074a4844bb1b31e482c": {
      "type": "Ybodychange",
      "commitMessage": "removes unnecessary class reference of static method calls which are declared in the same class\n",
      "commitDate": "2018-06-20, 7:28 a.m.",
      "commitName": "b610707cd072f07efb816074a4844bb1b31e482c",
      "commitAuthor": "Igor Curdvanovschi",
      "commitDateOld": "2017-06-06, 4:14 p.m.",
      "commitNameOld": "309b34f0573d0ec593c17008e8ef4151dfc35a12",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 378.63,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(final Calendar val, final int field, final ModifyType modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n\n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        final Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        final int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        final int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        final int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (final int[] aField : fields) {\n            for (final int element : aField) {\n                if (element \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d ModifyType.CEILING || modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            if (!offsetSet) {\n                final int min \u003d val.getActualMinimum(aField[0]);\n                final int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 958,
      "functionName": "modify",
      "diff": "@@ -1,139 +1,139 @@\n     private static void modify(final Calendar val, final int field, final ModifyType modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         final int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         final int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         final int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (modType \u003d\u003d ModifyType.CEILING || modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp) {\n-                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n+                        if (field \u003d\u003d SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n-                case DateUtils.SEMI_MONTH:\n+                case SEMI_MONTH:\n                     if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 default:\n                     break;\n             }\n             if (!offsetSet) {\n                 final int min \u003d val.getActualMinimum(aField[0]);\n                 final int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35f1cc00274122c0274b522d0b544a06faaba931": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Useless parentheses\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671675 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015-04-06, 3:48 p.m.",
      "commitName": "35f1cc00274122c0274b522d0b544a06faaba931",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014-09-27, 1:33 p.m.",
      "commitNameOld": "2aae22de23bf47566700c0ca2671d25e30c4a857",
      "commitAuthorOld": "Duncan Jones",
      "daysBetweenCommits": 191.09,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(final Calendar val, final int field, final ModifyType modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        final Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        final int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        final int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        final int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (final int[] aField : fields) {\n            for (final int element : aField) {\n                if (element \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d ModifyType.CEILING || modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            if (!offsetSet) {\n                final int min \u003d val.getActualMinimum(aField[0]);\n                final int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 967,
      "functionName": "modify",
      "diff": "@@ -1,139 +1,139 @@\n     private static void modify(final Calendar val, final int field, final ModifyType modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         final int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         final int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         final int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element \u003d\u003d field) {\n                     //This is our field... we stop looping\n-                    if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n+                    if (modType \u003d\u003d ModifyType.CEILING || modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 default:\n                     break;\n             }\n             if (!offsetSet) {\n                 final int min \u003d val.getActualMinimum(aField[0]);\n                 final int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "52e854e3bda9f1b92471884888f430345f73eca2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-09-27, 11:03 a.m.",
      "commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
      "commitAuthor": "Duncan Jones",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2014-09-27, 11:03 a.m.",
          "commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
          "commitAuthor": "Duncan Jones",
          "commitDateOld": "2014-09-26, 7:19 a.m.",
          "commitNameOld": "bdb1a684a7b3876d6812d4e281c852face5a5229",
          "commitAuthorOld": "Duncan Jones",
          "daysBetweenCommits": 1.16,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static void modify(final Calendar val, final int field, final ModifyType modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        final Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        final int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        final int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        final int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (final int[] aField : fields) {\n            for (final int element : aField) {\n                if (element \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            if (!offsetSet) {\n                final int min \u003d val.getActualMinimum(aField[0]);\n                final int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
          "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
          "functionStartLine": 967,
          "functionName": "modify",
          "diff": "@@ -1,139 +1,139 @@\n-    private static void modify(final Calendar val, final int field, final int modType) {\n+    private static void modify(final Calendar val, final int field, final ModifyType modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         final int millisecs \u003d val.get(Calendar.MILLISECOND);\n-        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n+        if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         final int seconds \u003d val.get(Calendar.SECOND);\n-        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n+        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         final int minutes \u003d val.get(Calendar.MINUTE);\n-        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n+        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element \u003d\u003d field) {\n                     //This is our field... we stop looping\n-                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n+                    if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 default:\n                     break;\n             }\n             if (!offsetSet) {\n                 final int min \u003d val.getActualMinimum(aField[0]);\n                 final int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-int(modifiers-final)]",
            "newValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-ModifyType(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2014-09-27, 11:03 a.m.",
          "commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
          "commitAuthor": "Duncan Jones",
          "commitDateOld": "2014-09-26, 7:19 a.m.",
          "commitNameOld": "bdb1a684a7b3876d6812d4e281c852face5a5229",
          "commitAuthorOld": "Duncan Jones",
          "daysBetweenCommits": 1.16,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static void modify(final Calendar val, final int field, final ModifyType modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        final Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        final int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        final int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        final int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (final int[] aField : fields) {\n            for (final int element : aField) {\n                if (element \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            if (!offsetSet) {\n                final int min \u003d val.getActualMinimum(aField[0]);\n                final int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
          "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
          "functionStartLine": 967,
          "functionName": "modify",
          "diff": "@@ -1,139 +1,139 @@\n-    private static void modify(final Calendar val, final int field, final int modType) {\n+    private static void modify(final Calendar val, final int field, final ModifyType modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         final int millisecs \u003d val.get(Calendar.MILLISECOND);\n-        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n+        if (ModifyType.TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         final int seconds \u003d val.get(Calendar.SECOND);\n-        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n+        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         final int minutes \u003d val.get(Calendar.MINUTE);\n-        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n+        if (!done \u0026\u0026 (ModifyType.TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element \u003d\u003d field) {\n                     //This is our field... we stop looping\n-                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n+                    if (modType \u003d\u003d ModifyType.CEILING || (modType \u003d\u003d ModifyType.ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 default:\n                     break;\n             }\n             if (!offsetSet) {\n                 final int min \u003d val.getActualMinimum(aField[0]);\n                 final int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d6a556dad71a7d785b9c40608d0bf56062b134a5": {
      "type": "Ybodychange",
      "commitMessage": "Add explict default case\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1565257 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-02-06, 8:51 a.m.",
      "commitName": "d6a556dad71a7d785b9c40608d0bf56062b134a5",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014-01-20, 12:19 p.m.",
      "commitNameOld": "0942ef04f1fa911d382b79a92dca1dd4b3eb88e6",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 16.86,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(final Calendar val, final int field, final int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        final Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        final int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        final int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        final int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (final int[] aField : fields) {\n            for (final int element : aField) {\n                if (element \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            if (!offsetSet) {\n                final int min \u003d val.getActualMinimum(aField[0]);\n                final int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 956,
      "functionName": "modify",
      "diff": "@@ -1,137 +1,139 @@\n     private static void modify(final Calendar val, final int field, final int modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         final int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         final int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         final int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n+                default:\n+                    break;\n             }\n             if (!offsetSet) {\n                 final int min \u003d val.getActualMinimum(aField[0]);\n                 final int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:09 a.m.",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013-01-22, 2:07 a.m.",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(final Calendar val, final int field, final int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        final Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        final int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        final int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        final int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (final int[] aField : fields) {\n            for (final int element : aField) {\n                if (element \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                final int min \u003d val.getActualMinimum(aField[0]);\n                final int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 956,
      "functionName": "modify",
      "diff": "@@ -1,137 +1,137 @@\n     private static void modify(final Calendar val, final int field, final int modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n-        Date date \u003d val.getTime();\n+        final Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n-        int millisecs \u003d val.get(Calendar.MILLISECOND);\n+        final int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n-        int seconds \u003d val.get(Calendar.SECOND);\n+        final int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n-        int minutes \u003d val.get(Calendar.MINUTE);\n+        final int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n-        for (int[] aField : fields) {\n-            for (int element : aField) {\n+        for (final int[] aField : fields) {\n+            for (final int element : aField) {\n                 if (element \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n-                int min \u003d val.getActualMinimum(aField[0]);\n-                int max \u003d val.getActualMaximum(aField[0]);\n+                final int min \u003d val.getActualMinimum(aField[0]);\n+                final int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:07 a.m.",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012-09-22, 9:22 a.m.",
      "commitNameOld": "ebdef1b95710b44324d40fa1e67a1bc1b370ee81",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 121.74,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(final Calendar val, final int field, final int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int[] aField : fields) {\n            for (int element : aField) {\n                if (element \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(aField[0]);\n                int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 956,
      "functionName": "modify",
      "diff": "@@ -1,137 +1,137 @@\n-    private static void modify(Calendar val, int field, int modType) {\n+    private static void modify(final Calendar val, final int field, final int modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (int[] aField : fields) {\n             for (int element : aField) {\n                 if (element \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(aField[0]);\n                 int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[val-Calendar, field-int, modType-int]",
        "newValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-int(modifiers-final)]"
      }
    },
    "14373ad1b11e5dc3a26457647ddee4e8ada97430": {
      "type": "Ybodychange",
      "commitMessage": "Convert to Java 5 enhanced for loops. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1144992 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-07-10, 8:49 p.m.",
      "commitName": "14373ad1b11e5dc3a26457647ddee4e8ada97430",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011-07-10, 2:26 p.m.",
      "commitNameOld": "fab64bbdc726cf06c5993b7b8f50557882086002",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int[] aField : fields) {\n            for (int element : aField) {\n                if (element \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(aField[0]);\n                int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 902,
      "functionName": "modify",
      "diff": "@@ -1,137 +1,137 @@\n     private static void modify(Calendar val, int field, int modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (int[] aField : fields) {\n-            for (int j \u003d 0; j \u003c aField.length; j++) {\n-                if (aField[j] \u003d\u003d field) {\n+            for (int element : aField) {\n+                if (element \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(aField[0]);\n                 int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fab64bbdc726cf06c5993b7b8f50557882086002": {
      "type": "Ybodychange",
      "commitMessage": "Convert to Java 5 enhanced loops. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1144929 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-07-10, 2:26 p.m.",
      "commitName": "fab64bbdc726cf06c5993b7b8f50557882086002",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011-04-12, 11:18 a.m.",
      "commitNameOld": "47132a3fcc7ba92e2f8028ac5261c03fcf94d67b",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 89.13,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int[] aField : fields) {\n            for (int j \u003d 0; j \u003c aField.length; j++) {\n                if (aField[j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(aField[0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(aField[0]);\n                int max \u003d val.getActualMaximum(aField[0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(aField[0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(aField[0], val.get(aField[0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 902,
      "functionName": "modify",
      "diff": "@@ -1,137 +1,137 @@\n     private static void modify(Calendar val, int field, int modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n-        for (int i \u003d 0; i \u003c fields.length; i++) {\n-            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n-                if (fields[i][j] \u003d\u003d field) {\n+        for (int[] aField : fields) {\n+            for (int j \u003d 0; j \u003c aField.length; j++) {\n+                if (aField[j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n-                            val.add(fields[i][0], 1);\n+                            val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n-                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n+                    if (aField[0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n-                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n+                    if (aField[0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n-                int min \u003d val.getActualMinimum(fields[i][0]);\n-                int max \u003d val.getActualMaximum(fields[i][0]);\n+                int min \u003d val.getActualMinimum(aField[0]);\n+                int max \u003d val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n-                offset \u003d val.get(fields[i][0]) - min;\n+                offset \u003d val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n-                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+                val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-01-02, 9:11 p.m.",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010-01-02, 9:09 p.m.",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 911,
      "functionName": "modify",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/time/DateUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/time/DateUtils.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-10, 6:33 a.m.",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-12-10, 6:31 a.m.",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang3/time/DateUtils.java",
      "functionStartLine": 869,
      "functionName": "modify",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/time/DateUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/time/DateUtils.java"
      }
    },
    "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Applying Robert Scholte\u0027s patch to Travis Reeder\u0027s request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-07-19, 3:21 p.m.",
      "commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
      "commitAuthor": "Henri Yandell",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Applying Robert Scholte\u0027s patch to Travis Reeder\u0027s request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009-07-19, 3:21 p.m.",
          "commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2009-03-15, 10:11 p.m.",
          "commitNameOld": "950def5b6f5fa146ea6035229f3751f224981f5e",
          "commitAuthorOld": "Sebastian Bazley",
          "daysBetweenCommits": 125.71,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 869,
          "functionName": "modify",
          "diff": "@@ -1,137 +1,137 @@\n-    private static void modify(Calendar val, int field, boolean round) {\n+    private static void modify(Calendar val, int field, int modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         int millisecs \u003d val.get(Calendar.MILLISECOND);\n-        if (!round || millisecs \u003c 500) {\n+        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         int seconds \u003d val.get(Calendar.SECOND);\n-        if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n+        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         int minutes \u003d val.get(Calendar.MINUTE);\n-        if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n+        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n-                    if (round \u0026\u0026 roundUp) {\n+                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[val-Calendar, field-int, round-boolean]",
            "newValue": "[val-Calendar, field-int, modType-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Applying Robert Scholte\u0027s patch to Travis Reeder\u0027s request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009-07-19, 3:21 p.m.",
          "commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2009-03-15, 10:11 p.m.",
          "commitNameOld": "950def5b6f5fa146ea6035229f3751f224981f5e",
          "commitAuthorOld": "Sebastian Bazley",
          "daysBetweenCommits": 125.71,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 869,
          "functionName": "modify",
          "diff": "@@ -1,137 +1,137 @@\n-    private static void modify(Calendar val, int field, boolean round) {\n+    private static void modify(Calendar val, int field, int modType) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         int millisecs \u003d val.get(Calendar.MILLISECOND);\n-        if (!round || millisecs \u003c 500) {\n+        if (MODIFY_TRUNCATE \u003d\u003d modType || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         int seconds \u003d val.get(Calendar.SECOND);\n-        if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n+        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         int minutes \u003d val.get(Calendar.MINUTE);\n-        if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n+        if (!done \u0026\u0026 (MODIFY_TRUNCATE \u003d\u003d modType || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n-                    if (round \u0026\u0026 roundUp) {\n+                    if (modType \u003d\u003d MODIFY_CEILING || (modType \u003d\u003d MODIFY_ROUND \u0026\u0026 roundUp)) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a6a2d04877d91a4c7cfff889bb64e2627ca60994": {
      "type": "Ybodychange",
      "commitMessage": "Applying Robert Scholte\u0027s excellent unit tests from LANG-443 and his second patch from LANG-440 fixing a discovered boundary case for AM_PM in round\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@711616 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2008-11-05, 12:00 p.m.",
      "commitName": "a6a2d04877d91a4c7cfff889bb64e2627ca60994",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2008-06-09, 3:17 a.m.",
      "commitNameOld": "db5c7106a44107b94332ee6844514b003f538a51",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 149.41,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (!round || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e\u003d 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 766,
      "functionName": "modify",
      "diff": "@@ -1,137 +1,137 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (!round || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field \u003d\u003d Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n-                        roundUp \u003d offset \u003e 6;\n+                        roundUp \u003d offset \u003e\u003d 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "db5c7106a44107b94332ee6844514b003f538a51": {
      "type": "Ybodychange",
      "commitMessage": "Applying Robert Scholte\u0027s fix for LANG-440, replicating the SEMI_MONTH logic for AM_PM requests\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@664643 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2008-06-09, 3:17 a.m.",
      "commitName": "db5c7106a44107b94332ee6844514b003f538a51",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2008-03-05, 7:58 p.m.",
      "commitNameOld": "8e83403ba9a34a2b2540d274c176f025d1ec9f1e",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 95.26,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (!round || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field \u003d\u003d Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 766,
      "functionName": "modify",
      "diff": "@@ -1,125 +1,137 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (!round || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n         }\n         if (field \u003d\u003d Calendar.SECOND) {\n             done \u003d true;\n         }\n \n         // truncate seconds\n         int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n         }\n         if (field \u003d\u003d Calendar.MINUTE) {\n             done \u003d true;\n         }\n \n         // truncate minutes\n         int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n+// ----------------- Fix for LANG-440 ---------------------- START ---------------\n+                        } else if (field \u003d\u003d Calendar.AM_PM) {\n+                            // This is a special case\n+                            // If the time is 0, we round up to 12, otherwise\n+                            //  we subtract 12 hours and add 1 day\n+                            if (val.get(Calendar.HOUR_OF_DAY) \u003d\u003d 0) {\n+                                val.add(Calendar.HOUR_OF_DAY, 12);\n+                            } else {\n+                                val.add(Calendar.HOUR_OF_DAY, -12);\n+                                val.add(Calendar.DATE, 1);\n+                            }\n+// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "050fe8e916507c9716983868284d64e58c1b56d2": {
      "type": "Ybodychange",
      "commitMessage": "Applying the fix and the test patches from LANG-346 - fixes bugs in DateUtils.round() for minutes and seconds. Patch from Dave Meikle\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@564053 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2007-08-08, 8:24 p.m.",
      "commitName": "050fe8e916507c9716983868284d64e58c1b56d2",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-08-28, 2:21 a.m.",
      "commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 345.75,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (!round || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n        }\n        if (field \u003d\u003d Calendar.SECOND) {\n            done \u003d true;\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n        }\n        if (field \u003d\u003d Calendar.MINUTE) {\n            done \u003d true;\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 620,
      "functionName": "modify",
      "diff": "@@ -1,125 +1,125 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field \u003d\u003d Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date \u003d val.getTime();\n         long time \u003d date.getTime();\n         boolean done \u003d false;\n \n         // truncate milliseconds\n         int millisecs \u003d val.get(Calendar.MILLISECOND);\n         if (!round || millisecs \u003c 500) {\n             time \u003d time - millisecs;\n-            if (field \u003d\u003d Calendar.SECOND) {\n-                done \u003d true;\n-            }\n+        }\n+        if (field \u003d\u003d Calendar.SECOND) {\n+            done \u003d true;\n         }\n \n         // truncate seconds\n         int seconds \u003d val.get(Calendar.SECOND);\n         if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n             time \u003d time - (seconds * 1000L);\n-            if (field \u003d\u003d Calendar.MINUTE) {\n-                done \u003d true;\n-            }\n+        }\n+        if (field \u003d\u003d Calendar.MINUTE) {\n+            done \u003d true;\n         }\n \n         // truncate minutes\n         int minutes \u003d val.get(Calendar.MINUTE);\n         if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n             time \u003d time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() !\u003d time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset !\u003d 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61": {
      "type": "Ybodychange",
      "commitMessage": "Adding Niall\u0027s fix for LANG-59 - an edge case in date truncation - and his enhancement \nfor the unit test that was there. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@424192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-07-21, 1:47 a.m.",
      "commitName": "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-07-05, 7:49 p.m.",
      "commitNameOld": "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 15.25,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field \u003d\u003d Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date \u003d val.getTime();\n        long time \u003d date.getTime();\n        boolean done \u003d false;\n\n        // truncate milliseconds\n        int millisecs \u003d val.get(Calendar.MILLISECOND);\n        if (!round || millisecs \u003c 500) {\n            time \u003d time - millisecs;\n            if (field \u003d\u003d Calendar.SECOND) {\n                done \u003d true;\n            }\n        }\n\n        // truncate seconds\n        int seconds \u003d val.get(Calendar.SECOND);\n        if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n            time \u003d time - (seconds * 1000L);\n            if (field \u003d\u003d Calendar.MINUTE) {\n                done \u003d true;\n            }\n        }\n\n        // truncate minutes\n        int minutes \u003d val.get(Calendar.MINUTE);\n        if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n            time \u003d time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() !\u003d time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset !\u003d 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 619,
      "functionName": "modify",
      "diff": "@@ -1,78 +1,125 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n+        if (field \u003d\u003d Calendar.MILLISECOND) {\n+            return;\n+        }\n+\n+        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n+        // see http://issues.apache.org/jira/browse/LANG-59\n+        //\n+        // Manually truncate milliseconds, seconds and minutes, rather than using\n+        // Calendar methods.\n+\n+        Date date \u003d val.getTime();\n+        long time \u003d date.getTime();\n+        boolean done \u003d false;\n+\n+        // truncate milliseconds\n+        int millisecs \u003d val.get(Calendar.MILLISECOND);\n+        if (!round || millisecs \u003c 500) {\n+            time \u003d time - millisecs;\n+            if (field \u003d\u003d Calendar.SECOND) {\n+                done \u003d true;\n+            }\n+        }\n+\n+        // truncate seconds\n+        int seconds \u003d val.get(Calendar.SECOND);\n+        if (!done \u0026\u0026 (!round || seconds \u003c 30)) {\n+            time \u003d time - (seconds * 1000L);\n+            if (field \u003d\u003d Calendar.MINUTE) {\n+                done \u003d true;\n+            }\n+        }\n+\n+        // truncate minutes\n+        int minutes \u003d val.get(Calendar.MINUTE);\n+        if (!done \u0026\u0026 (!round || minutes \u003c 30)) {\n+            time \u003d time - (minutes * 60000L);\n+        }\n+\n+        // reset time\n+        if (date.getTime() !\u003d time) {\n+            date.setTime(time);\n+            val.setTime(date);\n+        }\n+        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n+\n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n-            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            if (offset !\u003d 0) {\n+                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d": {
      "type": "Ybodychange",
      "commitMessage": "Remove debugging code\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@419387 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-07-05, 7:49 p.m.",
      "commitName": "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2006-07-05, 2:14 a.m.",
      "commitNameOld": "4a453bd132aa147607c14a036d23fc1fe524006f",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 619,
      "functionName": "modify",
      "diff": "@@ -1,79 +1,78 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n-System.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a453bd132aa147607c14a036d23fc1fe524006f": {
      "type": "Ybodychange",
      "commitMessage": "Minor style fixes suggested by checkstyle\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@419174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-07-05, 2:14 a.m.",
      "commitName": "4a453bd132aa147607c14a036d23fc1fe524006f",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-04-16, 4:55 p.m.",
      "commitNameOld": "12491a6801249b2a582a231b1a40e17b401cc413",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 79.39,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\nSystem.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n            //We need to remove this field\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 619,
      "functionName": "modify",
      "diff": "@@ -1,78 +1,79 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) \u003e 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n+System.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d19d4a852154ef1d38a842d88c34cac6505e5f01": {
      "type": "Ybodychange",
      "commitMessage": "Fix DateUtils.truncate oddity at the far end of the Date spectrum\nbug 31395, from Marc Portier\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137984 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004-10-16, 1:43 p.m.",
      "commitName": "d19d4a852154ef1d38a842d88c34cac6505e5f01",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2004-10-16, 1:08 p.m.",
      "commitNameOld": "61cccd3e0a4cc51c0956ca90310c8b76d4f6fdeb",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) \u003e 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 444,
      "functionName": "modify",
      "diff": "@@ -1,74 +1,78 @@\n     private static void modify(Calendar val, int field, boolean round) {\n+        if (val.get(Calendar.YEAR) \u003e 280000000) {\n+            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n+        }\n+        \n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c40162c2feef6cd17a553a5506666e1f43a7380": {
      "type": "Ybodychange",
      "commitMessage": "corrected calendar field used to calculate the offset when modifying the hour for a round or truncated based on AM_PM\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137881 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004-07-11, 8:04 p.m.",
      "commitName": "0c40162c2feef6cd17a553a5506666e1f43a7380",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2004-07-11, 2:40 p.m.",
      "commitNameOld": "946ba1293b91a73461d7f3db02a99881bed2147b",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 322,
      "functionName": "modify",
      "diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n-                    if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n+                    if (fields[i][0] \u003d\u003d Calendar.HOUR_OF_DAY) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n-                        offset \u003d val.get(Calendar.HOUR);\n+                        offset \u003d val.get(Calendar.HOUR_OF_DAY);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c4df48e565253ed75b1a3070b1f01f1d58087a1f": {
      "type": "Ybodychange",
      "commitMessage": "changed modify method to calculate the field offset and use the set method, rather than adding the offset and letting Calendar perform the calculation - this fixes http://issues.apache.org/bugzilla/show_bug.cgi?id\u003d25560;\nupdated javadocs on round method to explain how rounding across daylight saving time is handled\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137866 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004-07-05, 1:54 p.m.",
      "commitName": "c4df48e565253ed75b1a3070b1f01f1d58087a1f",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2004-06-27, 2:29 a.m.",
      "commitNameOld": "5f7e26a978322dd6d09459ecdbefb7a389a86652",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 8.48,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 322,
      "functionName": "modify",
      "diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n-            val.add(fields[i][0], -offset);\n+            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "402c8e0846d5ad865226a7488c4bbc803e685719": {
      "type": "Ybodychange",
      "commitMessage": "Prepare DateUtils for 2.0 release\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137375 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-06-23, 7:41 p.m.",
      "commitName": "402c8e0846d5ad865226a7488c4bbc803e685719",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2003-06-08, 7:14 p.m.",
      "commitNameOld": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 15.02,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.add(fields[i][0], -offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
      "functionStartLine": 312,
      "functionName": "modify",
      "diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n                         if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.add(fields[i][0], -offset);\n         }\n-        throw new RuntimeException(\"We do not support that field.\");\n+        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "73ee6c3d270a91bd447f732b24c4d65169b0c8d6": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-06-08, 7:14 p.m.",
      "commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003-06-08, 7:14 p.m.",
          "commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003-06-08, 10:19 a.m.",
          "commitNameOld": "9bb3f9b9a3e513cbac7f02d6ee97995d741d09de",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.37,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.add(fields[i][0], -offset);\n        }\n        throw new RuntimeException(\"We do not support that field.\");\n\n    }",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 227,
          "functionName": "modify",
          "diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n-                        if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n+                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n-                case CalendarUtils.SEMI_MONTH:\n+                case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.add(fields[i][0], -offset);\n         }\n         throw new RuntimeException(\"We do not support that field.\");\n \n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/java/org/apache/commons/lang/time/CalendarUtils.java",
            "newPath": "src/java/org/apache/commons/lang/time/DateUtils.java",
            "oldMethodName": "modify",
            "newMethodName": "modify"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003-06-08, 7:14 p.m.",
          "commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003-06-08, 10:19 a.m.",
          "commitNameOld": "9bb3f9b9a3e513cbac7f02d6ee97995d741d09de",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.37,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.add(fields[i][0], -offset);\n        }\n        throw new RuntimeException(\"We do not support that field.\");\n\n    }",
          "path": "src/java/org/apache/commons/lang/time/DateUtils.java",
          "functionStartLine": 227,
          "functionName": "modify",
          "diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp \u003d false;\n         for (int i \u003d 0; i \u003c fields.length; i++) {\n             for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                 if (fields[i][j] \u003d\u003d field) {\n                     //This is our field... we stop looping\n                     if (round \u0026\u0026 roundUp) {\n-                        if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n+                        if (field \u003d\u003d DateUtils.SEMI_MONTH) {\n                             //This is a special case that\u0027s hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset \u003d 0;\n             boolean offsetSet \u003d false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n-                case CalendarUtils.SEMI_MONTH:\n+                case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                         //If we\u0027re going to drop the DATE field\u0027s value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset \u003d val.get(Calendar.DATE) - 1;\n                         //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset \u003e\u003d 15) {\n                             offset -\u003d 15;\n                         }\n                         //Record whether we\u0027re in the top or bottom half of that range\n                         roundUp \u003d offset \u003e 7;\n                         offsetSet \u003d true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                         //If we\u0027re going to drop the HOUR field\u0027s value,\n                         //  we want to do this our own way.\n                         offset \u003d val.get(Calendar.HOUR);\n                         if (offset \u003e\u003d 12) {\n                             offset -\u003d 12;\n                         }\n                         roundUp \u003d offset \u003e 6;\n                         offsetSet \u003d true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min \u003d val.getActualMinimum(fields[i][0]);\n                 int max \u003d val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset \u003d val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp \u003d offset \u003e ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.add(fields[i][0], -offset);\n         }\n         throw new RuntimeException(\"We do not support that field.\");\n \n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "9c4166dbb25e1a0b53e0d776cddc9feececccc78": {
      "type": "Yfilerename",
      "commitMessage": "Create time subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137194 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2002-12-18, 6:30 p.m.",
      "commitName": "9c4166dbb25e1a0b53e0d776cddc9feececccc78",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2002-12-18, 6:28 p.m.",
      "commitNameOld": "55feeb72b96de4da9cc3535762ddf6b9d04209f7",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case CalendarUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.add(fields[i][0], -offset);\n        }\n        throw new RuntimeException(\"We do not support that field.\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/time/CalendarUtils.java",
      "functionStartLine": 195,
      "functionName": "modify",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/CalendarUtils.java",
        "newPath": "src/java/org/apache/commons/lang/time/CalendarUtils.java"
      }
    },
    "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5": {
      "type": "Yintroduced",
      "commitMessage": "CalendarUtils from the sandbox, for merger with DateUtils. Or parallel living.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137190 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2002-12-16, 4:55 p.m.",
      "commitName": "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,74 @@\n+    private static void modify(Calendar val, int field, boolean round) {\n+        boolean roundUp \u003d false;\n+        for (int i \u003d 0; i \u003c fields.length; i++) {\n+            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n+                if (fields[i][j] \u003d\u003d field) {\n+                    //This is our field... we stop looping\n+                    if (round \u0026\u0026 roundUp) {\n+                        if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n+                            //This is a special case that\u0027s hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(fields[i][0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset \u003d 0;\n+            boolean offsetSet \u003d false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case CalendarUtils.SEMI_MONTH:\n+                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n+                        //If we\u0027re going to drop the DATE field\u0027s value,\n+                        //  we want to do this our own way.\n+                        //We need to subtrace 1 since the date has a minimum of 1\n+                        offset \u003d val.get(Calendar.DATE) - 1;\n+                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset \u003e\u003d 15) {\n+                            offset -\u003d 15;\n+                        }\n+                        //Record whether we\u0027re in the top or bottom half of that range\n+                        roundUp \u003d offset \u003e 7;\n+                        offsetSet \u003d true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n+                        //If we\u0027re going to drop the HOUR field\u0027s value,\n+                        //  we want to do this our own way.\n+                        offset \u003d val.get(Calendar.HOUR);\n+                        if (offset \u003e\u003d 12) {\n+                            offset -\u003d 12;\n+                        }\n+                        roundUp \u003d offset \u003e 6;\n+                        offsetSet \u003d true;\n+                    }\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                int min \u003d val.getActualMinimum(fields[i][0]);\n+                int max \u003d val.getActualMaximum(fields[i][0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset \u003d val.get(fields[i][0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp \u003d offset \u003e ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            val.add(fields[i][0], -offset);\n+        }\n+        throw new RuntimeException(\"We do not support that field.\");\n+\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private static void modify(Calendar val, int field, boolean round) {\n        boolean roundUp \u003d false;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            for (int j \u003d 0; j \u003c fields[i].length; j++) {\n                if (fields[i][j] \u003d\u003d field) {\n                    //This is our field... we stop looping\n                    if (round \u0026\u0026 roundUp) {\n                        if (field \u003d\u003d CalendarUtils.SEMI_MONTH) {\n                            //This is a special case that\u0027s hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) \u003d\u003d 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset \u003d 0;\n            boolean offsetSet \u003d false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case CalendarUtils.SEMI_MONTH:\n                    if (fields[i][0] \u003d\u003d Calendar.DATE) {\n                        //If we\u0027re going to drop the DATE field\u0027s value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset \u003d val.get(Calendar.DATE) - 1;\n                        //If we\u0027re above 15 days adjustment, that means we\u0027re in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset \u003e\u003d 15) {\n                            offset -\u003d 15;\n                        }\n                        //Record whether we\u0027re in the top or bottom half of that range\n                        roundUp \u003d offset \u003e 7;\n                        offsetSet \u003d true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] \u003d\u003d Calendar.HOUR) {\n                        //If we\u0027re going to drop the HOUR field\u0027s value,\n                        //  we want to do this our own way.\n                        offset \u003d val.get(Calendar.HOUR);\n                        if (offset \u003e\u003d 12) {\n                            offset -\u003d 12;\n                        }\n                        roundUp \u003d offset \u003e 6;\n                        offsetSet \u003d true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min \u003d val.getActualMinimum(fields[i][0]);\n                int max \u003d val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset \u003d val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp \u003d offset \u003e ((max - min) / 2);\n            }\n            //We need to remove this field\n            val.add(fields[i][0], -offset);\n        }\n        throw new RuntimeException(\"We do not support that field.\");\n\n    }",
      "path": "src/java/org/apache/commons/lang/CalendarUtils.java",
      "functionStartLine": 195,
      "functionName": "modify"
    }
  }
}