{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "H:\\Projects\\hibernate\\hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "CollectionBinder.java",
  "functionName": "bind",
  "functionId": "bind",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
  "functionStartLine": 386,
  "functionEndLine": 552,
  "numCommitsSeen": 94,
  "timeTaken": 6106,
  "changeHistory": [
    "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83",
    "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
    "1e44e7420b7af10adc9547a461f02a6d979624f1",
    "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8",
    "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050",
    "1361925bc73a539bd6bd5d4a93de162e4a5b332b",
    "9caca0ce37d5a2763d476c6fa2471addcca710ca",
    "bcd6185809ecf9202267134d646037e8acdd0939",
    "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5",
    "05c36793730fb1b4e3d08c731998c7649c9b34ef",
    "d7d9f0dfb207cb8238ea2962fee81708942fa368",
    "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
    "fb44ad936d8d54d311ecbaea1633683a8d809d04",
    "ddfcc44d760938578771cb6ce24c809c980c8b8b",
    "4ffba763cf6645e722a2deeea552f998ec7dc22a",
    "e18799b03611ef8dc37690585de984f63b35bc34",
    "8c806d361d63764e8523006944dde52aff70532c",
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
    "7419fc298dab9afe82fbdbb8b64854fa37f60817",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
    "8577a68e69d30d9e671024bf3330616000a3ec54",
    "b1f925458eeb636897bf8a053712ed25fff39054",
    "e44b5f197d77e1d1a847cd04eaa0d25254362483",
    "658df91a5e308fd1d97cec62acf6110143012592",
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
    "c7c6981a558e35f01ff8d27938e98aa83896765c",
    "20d22941c0e07b37295704d5300a7071e48e640d",
    "11668ca67c916595d2789787e37b3ed1affc1aa8",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e",
    "7337743c93574823424ed6c399cfcf6bd75614f8"
  ],
  "changeHistoryShort": {
    "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83": "Ybodychange",
    "7c2a58861341f1404b4974f1ed9809f40c1da8f6": "Ybodychange",
    "1e44e7420b7af10adc9547a461f02a6d979624f1": "Ybodychange",
    "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8": "Ybodychange",
    "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050": "Ybodychange",
    "1361925bc73a539bd6bd5d4a93de162e4a5b332b": "Ybodychange",
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": "Ybodychange",
    "bcd6185809ecf9202267134d646037e8acdd0939": "Ybodychange",
    "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5": "Ybodychange",
    "05c36793730fb1b4e3d08c731998c7649c9b34ef": "Ybodychange",
    "d7d9f0dfb207cb8238ea2962fee81708942fa368": "Ybodychange",
    "ffb14b28b72c67dc2d658bfeb89545ca16eb3399": "Ybodychange",
    "fb44ad936d8d54d311ecbaea1633683a8d809d04": "Ybodychange",
    "ddfcc44d760938578771cb6ce24c809c980c8b8b": "Ybodychange",
    "4ffba763cf6645e722a2deeea552f998ec7dc22a": "Ybodychange",
    "e18799b03611ef8dc37690585de984f63b35bc34": "Ybodychange",
    "8c806d361d63764e8523006944dde52aff70532c": "Ybodychange",
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": "Ybodychange",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": "Ybodychange",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": "Yfilerename",
    "7419fc298dab9afe82fbdbb8b64854fa37f60817": "Ybodychange",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": "Yfilerename",
    "8577a68e69d30d9e671024bf3330616000a3ec54": "Ybodychange",
    "b1f925458eeb636897bf8a053712ed25fff39054": "Ybodychange",
    "e44b5f197d77e1d1a847cd04eaa0d25254362483": "Ybodychange",
    "658df91a5e308fd1d97cec62acf6110143012592": "Ybodychange",
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09": "Ybodychange",
    "c7c6981a558e35f01ff8d27938e98aa83896765c": "Ybodychange",
    "20d22941c0e07b37295704d5300a7071e48e640d": "Ybodychange",
    "11668ca67c916595d2789787e37b3ed1affc1aa8": "Ybodychange",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": "Yfilerename",
    "7337743c93574823424ed6c399cfcf6bd75614f8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12122 - Checking @OrderBy for special cases should perform case-insensitive checking\n",
      "commitDate": "2017-12-13, 7:19 a.m.",
      "commitName": "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2017-09-18, 5:03 a.m.",
      "commitNameOld": "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
      "commitAuthorOld": "Alexey Nesterov",
      "daysBetweenCommits": 86.14,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tif (!isMappedBy\n\t\t\t\t\u0026\u0026 oneToMany\n\t\t\t\t\u0026\u0026 property.isAnnotationPresent( OnDelete.class )\n\t\t\t\t\u0026\u0026 !property.isAnnotationPresent( JoinColumn.class )) {\n\t\t\tString message \u003d \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns,\n\t\t\t\tmapKeyManyToManyColumns,\n\t\t\t\tisEmbedded,\n\t\t\t\tproperty,\n\t\t\t\tcollectionType,\n\t\t\t\tignoreNotFound,\n\t\t\t\toneToMany,\n\t\t\t\ttableBinder,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.contains( \"delete-orphan\" ) ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setLazy( collection.isLazy() );\n\t\tfinal LazyGroup lazyGroupAnnotation \u003d property.getAnnotation( LazyGroup.class );\n\t\tif ( lazyGroupAnnotation !\u003d null ) {\n\t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 386,
      "functionName": "bind",
      "diff": "@@ -1,167 +1,167 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tif (!isMappedBy\n \t\t\t\t\u0026\u0026 oneToMany\n \t\t\t\t\u0026\u0026 property.isAnnotationPresent( OnDelete.class )\n \t\t\t\t\u0026\u0026 !property.isAnnotationPresent( JoinColumn.class )) {\n \t\t\tString message \u003d \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n-\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n+\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.contains( \"delete-orphan\" ) ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setLazy( collection.isLazy() );\n \t\tfinal LazyGroup lazyGroupAnnotation \u003d property.getAnnotation( LazyGroup.class );\n \t\tif ( lazyGroupAnnotation !\u003d null ) {\n \t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c2a58861341f1404b4974f1ed9809f40c1da8f6": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6382: Allow to use @OnDelete annotation on unidirectional @OneToMany associations\n",
      "commitDate": "2017-09-18, 5:03 a.m.",
      "commitName": "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
      "commitAuthor": "Alexey Nesterov",
      "commitDateOld": "2017-08-01, 4:13 a.m.",
      "commitNameOld": "47f8a679907789dd68f13cfd81a6c6caf232a81b",
      "commitAuthorOld": "Bogdan Stirbat",
      "daysBetweenCommits": 48.03,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tif (!isMappedBy\n\t\t\t\t\u0026\u0026 oneToMany\n\t\t\t\t\u0026\u0026 property.isAnnotationPresent( OnDelete.class )\n\t\t\t\t\u0026\u0026 !property.isAnnotationPresent( JoinColumn.class )) {\n\t\t\tString message \u003d \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns,\n\t\t\t\tmapKeyManyToManyColumns,\n\t\t\t\tisEmbedded,\n\t\t\t\tproperty,\n\t\t\t\tcollectionType,\n\t\t\t\tignoreNotFound,\n\t\t\t\toneToMany,\n\t\t\t\ttableBinder,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setLazy( collection.isLazy() );\n\t\tfinal LazyGroup lazyGroupAnnotation \u003d property.getAnnotation( LazyGroup.class );\n\t\tif ( lazyGroupAnnotation !\u003d null ) {\n\t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 386,
      "functionName": "bind",
      "diff": "@@ -1,158 +1,167 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n+\t\tif (!isMappedBy\n+\t\t\t\t\u0026\u0026 oneToMany\n+\t\t\t\t\u0026\u0026 property.isAnnotationPresent( OnDelete.class )\n+\t\t\t\t\u0026\u0026 !property.isAnnotationPresent( JoinColumn.class )) {\n+\t\t\tString message \u003d \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n+\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n+\t\t\tthrow new AnnotationException( message );\n+\t\t}\n+\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setLazy( collection.isLazy() );\n \t\tfinal LazyGroup lazyGroupAnnotation \u003d property.getAnnotation( LazyGroup.class );\n \t\tif ( lazyGroupAnnotation !\u003d null ) {\n \t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e44e7420b7af10adc9547a461f02a6d979624f1": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10267 - Support defining lazy attribute fetch groups\n",
      "commitDate": "2015-11-16, 4:43 p.m.",
      "commitName": "1e44e7420b7af10adc9547a461f02a6d979624f1",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015-10-06, 5:07 p.m.",
      "commitNameOld": "0cf66b85e03a997dc94f8f82598ca8edac04e889",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 41.02,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns,\n\t\t\t\tmapKeyManyToManyColumns,\n\t\t\t\tisEmbedded,\n\t\t\t\tproperty,\n\t\t\t\tcollectionType,\n\t\t\t\tignoreNotFound,\n\t\t\t\toneToMany,\n\t\t\t\ttableBinder,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setLazy( collection.isLazy() );\n\t\tfinal LazyGroup lazyGroupAnnotation \u003d property.getAnnotation( LazyGroup.class );\n\t\tif ( lazyGroupAnnotation !\u003d null ) {\n\t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 384,
      "functionName": "bind",
      "diff": "@@ -1,154 +1,158 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setLazy( collection.isLazy() );\n+\t\tfinal LazyGroup lazyGroupAnnotation \u003d property.getAnnotation( LazyGroup.class );\n+\t\tif ( lazyGroupAnnotation !\u003d null ) {\n+\t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n+\t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10073 Not propagating XML node names configured in mappings\n",
      "commitDate": "2015-09-01, 12:34 p.m.",
      "commitName": "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8",
      "commitAuthor": "Gunnar Morling",
      "commitDateOld": "2015-07-16, 4:05 a.m.",
      "commitNameOld": "e4781feb7423c1bc74f1c43d6665c9a0d1730e31",
      "commitAuthorOld": "Gunnar Morling",
      "daysBetweenCommits": 47.35,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns,\n\t\t\t\tmapKeyManyToManyColumns,\n\t\t\t\tisEmbedded,\n\t\t\t\tproperty,\n\t\t\t\tcollectionType,\n\t\t\t\tignoreNotFound,\n\t\t\t\toneToMany,\n\t\t\t\ttableBinder,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setLazy( collection.isLazy() );\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 383,
      "functionName": "bind",
      "diff": "@@ -1,155 +1,154 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n-\t\tcollection.setNodeName( propertyName );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setLazy( collection.isLazy() );\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8558 - Bytecode enhancer: lazy loading support\n",
      "commitDate": "2015-07-06, 2:34 p.m.",
      "commitName": "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050",
      "commitAuthor": "barreiro",
      "commitDateOld": "2015-05-19, 12:25 a.m.",
      "commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 48.59,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setNodeName( propertyName );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns,\n\t\t\t\tmapKeyManyToManyColumns,\n\t\t\t\tisEmbedded,\n\t\t\t\tproperty,\n\t\t\t\tcollectionType,\n\t\t\t\tignoreNotFound,\n\t\t\t\toneToMany,\n\t\t\t\ttableBinder,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setLazy( collection.isLazy() );\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 383,
      "functionName": "bind",
      "diff": "@@ -1,154 +1,155 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n+\t\tbinder.setLazy( collection.isLazy() );\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1361925bc73a539bd6bd5d4a93de162e4a5b332b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9722\n\nChanged all toLowerCase() and toUpperCase() to toLowerCase(Locale.ROOT),\ntoUpperCase(Locale.ROOT).\n",
      "commitDate": "2015-04-17, 3:53 p.m.",
      "commitName": "1361925bc73a539bd6bd5d4a93de162e4a5b332b",
      "commitAuthor": "10urshin",
      "commitDateOld": "2015-04-02, 6:02 p.m.",
      "commitNameOld": "22ca7125f74621c09f7c2eedbc399160ce2755d5",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 14.91,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setNodeName( propertyName );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns,\n\t\t\t\tmapKeyManyToManyColumns,\n\t\t\t\tisEmbedded,\n\t\t\t\tproperty,\n\t\t\t\tcollectionType,\n\t\t\t\tignoreNotFound,\n\t\t\t\toneToMany,\n\t\t\t\ttableBinder,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 400,
      "functionName": "bind",
      "diff": "@@ -1,154 +1,154 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
      "commitDate": "2015-03-10, 5:53 p.m.",
      "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2014-10-21, 1:18 a.m.",
      "commitNameOld": "1cba98022ec0ccb30f6a68547c050663daf51a96",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 140.69,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setNodeName( propertyName );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns,\n\t\t\t\tmapKeyManyToManyColumns,\n\t\t\t\tisEmbedded,\n\t\t\t\tproperty,\n\t\t\t\tcollectionType,\n\t\t\t\tignoreNotFound,\n\t\t\t\toneToMany,\n\t\t\t\ttableBinder,\n\t\t\t\tbuildingContext\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 397,
      "functionName": "bind",
      "diff": "@@ -1,149 +1,154 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n-\t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n+\t\t\tfinal TypeDefinition typeDef \u003d buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n+\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n-\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n+\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n-\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n-\t\t\t\tproperty, collectionType,\n-\t\t\t\tignoreNotFound, oneToMany,\n-\t\t\t\ttableBinder, mappings\n+\t\t\t\tmapKeyColumns,\n+\t\t\t\tmapKeyManyToManyColumns,\n+\t\t\t\tisEmbedded,\n+\t\t\t\tproperty,\n+\t\t\t\tcollectionType,\n+\t\t\t\tignoreNotFound,\n+\t\t\t\toneToMany,\n+\t\t\t\ttableBinder,\n+\t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n-\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n+\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n-\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n+\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n-\t\tmappings.addCollection( collection );\n+\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bcd6185809ecf9202267134d646037e8acdd0939": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4910 The collection cache is evicted if a related collection element is inserted, removed or updated\n\nHHH-4910 minor fixes\n\nHHH-4910 make this feature configurable\n",
      "commitDate": "2013-09-18, 12:26 p.m.",
      "commitName": "bcd6185809ecf9202267134d646037e8acdd0939",
      "commitAuthor": "Andy2003",
      "commitDateOld": "2013-09-06, 2:38 p.m.",
      "commitNameOld": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 11.91,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setNodeName( propertyName );\n\t\tcollection.setMappedByProperty( mappedBy );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 395,
      "functionName": "bind",
      "diff": "@@ -1,148 +1,149 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n+\t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8164 - Deprecate @Sort in favor of @SortNatural and @SortComparator\n",
      "commitDate": "2013-04-10, 5:25 p.m.",
      "commitName": "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012-10-29, 11:37 a.m.",
      "commitNameOld": "eae079d283683497d50861c78d0d84b765255105",
      "commitAuthorOld": "brmeyer",
      "daysBetweenCommits": 163.24,
      "commitsBetweenForRepo": 348,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\tapplySortingAndOrdering( collection );\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 395,
      "functionName": "bind",
      "diff": "@@ -1,182 +1,148 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n-\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n-\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n-\t\t\t);\n-\t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n-\t\t// set ordering\n-\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n-\t\tif ( isSorted ) {\n-\t\t\tcollection.setSorted( true );\n-\t\t\tif ( comparator !\u003d null ) {\n-\t\t\t\ttry {\n-\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n-\t\t\t\t}\n-\t\t\t\tcatch (ClassCastException e) {\n-\t\t\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n-\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n-\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse {\n-\t\t\tif ( hasToBeSorted ) {\n-\t\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n-\t\t\t\t\t\t\t\t+ safeCollectionRole()\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n+\t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "05c36793730fb1b4e3d08c731998c7649c9b34ef": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7138 - Hibernate implements JPA @OneToMany collection versioning incorrectly\n",
      "commitDate": "2012-03-07, 9:40 p.m.",
      "commitName": "05c36793730fb1b4e3d08c731998c7649c9b34ef",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012-03-05, 11:24 a.m.",
      "commitNameOld": "36c135ab6619cc56af293060c0216e924e16b187",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 2.43,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n\t\t\t\t? ! lockAnn.excluded()\n\t\t\t\t: ! isMappedBy;\n\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 399,
      "functionName": "bind",
      "diff": "@@ -1,178 +1,182 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType !\u003d null ) {\n \t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n \t\t\tif ( typeDef \u003d\u003d null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n-\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n-\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n+\n+\t\t//work on association\n+\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n+\n+\t\tfinal OptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n+\t\tfinal boolean includeInOptimisticLockChecks \u003d ( lockAnn !\u003d null )\n+\t\t\t\t? ! lockAnn.excluded()\n+\t\t\t\t: ! isMappedBy;\n+\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n-\t\t//work on association\n-\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n-\n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d7d9f0dfb207cb8238ea2962fee81708942fa368": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4417 - Add annotation support for UserCollectionType\n",
      "commitDate": "2012-03-02, 2:17 p.m.",
      "commitName": "d7d9f0dfb207cb8238ea2962fee81708942fa368",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011-10-26, 6:24 p.m.",
      "commitNameOld": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "commitAuthorOld": "Sanne Grinovero",
      "daysBetweenCommits": 127.87,
      "commitsBetweenForRepo": 349,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\tLOG.debugf( \"Collection role: %s\", role );\n\t\tcollection.setRole( role );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// set explicit type information\n\t\tif ( explicitType !\u003d null ) {\n\t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n\t\t\tif ( typeDef \u003d\u003d null ) {\n\t\t\t\tcollection.setTypeName( explicitType );\n\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n\t\t\t}\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 388,
      "functionName": "bind",
      "diff": "@@ -1,165 +1,178 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tString role \u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n+\t\t// set explicit type information\n+\t\tif ( explicitType !\u003d null ) {\n+\t\t\tfinal TypeDef typeDef \u003d mappings.getTypeDef( explicitType );\n+\t\t\tif ( typeDef \u003d\u003d null ) {\n+\t\t\t\tcollection.setTypeName( explicitType );\n+\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n+\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n+\t\t\t}\n+\t\t}\n+\n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ffb14b28b72c67dc2d658bfeb89545ca16eb3399": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6368 remove deprecated hibernate annotations\n",
      "commitDate": "2011-06-28, 4:29 a.m.",
      "commitName": "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2011-05-04, 6:15 p.m.",
      "commitNameOld": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 54.43,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n        String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        LOG.debugf(\"Collection role: %s\", role);\n        collection.setRole(role);\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 371,
      "functionName": "bind",
      "diff": "@@ -1,167 +1,165 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n         String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         LOG.debugf(\"Collection role: %s\", role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n-\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n-\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n+\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n-\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb44ad936d8d54d311ecbaea1633683a8d809d04": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6196 - Split org.hibernate.engine package into api/spi/internal\n",
      "commitDate": "2011-05-04, 6:15 p.m.",
      "commitName": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011-04-12, 10:07 a.m.",
      "commitNameOld": "ad17f89c4c29f0327c843cf5265e156d65743ab1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 22.34,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n        String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        LOG.debugf(\"Collection role: %s\", role);\n        collection.setRole(role);\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 372,
      "functionName": "bind",
      "diff": "@@ -1,167 +1,167 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n         String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         LOG.debugf(\"Collection role: %s\", role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ddfcc44d760938578771cb6ce24c809c980c8b8b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5916 - Add support for a programmatic way to define a default EntityPersister and CollectionPersister class implementation\n",
      "commitDate": "2011-03-04, 4:37 p.m.",
      "commitName": "ddfcc44d760938578771cb6ce24c809c980c8b8b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011-02-14, 1:20 p.m.",
      "commitNameOld": "e18799b03611ef8dc37690585de984f63b35bc34",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 18.14,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 374,
      "functionName": "bind",
      "diff": "@@ -1,178 +1,166 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \n-\t\t//@Persister has priority over PersisterClassProvider\n-\t\t//if all fail, left null and Hibernate defaults kick in\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n-\t\telse {\n-\t\t\tfinal PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n-\t\t\tif (persisterClassProvider !\u003d null) {\n-\t\t\t\tfinal Class\u003c? extends CollectionPersister\u003e persister \u003d\n-\t\t\t\t\t\tpersisterClassProvider.getCollectionPersisterClass( collection.getRole() );\n-\t\t\t\tif (persister !\u003d null) {\n-\t\t\t\t\tcollection.setCollectionPersisterClass( persister );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4ffba763cf6645e722a2deeea552f998ec7dc22a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5916 Use PersisterClassProvider in Binders\n",
      "commitDate": "2011-02-23, 4:33 p.m.",
      "commitName": "4ffba763cf6645e722a2deeea552f998ec7dc22a",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2011-02-08, 2:55 p.m.",
      "commitNameOld": "8c806d361d63764e8523006944dde52aff70532c",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 15.07,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n        String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        LOG.debugf(\"Collection role: %s\", role);\n        collection.setRole(role);\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\n\t\t//@Persister has priority over PersisterClassProvider\n\t\t//if all fail, left null and Hibernate defaults kick in\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\t\telse {\n\t\t\tfinal PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n\t\t\tif (persisterClassProvider !\u003d null) {\n\t\t\t\tfinal Class\u003c? extends CollectionPersister\u003e persister \u003d\n\t\t\t\t\t\tpersisterClassProvider.getCollectionPersisterClass( collection.getRole() );\n\t\t\t\tif (persister !\u003d null) {\n\t\t\t\t\tcollection.setCollectionPersisterClass( persister );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 372,
      "functionName": "bind",
      "diff": "@@ -1,164 +1,179 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n         String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         LOG.debugf(\"Collection role: %s\", role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n+\n+\t\t//@Persister has priority over PersisterClassProvider\n+\t\t//if all fail, left null and Hibernate defaults kick in\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n-\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n+\t\tif ( persisterAnn !\u003d null ) {\n+\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n+\t\t}\n+\t\telse {\n+\t\t\tfinal PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n+\t\t\tif (persisterClassProvider !\u003d null) {\n+\t\t\t\tfinal Class\u003c? extends CollectionPersister\u003e persister \u003d\n+\t\t\t\t\t\tpersisterClassProvider.getCollectionPersisterClass( collection.getRole() );\n+\t\t\t\tif (persister !\u003d null) {\n+\t\t\t\t\tcollection.setCollectionPersisterClass( persister );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e18799b03611ef8dc37690585de984f63b35bc34": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5916 Use PersisterClassProvider in Binders\n",
      "commitDate": "2011-02-14, 1:20 p.m.",
      "commitName": "e18799b03611ef8dc37690585de984f63b35bc34",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-10-11, 3:41 p.m.",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 125.94,
      "commitsBetweenForRepo": 229,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\n\t\t//@Persister has priority over PersisterClassProvider\n\t\t//if all fail, left null and Hibernate defaults kick in\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) {\n\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n\t\t}\n\t\telse {\n\t\t\tfinal PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n\t\t\tif (persisterClassProvider !\u003d null) {\n\t\t\t\tfinal Class\u003c? extends CollectionPersister\u003e persister \u003d\n\t\t\t\t\t\tpersisterClassProvider.getCollectionPersisterClass( collection.getRole() );\n\t\t\t\tif (persister !\u003d null) {\n\t\t\t\t\tcollection.setCollectionPersisterClass( persister );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 375,
      "functionName": "bind",
      "diff": "@@ -1,163 +1,178 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n+\n+\t\t//@Persister has priority over PersisterClassProvider\n+\t\t//if all fail, left null and Hibernate defaults kick in\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n-\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n+\t\tif ( persisterAnn !\u003d null ) {\n+\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n+\t\t}\n+\t\telse {\n+\t\t\tfinal PersisterClassProvider persisterClassProvider \u003d mappings.getPersisterClassProvider();\n+\t\t\tif (persisterClassProvider !\u003d null) {\n+\t\t\t\tfinal Class\u003c? extends CollectionPersister\u003e persister \u003d\n+\t\t\t\t\t\tpersisterClassProvider.getCollectionPersisterClass( collection.getRole() );\n+\t\t\t\tif (persister !\u003d null) {\n+\t\t\t\t\tcollection.setCollectionPersisterClass( persister );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c806d361d63764e8523006944dde52aff70532c": {
      "type": "Ybodychange",
      "commitMessage": "Changes from requests at Hibernate meeting: message codes, use XXXf methods for debug and trace, use @Cause\n",
      "commitDate": "2011-02-08, 2:55 p.m.",
      "commitName": "8c806d361d63764e8523006944dde52aff70532c",
      "commitAuthor": "JPAV",
      "commitDateOld": "2011-01-18, 5:00 p.m.",
      "commitNameOld": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 20.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n        String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        LOG.debugf(\"Collection role: %s\", role);\n        collection.setRole(role);\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 370,
      "functionName": "bind",
      "diff": "@@ -1,164 +1,164 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n         String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n-        LOG.debug(\"Collection role: \" + role);\n+        LOG.debugf(\"Collection role: %s\", role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": {
      "type": "Ybodychange",
      "commitMessage": "Give each project a single logger\n",
      "commitDate": "2011-01-18, 5:00 p.m.",
      "commitName": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "commitAuthor": "JPAV",
      "commitDateOld": "2011-01-18, 4:35 p.m.",
      "commitNameOld": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n        String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        LOG.debug(\"Collection role: \" + role);\n        collection.setRole(role);\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 371,
      "functionName": "bind",
      "diff": "@@ -1,164 +1,164 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n         String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n-        LOG.collectionRole(role);\n+        LOG.debug(\"Collection role: \" + role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": {
      "type": "Ybodychange",
      "commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n\u0027d where it was clear how to do so.\n",
      "commitDate": "2011-01-18, 4:35 p.m.",
      "commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthor": "JPAV",
      "commitDateOld": "2010-10-11, 3:41 p.m.",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 99.08,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n        String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n        LOG.collectionRole(role);\n        collection.setRole(role);\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 376,
      "functionName": "bind",
      "diff": "@@ -1,163 +1,164 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n-\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n-\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n+        String role \u003d StringHelper.qualify(propertyHolder.getPath(), propertyName);\n+        LOG.collectionRole(role);\n+        collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
      "commitDate": "2010-10-11, 3:41 p.m.",
      "commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-10-11, 2:51 p.m.",
      "commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 373,
      "functionName": "bind",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
      }
    },
    "7419fc298dab9afe82fbdbb8b64854fa37f60817": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5205 - Renamed BinderHelper.isDefault() to BinderHelper.isEmptyAnnotationValue() , because this describes better what the function does. Also renamed VersionTest to OptimisitcLockAnnotationTest to better describe what gets tested.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20741 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-09-28, 12:32 p.m.",
      "commitName": "7419fc298dab9afe82fbdbb8b64854fa37f60817",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010-08-12, 3:13 p.m.",
      "commitNameOld": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 46.89,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 373,
      "functionName": "bind",
      "diff": "@@ -1,163 +1,163 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n-\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n+\t\tboolean isMappedBy \u003d !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5367 - Move annotations module sources into core module\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19921 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-07-08, 7:41 p.m.",
      "commitName": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010-07-08, 1:32 p.m.",
      "commitNameOld": "cc3b41a09c983913594b16d6c909be0bfd41bd7a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 373,
      "functionName": "bind",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
        "newPath": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
      }
    },
    "8577a68e69d30d9e671024bf3330616000a3ec54": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4529 clean @Id/@EmbeddedId mapping and merge with the regular basic and component mapping to open possibilities for @Id @ManyToOne support\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18600 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-21, 12:51 p.m.",
      "commitName": "8577a68e69d30d9e671024bf3330616000a3ec54",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-01-12, 1:48 p.m.",
      "commitNameOld": "b1f925458eeb636897bf8a053712ed25fff39054",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 8.96,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.makeProperty();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 367,
      "functionName": "bind",
      "diff": "@@ -1,163 +1,163 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n-\t\tProperty prop \u003d binder.make();\n+\t\tProperty prop \u003d binder.makeProperty();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b1f925458eeb636897bf8a053712ed25fff39054": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4782 supports @AssociationOverride.joinTable\nHHH-4679 add tests for dot notations in @AssocuiationOverride\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18518 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-12, 1:48 p.m.",
      "commitName": "b1f925458eeb636897bf8a053712ed25fff39054",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-01-08, 11:58 a.m.",
      "commitNameOld": "e44b5f197d77e1d1a847cd04eaa0d25254362483",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 4.08,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 367,
      "functionName": "bind",
      "diff": "@@ -1,163 +1,163 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n-\t\t\t\t\t|| property.isAnnotationPresent( JoinTable.class ) ) ) {\n+\t\t\t\t\t|| propertyHolder.getJoinTable( property ) !\u003d null ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.make();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e44b5f197d77e1d1a847cd04eaa0d25254362483": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4771 @ElementCollection fk column should default to entityName_columnNameOfOwningId\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18455 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-08, 11:58 a.m.",
      "commitName": "e44b5f197d77e1d1a847cd04eaa0d25254362483",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-01-07, 12:41 p.m.",
      "commitNameOld": "9ef2317e28887cf48d8fb96775b24ec832386d3f",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinTable.class ) ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 367,
      "functionName": "bind",
      "diff": "@@ -1,162 +1,163 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n+\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinTable.class ) ) ) {\n \t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.make();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "658df91a5e308fd1d97cec62acf6110143012592": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4283 fix the incorrect test case and add a proper exception when the user error occurs\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18421 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010-01-06, 12:28 p.m.",
      "commitName": "658df91a5e308fd1d97cec62acf6110143012592",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010-01-06, 11:59 a.m.",
      "commitNameOld": "71d9459a20c4f769a205b70537fe416bd992e76e",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\n\t\tif (isMappedBy\n\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n\t\t\t\t\t|| property.isAnnotationPresent( JoinTable.class ) ) ) {\n\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n\t\t\tthrow new AnnotationException( message );\n\t\t}\n\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 366,
      "functionName": "bind",
      "diff": "@@ -1,153 +1,162 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n+\n+\t\tif (isMappedBy\n+\t\t\t\t\u0026\u0026 (property.isAnnotationPresent( JoinColumn.class )\n+\t\t\t\t\t|| property.isAnnotationPresent( JoinTable.class ) ) ) {\n+\t\t\tString message \u003d \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n+\t\t\tmessage +\u003d StringHelper.qualify( propertyHolder.getPath(), propertyName );\n+\t\t\tthrow new AnnotationException( message );\n+\t\t}\n+\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n-\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n+\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.make();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09": {
      "type": "Ybodychange",
      "commitMessage": " HHH-4527 - first cut for supporting JPA2 @Access annotation. Not quite complete and needs some more tests.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18260 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-12-17, 4:14 p.m.",
      "commitName": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2009-10-28, 2:14 p.m.",
      "commitNameOld": "c7c6981a558e35f01ff8d27938e98aa83896765c",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 50.12,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setAccessType( accessType );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 349,
      "functionName": "bind",
      "diff": "@@ -1,153 +1,153 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n-\t\tbinder.setPropertyAccessorName( propertyAccessorName );\n+\t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.make();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7c6981a558e35f01ff8d27938e98aa83896765c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4533 add representation for @MappedSuperclass in the Hibernate Core metamodel and properly populate this model extension in Hibernate Annotations\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17871 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-10-28, 2:14 p.m.",
      "commitName": "c7c6981a558e35f01ff8d27938e98aa83896765c",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009-07-22, 4:40 p.m.",
      "commitNameOld": "eeb136fa719fe007158d90ba011473ea7d1fa38b",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 97.9,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setPropertyAccessorName( propertyAccessorName );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n\t\tpropertyHolder.addProperty( prop, declaringClass );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 350,
      "functionName": "bind",
      "diff": "@@ -1,151 +1,153 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n+\t\tif ( inheritanceStatePerClass \u003d\u003d null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setPropertyAccessorName( propertyAccessorName );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.make();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n-\t\tpropertyHolder.addProperty( prop );\n+\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n+\t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "20d22941c0e07b37295704d5300a7071e48e640d": {
      "type": "Ybodychange",
      "commitMessage": "ANN-856 implement @MapKeyColumn\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17173 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-07-20, 10:07 p.m.",
      "commitName": "20d22941c0e07b37295704d5300a7071e48e640d",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009-05-07, 5:34 p.m.",
      "commitNameOld": "11668ca67c916595d2789787e37b3ed1affc1aa8",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 74.19,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setPropertyAccessorName( propertyAccessorName );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tpropertyHolder.addProperty( prop );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 335,
      "functionName": "bind",
      "diff": "@@ -1,149 +1,151 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n-\t\tif ( property.isAnnotationPresent( org.hibernate.annotations.MapKey.class ) \u0026\u0026 mapKeyPropertyName !\u003d null ) {\n+\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n+\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n+\t\t\t\u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \"\n+\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setPropertyAccessorName( propertyAccessorName );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.make();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tpropertyHolder.addProperty( prop );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "11668ca67c916595d2789787e37b3ed1affc1aa8": {
      "type": "Ybodychange",
      "commitMessage": "HHH-3906 EJB-436 ANN-830 Move to JPA 2 API as a dependency\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@16523 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009-05-07, 5:34 p.m.",
      "commitName": "11668ca67c916595d2789787e37b3ed1affc1aa8",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2008-10-28, 5:41 p.m.",
      "commitNameOld": "513c71de5c5c6fb65bbc2a191ab7a9e565e304d5",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 190.99,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( property.isAnnotationPresent( org.hibernate.annotations.MapKey.class ) \u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n\t\t\t\t) {\n\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setPropertyAccessorName( propertyAccessorName );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tpropertyHolder.addProperty( prop );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 334,
      "functionName": "bind",
      "diff": "@@ -1,147 +1,149 @@\n \tpublic void bind() {\n \t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( property.isAnnotationPresent( org.hibernate.annotations.MapKey.class ) \u0026\u0026 mapKeyPropertyName !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator !\u003d null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader \u003d property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert !\u003d null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate !\u003d null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete !\u003d null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll !\u003d null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader !\u003d null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder !\u003d null and oneToMany\n \t\tXClass collectionType \u003d getCollectionType();\n \t\tSecondPass sp \u003d getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n-\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) ) {\n+\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n+\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n+\t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder \u003d new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setPropertyAccessorName( propertyAccessorName );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop \u003d binder.make();\n \t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n \t\tpropertyHolder.addProperty( prop );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": {
      "type": "Yfilerename",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15418 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-28, 2:53 p.m.",
      "commitName": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2008-10-28, 2:52 p.m.",
      "commitNameOld": "c457f2b3258fc48ef4010a9e58cd2fc3baaca6cc",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( property.isAnnotationPresent( org.hibernate.annotations.MapKey.class ) \u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) ) {\n\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setPropertyAccessorName( propertyAccessorName );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tpropertyHolder.addProperty( prop );\n\t}",
      "path": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 310,
      "functionName": "bind",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/java/org/hibernate/cfg/annotations/CollectionBinder.java",
        "newPath": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
      }
    },
    "7337743c93574823424ed6c399cfcf6bd75614f8": {
      "type": "Yintroduced",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15415 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008-10-28, 2:41 p.m.",
      "commitName": "7337743c93574823424ed6c399cfcf6bd75614f8",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,147 @@\n+\tpublic void bind() {\n+\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n+\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n+\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n+\t\tcollection.setNodeName( propertyName );\n+\n+\t\tif ( property.isAnnotationPresent( org.hibernate.annotations.MapKey.class ) \u0026\u0026 mapKeyPropertyName !\u003d null ) {\n+\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \"\n+\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n+\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n+\t\t\t\t\t)\n+\t\t\t);\n+\t\t}\n+\n+\t\t//set laziness\n+\t\tdefineFetchingStrategy();\n+\t\tcollection.setBatchSize( batchSize );\n+\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n+\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n+\t\t\t);\n+\t\t}\n+\n+\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n+\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n+\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n+\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n+\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n+\n+\t\t// set ordering\n+\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n+\t\tif ( isSorted ) {\n+\t\t\tcollection.setSorted( true );\n+\t\t\tif ( comparator !\u003d null ) {\n+\t\t\t\ttry {\n+\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n+\t\t\t\t}\n+\t\t\t\tcatch (ClassCastException e) {\n+\t\t\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n+\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t\tcatch (Exception e) {\n+\t\t\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n+\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tif ( hasToBeSorted ) {\n+\t\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n+\t\t\t\t\t\t\t\t+ safeCollectionRole()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t}\n+\n+\t\t//set cache\n+\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n+\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n+\t\t\tcollection.setCacheRegionName( cacheRegionName );\n+\t\t}\n+\n+\t\t//SQL overriding\n+\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n+\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n+\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n+\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n+\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n+\t\tif ( sqlInsert !\u003d null ) {\n+\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n+\t\t\t);\n+\n+\t\t}\n+\t\tif ( sqlUpdate !\u003d null ) {\n+\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n+\t\t\t);\n+\t\t}\n+\t\tif ( sqlDelete !\u003d null ) {\n+\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n+\t\t\t);\n+\t\t}\n+\t\tif ( sqlDeleteAll !\u003d null ) {\n+\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n+\t\t\t);\n+\t\t}\n+\t\tif ( loader !\u003d null ) {\n+\t\t\tcollection.setLoaderName( loader.namedQuery() );\n+\t\t}\n+\n+\t\t//work on association\n+\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n+\t\tcollection.setInverse( isMappedBy );\n+\n+\t\t//many to many may need some second pass informations\n+\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n+\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n+\t\t}\n+\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n+\t\tXClass collectionType \u003d getCollectionType();\n+\t\tSecondPass sp \u003d getSecondPass(\n+\t\t\t\tfkJoinColumns,\n+\t\t\t\tjoinColumns,\n+\t\t\t\tinverseJoinColumns,\n+\t\t\t\telementColumns,\n+\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n+\t\t\t\tproperty, collectionType,\n+\t\t\t\tignoreNotFound, oneToMany,\n+\t\t\t\ttableBinder, mappings\n+\t\t);\n+\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n+\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) ) {\n+\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n+\t\t\t// and raise a ConcurrentModificationException\n+\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n+\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n+\t\t}\n+\t\telse {\n+\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n+\t\t}\n+\n+\t\tmappings.addCollection( collection );\n+\n+\t\t//property building\n+\t\tPropertyBinder binder \u003d new PropertyBinder();\n+\t\tbinder.setName( propertyName );\n+\t\tbinder.setValue( collection );\n+\t\tbinder.setCascade( cascadeStrategy );\n+\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n+\t\t\tcollection.setOrphanDelete( true );\n+\t\t}\n+\t\tbinder.setPropertyAccessorName( propertyAccessorName );\n+\t\tbinder.setProperty( property );\n+\t\tbinder.setInsertable( insertable );\n+\t\tbinder.setUpdatable( updatable );\n+\t\tProperty prop \u003d binder.make();\n+\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n+\t\tpropertyHolder.addProperty( prop );\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tpublic void bind() {\n\t\tthis.collection \u003d createCollection( propertyHolder.getPersistentClass() );\n\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n\t\tcollection.setNodeName( propertyName );\n\n\t\tif ( property.isAnnotationPresent( org.hibernate.annotations.MapKey.class ) \u0026\u0026 mapKeyPropertyName !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \"\n\t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n\t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//set laziness\n\t\tdefineFetchingStrategy();\n\t\tcollection.setBatchSize( batchSize );\n\t\tif ( orderBy !\u003d null \u0026\u0026 hqlOrderBy !\u003d null ) {\n\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n\t\t\t);\n\t\t}\n\n\t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n\t\tOptimisticLock lockAnn \u003d property.getAnnotation( OptimisticLock.class );\n\t\tif ( lockAnn !\u003d null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n\t\tPersister persisterAnn \u003d property.getAnnotation( Persister.class );\n\t\tif ( persisterAnn !\u003d null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n\n\t\t// set ordering\n\t\tif ( orderBy !\u003d null ) collection.setOrderBy( orderBy );\n\t\tif ( isSorted ) {\n\t\t\tcollection.setSorted( true );\n\t\t\tif ( comparator !\u003d null ) {\n\t\t\t\ttry {\n\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n\t\t\t\t}\n\t\t\t\tcatch (ClassCastException e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasToBeSorted ) {\n\t\t\t\tthrow new AnnotationException(\n\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n\t\t\t\t\t\t\t\t+ safeCollectionRole()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t//set cache\n\t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n\t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n\t\t\tcollection.setCacheRegionName( cacheRegionName );\n\t\t}\n\n\t\t//SQL overriding\n\t\tSQLInsert sqlInsert \u003d property.getAnnotation( SQLInsert.class );\n\t\tSQLUpdate sqlUpdate \u003d property.getAnnotation( SQLUpdate.class );\n\t\tSQLDelete sqlDelete \u003d property.getAnnotation( SQLDelete.class );\n\t\tSQLDeleteAll sqlDeleteAll \u003d property.getAnnotation( SQLDeleteAll.class );\n\t\tLoader loader \u003d property.getAnnotation( Loader.class );\n\t\tif ( sqlInsert !\u003d null ) {\n\t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n\t\t\t);\n\n\t\t}\n\t\tif ( sqlUpdate !\u003d null ) {\n\t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDelete !\u003d null ) {\n\t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( sqlDeleteAll !\u003d null ) {\n\t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n\t\t\t);\n\t\t}\n\t\tif ( loader !\u003d null ) {\n\t\t\tcollection.setLoaderName( loader.namedQuery() );\n\t\t}\n\n\t\t//work on association\n\t\tboolean isMappedBy \u003d !BinderHelper.isDefault( mappedBy );\n\t\tcollection.setInverse( isMappedBy );\n\n\t\t//many to many may need some second pass informations\n\t\tif ( !oneToMany \u0026\u0026 isMappedBy ) {\n\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n\t\t}\n\t\t//TODO reducce tableBinder !\u003d null and oneToMany\n\t\tXClass collectionType \u003d getCollectionType();\n\t\tSecondPass sp \u003d getSecondPass(\n\t\t\t\tfkJoinColumns,\n\t\t\t\tjoinColumns,\n\t\t\t\tinverseJoinColumns,\n\t\t\t\telementColumns,\n\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n\t\t\t\tproperty, collectionType,\n\t\t\t\tignoreNotFound, oneToMany,\n\t\t\t\ttableBinder, mappings\n\t\t);\n\t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) ) {\n\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n\t\t\t// and raise a ConcurrentModificationException\n\t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\t\telse {\n\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n\t\t}\n\n\t\tmappings.addCollection( collection );\n\n\t\t//property building\n\t\tPropertyBinder binder \u003d new PropertyBinder();\n\t\tbinder.setName( propertyName );\n\t\tbinder.setValue( collection );\n\t\tbinder.setCascade( cascadeStrategy );\n\t\tif ( cascadeStrategy !\u003d null \u0026\u0026 cascadeStrategy.indexOf( \"delete-orphan\" ) \u003e\u003d 0 ) {\n\t\t\tcollection.setOrphanDelete( true );\n\t\t}\n\t\tbinder.setPropertyAccessorName( propertyAccessorName );\n\t\tbinder.setProperty( property );\n\t\tbinder.setInsertable( insertable );\n\t\tbinder.setUpdatable( updatable );\n\t\tProperty prop \u003d binder.make();\n\t\t//we don\u0027t care about the join stuffs because the column is on the association table.\n\t\tpropertyHolder.addProperty( prop );\n\t}",
      "path": "annotations/src/java/org/hibernate/cfg/annotations/CollectionBinder.java",
      "functionStartLine": 310,
      "functionName": "bind"
    }
  }
}