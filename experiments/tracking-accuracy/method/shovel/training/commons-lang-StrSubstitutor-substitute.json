{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "H:\\Projects\\apache\\commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "StrSubstitutor.java",
  "functionName": "substitute",
  "functionId": "substitute___buf-StrBuilder(modifiers-final)__offset-int(modifiers-final)__length-int(modifiers-final)__priorVariables-List__String__",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
  "functionStartLine": 758,
  "functionEndLine": 892,
  "numCommitsSeen": 54,
  "timeTaken": 2124,
  "changeHistory": [
    "4f82195afdc4279c05826fc20f8642bfdaaafec3",
    "e55aaa5706f031df2e8d68bdf088604c79944246",
    "93b1808e523c252098139c37ee5b23324e855b4a",
    "1d97f23c08d8dbf889e976f9248d37173dbadb95",
    "abc5dda962fe00fba27f98807ca70439a37a3746",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "371e866442f46131cc38a9a5018e1703f52f9b60",
    "6f6eddbf3a41fa2838f062fee7724a69b86206df",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "654fb75d80a63fa551ced73c3b652f4120573590",
    "927e7361037fa495cafece987c1c7d54b7e8128b",
    "4bfa1f6cb94c368ffa4febc3a2236886ced2290f"
  ],
  "changeHistoryShort": {
    "4f82195afdc4279c05826fc20f8642bfdaaafec3": "Ybodychange",
    "e55aaa5706f031df2e8d68bdf088604c79944246": "Ybodychange",
    "93b1808e523c252098139c37ee5b23324e855b4a": "Ybodychange",
    "1d97f23c08d8dbf889e976f9248d37173dbadb95": "Ybodychange",
    "abc5dda962fe00fba27f98807ca70439a37a3746": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "371e866442f46131cc38a9a5018e1703f52f9b60": "Ybodychange",
    "6f6eddbf3a41fa2838f062fee7724a69b86206df": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "654fb75d80a63fa551ced73c3b652f4120573590": "Ymultichange(Yparameterchange,Ybodychange)",
    "927e7361037fa495cafece987c1c7d54b7e8128b": "Ybodychange",
    "4bfa1f6cb94c368ffa4febc3a2236886ced2290f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4f82195afdc4279c05826fc20f8642bfdaaafec3": {
      "type": "Ybodychange",
      "commitMessage": "Remove redundant type arguments.",
      "commitDate": "2016-10-23, 1:52 p.m.",
      "commitName": "4f82195afdc4279c05826fc20f8642bfdaaafec3",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": "2016-09-11, 10:07 a.m.",
      "commitNameOld": "ecf6de89ba1a6542c68194e95d14ea944b6c92b7",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 42.16,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n        final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n        final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n        final char escape \u003d getEscapeChar();\n        final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n\n        final boolean top \u003d priorVariables \u003d\u003d null;\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    if (preserveEscapes) {\n                        pos++;\n                        continue;\n                    }\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (substitutionInVariablesEnabled\n                                \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varNameExpr \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (substitutionInVariablesEnabled) {\n                                    final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                    substitute(bufName, 0, bufName.length());\n                                    varNameExpr \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                final int endPos \u003d pos;\n\n                                String varName \u003d varNameExpr;\n                                String varDefaultValue \u003d null;\n\n                                if (valueDelimMatcher !\u003d null) {\n                                    final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                    int valueDelimiterMatchLen \u003d 0;\n                                    for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                        // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                        if (!substitutionInVariablesEnabled\n                                                \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                            break;\n                                        }\n                                        if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                            varName \u003d varNameExpr.substring(0, i);\n                                            varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003c\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue \u003d\u003d null) {\n                                    varValue \u003d varDefaultValue;\n                                }\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    final int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + varLen - (endPos - startPos);\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            }\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 753,
      "functionName": "substitute",
      "diff": "@@ -1,135 +1,135 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n         final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n         final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n         final char escape \u003d getEscapeChar();\n         final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n         final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n \n         final boolean top \u003d priorVariables \u003d\u003d null;\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     if (preserveEscapes) {\n                         pos++;\n                         continue;\n                     }\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         if (substitutionInVariablesEnabled\n                                 \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) !\u003d 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos +\u003d endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount \u003d\u003d 0) {\n                                 String varNameExpr \u003d new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (substitutionInVariablesEnabled) {\n                                     final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n                                     varNameExpr \u003d bufName.toString();\n                                 }\n                                 pos +\u003d endMatchLen;\n                                 final int endPos \u003d pos;\n \n                                 String varName \u003d varNameExpr;\n                                 String varDefaultValue \u003d null;\n \n                                 if (valueDelimMatcher !\u003d null) {\n                                     final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                     int valueDelimiterMatchLen \u003d 0;\n                                     for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                         // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                         if (!substitutionInVariablesEnabled\n                                                 \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                             break;\n                                         }\n                                         if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                             varName \u003d varNameExpr.substring(0, i);\n                                             varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                             break;\n                                         }\n                                     }\n                                 }\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables \u003d\u003d null) {\n-                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n+                                    priorVariables \u003d new ArrayList\u003c\u003e();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue \u003d resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue \u003d\u003d null) {\n                                     varValue \u003d varDefaultValue;\n                                 }\n                                 if (varValue !\u003d null) {\n                                     // recursive replace\n                                     final int varLen \u003d varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered \u003d true;\n                                     int change \u003d substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change \u003d change\n                                             + varLen - (endPos - startPos);\n                                     pos +\u003d change;\n                                     bufEnd +\u003d change;\n                                     lengthChange +\u003d change;\n                                     chars \u003d buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             }\n                             nestedVarCount--;\n                             pos +\u003d endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e55aaa5706f031df2e8d68bdf088604c79944246": {
      "type": "Ybodychange",
      "commitMessage": "StrSubstitutor can preserve escapes\n\nStrSubstitutor can now optionally preserve the escape character for an\nescaped reference, which is useful when substitution takes place in\nmultiple phases and some references are intentionally unresolved.  Prior\nto this change, an unresolved reference `${a}` and an escaped reference\n`$${a}` may result in the same string `${a}`, making it impossible for\nan additional substitution phase to distinguish between escaped\nreferences and non-escaped references.\n",
      "commitDate": "2016-02-25, 8:02 p.m.",
      "commitName": "e55aaa5706f031df2e8d68bdf088604c79944246",
      "commitAuthor": "Samuel Karp",
      "commitDateOld": "2015-05-05, 3:12 p.m.",
      "commitNameOld": "740c0f95fbd99cb7c07bcf7c54bc077c3ab27bd1",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 296.24,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n        final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n        final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n        final char escape \u003d getEscapeChar();\n        final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n\n        final boolean top \u003d priorVariables \u003d\u003d null;\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    if (preserveEscapes) {\n                        pos++;\n                        continue;\n                    }\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (substitutionInVariablesEnabled\n                                \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varNameExpr \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (substitutionInVariablesEnabled) {\n                                    final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                    substitute(bufName, 0, bufName.length());\n                                    varNameExpr \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                final int endPos \u003d pos;\n\n                                String varName \u003d varNameExpr;\n                                String varDefaultValue \u003d null;\n\n                                if (valueDelimMatcher !\u003d null) {\n                                    final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                    int valueDelimiterMatchLen \u003d 0;\n                                    for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                        // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                        if (!substitutionInVariablesEnabled\n                                                \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                            break;\n                                        }\n                                        if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                            varName \u003d varNameExpr.substring(0, i);\n                                            varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue \u003d\u003d null) {\n                                    varValue \u003d varDefaultValue;\n                                }\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    final int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + varLen - (endPos - startPos);\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            }\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 753,
      "functionName": "substitute",
      "diff": "@@ -1,131 +1,135 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n         final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n         final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n         final char escape \u003d getEscapeChar();\n         final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n         final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n \n         final boolean top \u003d priorVariables \u003d\u003d null;\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n+                    if (preserveEscapes) {\n+                        pos++;\n+                        continue;\n+                    }\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         if (substitutionInVariablesEnabled\n                                 \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) !\u003d 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos +\u003d endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount \u003d\u003d 0) {\n                                 String varNameExpr \u003d new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (substitutionInVariablesEnabled) {\n                                     final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n                                     varNameExpr \u003d bufName.toString();\n                                 }\n                                 pos +\u003d endMatchLen;\n                                 final int endPos \u003d pos;\n \n                                 String varName \u003d varNameExpr;\n                                 String varDefaultValue \u003d null;\n \n                                 if (valueDelimMatcher !\u003d null) {\n                                     final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                     int valueDelimiterMatchLen \u003d 0;\n                                     for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                         // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                         if (!substitutionInVariablesEnabled\n                                                 \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                             break;\n                                         }\n                                         if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                             varName \u003d varNameExpr.substring(0, i);\n                                             varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                             break;\n                                         }\n                                     }\n                                 }\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables \u003d\u003d null) {\n                                     priorVariables \u003d new ArrayList\u003cString\u003e();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue \u003d resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue \u003d\u003d null) {\n                                     varValue \u003d varDefaultValue;\n                                 }\n                                 if (varValue !\u003d null) {\n                                     // recursive replace\n                                     final int varLen \u003d varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered \u003d true;\n                                     int change \u003d substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change \u003d change\n                                             + varLen - (endPos - startPos);\n                                     pos +\u003d change;\n                                     bufEnd +\u003d change;\n                                     lengthChange +\u003d change;\n                                     chars \u003d buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             }\n                             nestedVarCount--;\n                             pos +\u003d endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "93b1808e523c252098139c37ee5b23324e855b4a": {
      "type": "Ybodychange",
      "commitMessage": "Statement unnecessarily nested within else clause.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1606063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014-06-27, 8:34 a.m.",
      "commitName": "93b1808e523c252098139c37ee5b23324e855b4a",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2014-06-27, 8:22 a.m.",
      "commitNameOld": "96c30e248d6d27a1df8e26be14aa10c633168cdb",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n        final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n        final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n        final char escape \u003d getEscapeChar();\n        final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n\n        final boolean top \u003d priorVariables \u003d\u003d null;\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (substitutionInVariablesEnabled\n                                \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varNameExpr \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (substitutionInVariablesEnabled) {\n                                    final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                    substitute(bufName, 0, bufName.length());\n                                    varNameExpr \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                final int endPos \u003d pos;\n\n                                String varName \u003d varNameExpr;\n                                String varDefaultValue \u003d null;\n\n                                if (valueDelimMatcher !\u003d null) {\n                                    final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                    int valueDelimiterMatchLen \u003d 0;\n                                    for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                        // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                        if (!substitutionInVariablesEnabled\n                                                \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                            break;\n                                        }\n                                        if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                            varName \u003d varNameExpr.substring(0, i);\n                                            varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue \u003d\u003d null) {\n                                    varValue \u003d varDefaultValue;\n                                }\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    final int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + varLen - (endPos - startPos);\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            }\n                            nestedVarCount--;\n                            pos +\u003d endMatchLen;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 750,
      "functionName": "substitute",
      "diff": "@@ -1,132 +1,131 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n         final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n         final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n         final char escape \u003d getEscapeChar();\n         final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n         final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n \n         final boolean top \u003d priorVariables \u003d\u003d null;\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         if (substitutionInVariablesEnabled\n                                 \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) !\u003d 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos +\u003d endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount \u003d\u003d 0) {\n                                 String varNameExpr \u003d new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (substitutionInVariablesEnabled) {\n                                     final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n                                     varNameExpr \u003d bufName.toString();\n                                 }\n                                 pos +\u003d endMatchLen;\n                                 final int endPos \u003d pos;\n \n                                 String varName \u003d varNameExpr;\n                                 String varDefaultValue \u003d null;\n \n                                 if (valueDelimMatcher !\u003d null) {\n                                     final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                     int valueDelimiterMatchLen \u003d 0;\n                                     for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                         // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                         if (!substitutionInVariablesEnabled\n                                                 \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                             break;\n                                         }\n                                         if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                             varName \u003d varNameExpr.substring(0, i);\n                                             varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                             break;\n                                         }\n                                     }\n                                 }\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables \u003d\u003d null) {\n                                     priorVariables \u003d new ArrayList\u003cString\u003e();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue \u003d resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue \u003d\u003d null) {\n                                     varValue \u003d varDefaultValue;\n                                 }\n                                 if (varValue !\u003d null) {\n                                     // recursive replace\n                                     final int varLen \u003d varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered \u003d true;\n                                     int change \u003d substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change \u003d change\n                                             + varLen - (endPos - startPos);\n                                     pos +\u003d change;\n                                     bufEnd +\u003d change;\n                                     lengthChange +\u003d change;\n                                     chars \u003d buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n-                            } else {\n-                                nestedVarCount--;\n-                                pos +\u003d endMatchLen;\n                             }\n+                            nestedVarCount--;\n+                            pos +\u003d endMatchLen;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d97f23c08d8dbf889e976f9248d37173dbadb95": {
      "type": "Ybodychange",
      "commitMessage": "It\u0027s confusing to re-use field names locally\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1533551 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-10-18, 12:49 p.m.",
      "commitName": "1d97f23c08d8dbf889e976f9248d37173dbadb95",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013-09-29, 2:06 p.m.",
      "commitNameOld": "a328fd00a7092768758c0a76d68eeebaf8116440",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 18.95,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n        final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n        final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n        final char escape \u003d getEscapeChar();\n        final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n\n        final boolean top \u003d priorVariables \u003d\u003d null;\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (substitutionInVariablesEnabled\n                                \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varNameExpr \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (substitutionInVariablesEnabled) {\n                                    final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                    substitute(bufName, 0, bufName.length());\n                                    varNameExpr \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                final int endPos \u003d pos;\n\n                                String varName \u003d varNameExpr;\n                                String varDefaultValue \u003d null;\n\n                                if (valueDelimMatcher !\u003d null) {\n                                    final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                    int valueDelimiterMatchLen \u003d 0;\n                                    for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                        // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                        if (!substitutionInVariablesEnabled\n                                                \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                            break;\n                                        }\n                                        if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                            varName \u003d varNameExpr.substring(0, i);\n                                            varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue \u003d\u003d null) {\n                                    varValue \u003d varDefaultValue;\n                                }\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    final int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + varLen - (endPos - startPos);\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos +\u003d endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 740,
      "functionName": "substitute",
      "diff": "@@ -1,132 +1,132 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n-        final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n-        final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n+        final StrMatcher pfxMatcher \u003d getVariablePrefixMatcher();\n+        final StrMatcher suffMatcher \u003d getVariableSuffixMatcher();\n         final char escape \u003d getEscapeChar();\n-        final StrMatcher valueDelimiterMatcher \u003d getValueDelimiterMatcher();\n+        final StrMatcher valueDelimMatcher \u003d getValueDelimiterMatcher();\n         final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n \n         final boolean top \u003d priorVariables \u003d\u003d null;\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n-            final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n+            final int startMatchLen \u003d pfxMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         if (substitutionInVariablesEnabled\n-                                \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n+                                \u0026\u0026 (endMatchLen \u003d pfxMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) !\u003d 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos +\u003d endMatchLen;\n                             continue;\n                         }\n \n-                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n+                        endMatchLen \u003d suffMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount \u003d\u003d 0) {\n                                 String varNameExpr \u003d new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (substitutionInVariablesEnabled) {\n                                     final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n                                     varNameExpr \u003d bufName.toString();\n                                 }\n                                 pos +\u003d endMatchLen;\n                                 final int endPos \u003d pos;\n \n                                 String varName \u003d varNameExpr;\n                                 String varDefaultValue \u003d null;\n \n-                                if (valueDelimiterMatcher !\u003d null) {\n+                                if (valueDelimMatcher !\u003d null) {\n                                     final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                     int valueDelimiterMatchLen \u003d 0;\n                                     for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                         // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                         if (!substitutionInVariablesEnabled\n-                                                \u0026\u0026 prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n+                                                \u0026\u0026 pfxMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                             break;\n                                         }\n-                                        if ((valueDelimiterMatchLen \u003d valueDelimiterMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n+                                        if ((valueDelimiterMatchLen \u003d valueDelimMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                             varName \u003d varNameExpr.substring(0, i);\n                                             varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                             break;\n                                         }\n                                     }\n                                 }\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables \u003d\u003d null) {\n                                     priorVariables \u003d new ArrayList\u003cString\u003e();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue \u003d resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue \u003d\u003d null) {\n                                     varValue \u003d varDefaultValue;\n                                 }\n                                 if (varValue !\u003d null) {\n                                     // recursive replace\n                                     final int varLen \u003d varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered \u003d true;\n                                     int change \u003d substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change \u003d change\n                                             + varLen - (endPos - startPos);\n                                     pos +\u003d change;\n                                     bufEnd +\u003d change;\n                                     lengthChange +\u003d change;\n                                     chars \u003d buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos +\u003d endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abc5dda962fe00fba27f98807ca70439a37a3746": {
      "type": "Ybodychange",
      "commitMessage": "[LANG-893] StrSubstitutor now supports the declaration of default values for the variables to be replaced. Thanks to Woonsan Ko for the patch.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1524541 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-09-18, 3:35 p.m.",
      "commitName": "abc5dda962fe00fba27f98807ca70439a37a3746",
      "commitAuthor": "Oliver Heger",
      "commitDateOld": "2013-05-30, 12:36 p.m.",
      "commitNameOld": "8b494b784dca4de7d79c58e0f00dd4756c04cf89",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 111.12,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n        final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        final char escape \u003d getEscapeChar();\n        final StrMatcher valueDelimiterMatcher \u003d getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n\n        final boolean top \u003d priorVariables \u003d\u003d null;\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (substitutionInVariablesEnabled\n                                \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varNameExpr \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (substitutionInVariablesEnabled) {\n                                    final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                    substitute(bufName, 0, bufName.length());\n                                    varNameExpr \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                final int endPos \u003d pos;\n\n                                String varName \u003d varNameExpr;\n                                String varDefaultValue \u003d null;\n\n                                if (valueDelimiterMatcher !\u003d null) {\n                                    final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n                                    int valueDelimiterMatchLen \u003d 0;\n                                    for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n                                        // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n                                        if (!substitutionInVariablesEnabled\n                                                \u0026\u0026 prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n                                            break;\n                                        }\n                                        if ((valueDelimiterMatchLen \u003d valueDelimiterMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n                                            varName \u003d varNameExpr.substring(0, i);\n                                            varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue \u003d\u003d null) {\n                                    varValue \u003d varDefaultValue;\n                                }\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    final int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + varLen - (endPos - startPos);\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos +\u003d endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 738,
      "functionName": "substitute",
      "diff": "@@ -1,107 +1,132 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n         final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n         final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n         final char escape \u003d getEscapeChar();\n+        final StrMatcher valueDelimiterMatcher \u003d getValueDelimiterMatcher();\n+        final boolean substitutionInVariablesEnabled \u003d isEnableSubstitutionInVariables();\n \n         final boolean top \u003d priorVariables \u003d\u003d null;\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     final int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n-                        if (isEnableSubstitutionInVariables()\n+                        if (substitutionInVariablesEnabled\n                                 \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) !\u003d 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos +\u003d endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount \u003d\u003d 0) {\n-                                String varName \u003d new String(chars, startPos\n+                                String varNameExpr \u003d new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n-                                if (isEnableSubstitutionInVariables()) {\n-                                    final StrBuilder bufName \u003d new StrBuilder(varName);\n+                                if (substitutionInVariablesEnabled) {\n+                                    final StrBuilder bufName \u003d new StrBuilder(varNameExpr);\n                                     substitute(bufName, 0, bufName.length());\n-                                    varName \u003d bufName.toString();\n+                                    varNameExpr \u003d bufName.toString();\n                                 }\n                                 pos +\u003d endMatchLen;\n                                 final int endPos \u003d pos;\n \n+                                String varName \u003d varNameExpr;\n+                                String varDefaultValue \u003d null;\n+\n+                                if (valueDelimiterMatcher !\u003d null) {\n+                                    final char [] varNameExprChars \u003d varNameExpr.toCharArray();\n+                                    int valueDelimiterMatchLen \u003d 0;\n+                                    for (int i \u003d 0; i \u003c varNameExprChars.length; i++) {\n+                                        // if there\u0027s any nested variable when nested variable substitution disabled, then stop resolving name and default value.\n+                                        if (!substitutionInVariablesEnabled\n+                                                \u0026\u0026 prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) !\u003d 0) {\n+                                            break;\n+                                        }\n+                                        if ((valueDelimiterMatchLen \u003d valueDelimiterMatcher.isMatch(varNameExprChars, i)) !\u003d 0) {\n+                                            varName \u003d varNameExpr.substring(0, i);\n+                                            varDefaultValue \u003d varNameExpr.substring(i + valueDelimiterMatchLen);\n+                                            break;\n+                                        }\n+                                    }\n+                                }\n+\n                                 // on the first call initialize priorVariables\n                                 if (priorVariables \u003d\u003d null) {\n                                     priorVariables \u003d new ArrayList\u003cString\u003e();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n-                                final String varValue \u003d resolveVariable(varName, buf,\n+                                String varValue \u003d resolveVariable(varName, buf,\n                                         startPos, endPos);\n+                                if (varValue \u003d\u003d null) {\n+                                    varValue \u003d varDefaultValue;\n+                                }\n                                 if (varValue !\u003d null) {\n                                     // recursive replace\n                                     final int varLen \u003d varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered \u003d true;\n                                     int change \u003d substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change \u003d change\n                                             + varLen - (endPos - startPos);\n                                     pos +\u003d change;\n                                     bufEnd +\u003d change;\n                                     lengthChange +\u003d change;\n                                     chars \u003d buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos +\u003d endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:09 a.m.",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013-01-22, 2:07 a.m.",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n        final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        final char escape \u003d getEscapeChar();\n\n        final boolean top \u003d priorVariables \u003d\u003d null;\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    final int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (isEnableSubstitutionInVariables()\n                                \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varName \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (isEnableSubstitutionInVariables()) {\n                                    final StrBuilder bufName \u003d new StrBuilder(varName);\n                                    substitute(bufName, 0, bufName.length());\n                                    varName \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                final int endPos \u003d pos;\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                final String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    final int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + varLen - (endPos - startPos);\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos +\u003d endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 578,
      "functionName": "substitute",
      "diff": "@@ -1,107 +1,107 @@\n     private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n-        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n-        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n-        char escape \u003d getEscapeChar();\n+        final StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n+        final StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n+        final char escape \u003d getEscapeChar();\n \n-        boolean top \u003d priorVariables \u003d\u003d null;\n+        final boolean top \u003d priorVariables \u003d\u003d null;\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n-            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n+            final int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n-                    int startPos \u003d pos;\n+                    final int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         if (isEnableSubstitutionInVariables()\n                                 \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) !\u003d 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos +\u003d endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount \u003d\u003d 0) {\n                                 String varName \u003d new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (isEnableSubstitutionInVariables()) {\n-                                    StrBuilder bufName \u003d new StrBuilder(varName);\n+                                    final StrBuilder bufName \u003d new StrBuilder(varName);\n                                     substitute(bufName, 0, bufName.length());\n                                     varName \u003d bufName.toString();\n                                 }\n                                 pos +\u003d endMatchLen;\n-                                int endPos \u003d pos;\n+                                final int endPos \u003d pos;\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables \u003d\u003d null) {\n                                     priorVariables \u003d new ArrayList\u003cString\u003e();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n-                                String varValue \u003d resolveVariable(varName, buf,\n+                                final String varValue \u003d resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue !\u003d null) {\n                                     // recursive replace\n-                                    int varLen \u003d varValue.length();\n+                                    final int varLen \u003d varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered \u003d true;\n                                     int change \u003d substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change \u003d change\n                                             + varLen - (endPos - startPos);\n                                     pos +\u003d change;\n                                     bufEnd +\u003d change;\n                                     lengthChange +\u003d change;\n                                     chars \u003d buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos +\u003d endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:07 a.m.",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011-11-09, 12:53 p.m.",
      "commitNameOld": "371e866442f46131cc38a9a5018e1703f52f9b60",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 439.55,
      "commitsBetweenForRepo": 243,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n\n        boolean top \u003d priorVariables \u003d\u003d null;\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (isEnableSubstitutionInVariables()\n                                \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varName \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (isEnableSubstitutionInVariables()) {\n                                    StrBuilder bufName \u003d new StrBuilder(varName);\n                                    substitute(bufName, 0, bufName.length());\n                                    varName \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                int endPos \u003d pos;\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + varLen - (endPos - startPos);\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos +\u003d endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 578,
      "functionName": "substitute",
      "diff": "@@ -1,107 +1,107 @@\n-    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n+    private int substitute(final StrBuilder buf, final int offset, final int length, List\u003cString\u003e priorVariables) {\n         StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n         StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n         char escape \u003d getEscapeChar();\n \n         boolean top \u003d priorVariables \u003d\u003d null;\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         if (isEnableSubstitutionInVariables()\n                                 \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) !\u003d 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos +\u003d endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount \u003d\u003d 0) {\n                                 String varName \u003d new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (isEnableSubstitutionInVariables()) {\n                                     StrBuilder bufName \u003d new StrBuilder(varName);\n                                     substitute(bufName, 0, bufName.length());\n                                     varName \u003d bufName.toString();\n                                 }\n                                 pos +\u003d endMatchLen;\n                                 int endPos \u003d pos;\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables \u003d\u003d null) {\n                                     priorVariables \u003d new ArrayList\u003cString\u003e();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue \u003d resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue !\u003d null) {\n                                     // recursive replace\n                                     int varLen \u003d varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered \u003d true;\n                                     int change \u003d substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change \u003d change\n                                             + varLen - (endPos - startPos);\n                                     pos +\u003d change;\n                                     bufEnd +\u003d change;\n                                     lengthChange +\u003d change;\n                                     chars \u003d buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos +\u003d endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List\u003cString\u003e]",
        "newValue": "[buf-StrBuilder(modifiers-final), offset-int(modifiers-final), length-int(modifiers-final), priorVariables-List\u003cString\u003e]"
      }
    },
    "371e866442f46131cc38a9a5018e1703f52f9b60": {
      "type": "Ybodychange",
      "commitMessage": "Remove superfluous parens like:\nreturn (foo + 1);\nint len \u003d (foo + 1);\nif ((foo + 1 \u003e 2))\n((String) foo)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1199894 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-11-09, 12:53 p.m.",
      "commitName": "371e866442f46131cc38a9a5018e1703f52f9b60",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011-04-05, 1:31 a.m.",
      "commitNameOld": "3a0c152c22b6e96fc809fdee2d6ea5b816a139e6",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 218.52,
      "commitsBetweenForRepo": 424,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n\n        boolean top \u003d priorVariables \u003d\u003d null;\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (isEnableSubstitutionInVariables()\n                                \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varName \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (isEnableSubstitutionInVariables()) {\n                                    StrBuilder bufName \u003d new StrBuilder(varName);\n                                    substitute(bufName, 0, bufName.length());\n                                    varName \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                int endPos \u003d pos;\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + varLen - (endPos - startPos);\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos +\u003d endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 578,
      "functionName": "substitute",
      "diff": "@@ -1,107 +1,107 @@\n     private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n         StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n         StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n         char escape \u003d getEscapeChar();\n \n-        boolean top \u003d (priorVariables \u003d\u003d null);\n+        boolean top \u003d priorVariables \u003d\u003d null;\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         if (isEnableSubstitutionInVariables()\n                                 \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                         pos, offset, bufEnd)) !\u003d 0) {\n                             // found a nested variable start\n                             nestedVarCount++;\n                             pos +\u003d endMatchLen;\n                             continue;\n                         }\n \n                         endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                 bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             if (nestedVarCount \u003d\u003d 0) {\n                                 String varName \u003d new String(chars, startPos\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (isEnableSubstitutionInVariables()) {\n                                     StrBuilder bufName \u003d new StrBuilder(varName);\n                                     substitute(bufName, 0, bufName.length());\n                                     varName \u003d bufName.toString();\n                                 }\n                                 pos +\u003d endMatchLen;\n                                 int endPos \u003d pos;\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables \u003d\u003d null) {\n                                     priorVariables \u003d new ArrayList\u003cString\u003e();\n                                     priorVariables.add(new String(chars,\n                                             offset, length));\n                                 }\n \n                                 // handle cyclic substitution\n                                 checkCyclicSubstitution(varName, priorVariables);\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n                                 String varValue \u003d resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue !\u003d null) {\n                                     // recursive replace\n                                     int varLen \u003d varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered \u003d true;\n                                     int change \u003d substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change \u003d change\n-                                            + (varLen - (endPos - startPos));\n+                                            + varLen - (endPos - startPos);\n                                     pos +\u003d change;\n                                     bufEnd +\u003d change;\n                                     lengthChange +\u003d change;\n                                     chars \u003d buf.buffer; // in case buffer was\n                                                         // altered\n                                 }\n \n                                 // remove variable from the cyclic stack\n                                 priorVariables\n                                         .remove(priorVariables.size() - 1);\n                                 break;\n                             } else {\n                                 nestedVarCount--;\n                                 pos +\u003d endMatchLen;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n-            return (altered ? 1 : 0);\n+            return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f6eddbf3a41fa2838f062fee7724a69b86206df": {
      "type": "Ybodychange",
      "commitMessage": "[lang-482] Added support for substitution in variable names.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1005974 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-10-08, 3:17 p.m.",
      "commitName": "6f6eddbf3a41fa2838f062fee7724a69b86206df",
      "commitAuthor": "Oliver Heger",
      "commitDateOld": "2010-10-02, 2:37 p.m.",
      "commitNameOld": "802ebc4279f6020c4bb9a8d11fc164920c54949f",
      "commitAuthorOld": "Oliver Heger",
      "daysBetweenCommits": 6.03,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n\n        boolean top \u003d (priorVariables \u003d\u003d null);\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer; // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    int nestedVarCount \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        if (isEnableSubstitutionInVariables()\n                                \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n                                        pos, offset, bufEnd)) !\u003d 0) {\n                            // found a nested variable start\n                            nestedVarCount++;\n                            pos +\u003d endMatchLen;\n                            continue;\n                        }\n\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n                                bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            if (nestedVarCount \u003d\u003d 0) {\n                                String varName \u003d new String(chars, startPos\n                                        + startMatchLen, pos - startPos\n                                        - startMatchLen);\n                                if (isEnableSubstitutionInVariables()) {\n                                    StrBuilder bufName \u003d new StrBuilder(varName);\n                                    substitute(bufName, 0, bufName.length());\n                                    varName \u003d bufName.toString();\n                                }\n                                pos +\u003d endMatchLen;\n                                int endPos \u003d pos;\n\n                                // on the first call initialize priorVariables\n                                if (priorVariables \u003d\u003d null) {\n                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n                                    priorVariables.add(new String(chars,\n                                            offset, length));\n                                }\n\n                                // handle cyclic substitution\n                                checkCyclicSubstitution(varName, priorVariables);\n                                priorVariables.add(varName);\n\n                                // resolve the variable\n                                String varValue \u003d resolveVariable(varName, buf,\n                                        startPos, endPos);\n                                if (varValue !\u003d null) {\n                                    // recursive replace\n                                    int varLen \u003d varValue.length();\n                                    buf.replace(startPos, endPos, varValue);\n                                    altered \u003d true;\n                                    int change \u003d substitute(buf, startPos,\n                                            varLen, priorVariables);\n                                    change \u003d change\n                                            + (varLen - (endPos - startPos));\n                                    pos +\u003d change;\n                                    bufEnd +\u003d change;\n                                    lengthChange +\u003d change;\n                                    chars \u003d buf.buffer; // in case buffer was\n                                                        // altered\n                                }\n\n                                // remove variable from the cyclic stack\n                                priorVariables\n                                        .remove(priorVariables.size() - 1);\n                                break;\n                            } else {\n                                nestedVarCount--;\n                                pos +\u003d endMatchLen;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return (altered ? 1 : 0);\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 576,
      "functionName": "substitute",
      "diff": "@@ -1,78 +1,107 @@\n     private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n         StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n         StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n         char escape \u003d getEscapeChar();\n \n         boolean top \u003d (priorVariables \u003d\u003d null);\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n-            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset,\n+                    bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n-                    chars \u003d buf.buffer;  // in case buffer was altered\n+                    chars \u003d buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n+                    int nestedVarCount \u003d 0;\n                     while (pos \u003c bufEnd) {\n-                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                        if (isEnableSubstitutionInVariables()\n+                                \u0026\u0026 (endMatchLen \u003d prefixMatcher.isMatch(chars,\n+                                        pos, offset, bufEnd)) !\u003d 0) {\n+                            // found a nested variable start\n+                            nestedVarCount++;\n+                            pos +\u003d endMatchLen;\n+                            continue;\n+                        }\n+\n+                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset,\n+                                bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n-                            String varName \u003d new String(chars, startPos + startMatchLen,\n-                                                        pos - startPos - startMatchLen);\n-                            pos +\u003d endMatchLen;\n-                            int endPos \u003d pos;\n+                            if (nestedVarCount \u003d\u003d 0) {\n+                                String varName \u003d new String(chars, startPos\n+                                        + startMatchLen, pos - startPos\n+                                        - startMatchLen);\n+                                if (isEnableSubstitutionInVariables()) {\n+                                    StrBuilder bufName \u003d new StrBuilder(varName);\n+                                    substitute(bufName, 0, bufName.length());\n+                                    varName \u003d bufName.toString();\n+                                }\n+                                pos +\u003d endMatchLen;\n+                                int endPos \u003d pos;\n \n-                            // on the first call initialize priorVariables\n-                            if (priorVariables \u003d\u003d null) {\n-                                priorVariables \u003d new ArrayList\u003cString\u003e();\n-                                priorVariables.add(new String(chars, offset, length));\n+                                // on the first call initialize priorVariables\n+                                if (priorVariables \u003d\u003d null) {\n+                                    priorVariables \u003d new ArrayList\u003cString\u003e();\n+                                    priorVariables.add(new String(chars,\n+                                            offset, length));\n+                                }\n+\n+                                // handle cyclic substitution\n+                                checkCyclicSubstitution(varName, priorVariables);\n+                                priorVariables.add(varName);\n+\n+                                // resolve the variable\n+                                String varValue \u003d resolveVariable(varName, buf,\n+                                        startPos, endPos);\n+                                if (varValue !\u003d null) {\n+                                    // recursive replace\n+                                    int varLen \u003d varValue.length();\n+                                    buf.replace(startPos, endPos, varValue);\n+                                    altered \u003d true;\n+                                    int change \u003d substitute(buf, startPos,\n+                                            varLen, priorVariables);\n+                                    change \u003d change\n+                                            + (varLen - (endPos - startPos));\n+                                    pos +\u003d change;\n+                                    bufEnd +\u003d change;\n+                                    lengthChange +\u003d change;\n+                                    chars \u003d buf.buffer; // in case buffer was\n+                                                        // altered\n+                                }\n+\n+                                // remove variable from the cyclic stack\n+                                priorVariables\n+                                        .remove(priorVariables.size() - 1);\n+                                break;\n+                            } else {\n+                                nestedVarCount--;\n+                                pos +\u003d endMatchLen;\n                             }\n-\n-                            // handle cyclic substitution\n-                            checkCyclicSubstitution(varName, priorVariables);\n-                            priorVariables.add(varName);\n-\n-                            // resolve the variable\n-                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n-                            if (varValue !\u003d null) {\n-                                // recursive replace\n-                                int varLen \u003d varValue.length();\n-                                buf.replace(startPos, endPos, varValue);\n-                                altered \u003d true;\n-                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n-                                change \u003d change + (varLen - (endPos - startPos));\n-                                pos +\u003d change;\n-                                bufEnd +\u003d change;\n-                                lengthChange +\u003d change;\n-                                chars \u003d buf.buffer;  // in case buffer was altered\n-                            }\n-\n-                            // remove variable from the cyclic stack\n-                            priorVariables.remove(priorVariables.size() - 1);\n-                            break;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return (altered ? 1 : 0);\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-01-02, 9:11 p.m.",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010-01-02, 9:09 p.m.",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n        \n        boolean top \u003d (priorVariables \u003d\u003d null);\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer;  // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            String varName \u003d new String(chars, startPos + startMatchLen, \n                                                        pos - startPos - startMatchLen);\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            \n                            // on the first call initialize priorVariables\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            \n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            \n                            // resolve the variable\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                // recursive replace\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + (varLen - (endPos - startPos));\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;  // in case buffer was altered\n                            }\n                            \n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return (altered ? 1 : 0);\n        }\n        return lengthChange;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 536,
      "functionName": "substitute",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/text/StrSubstitutor.java",
        "newPath": "src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-10, 6:33 a.m.",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-12-10, 6:31 a.m.",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n        \n        boolean top \u003d (priorVariables \u003d\u003d null);\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer;  // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            String varName \u003d new String(chars, startPos + startMatchLen, \n                                                        pos - startPos - startMatchLen);\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            \n                            // on the first call initialize priorVariables\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            \n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            \n                            // resolve the variable\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                // recursive replace\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + (varLen - (endPos - startPos));\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;  // in case buffer was altered\n                            }\n                            \n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return (altered ? 1 : 0);\n        }\n        return lengthChange;\n    }",
      "path": "src/java/org/apache/commons/lang3/text/StrSubstitutor.java",
      "functionStartLine": 536,
      "functionName": "substitute",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
        "newPath": "src/java/org/apache/commons/lang3/text/StrSubstitutor.java"
      }
    },
    "654fb75d80a63fa551ced73c3b652f4120573590": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-03-15, 11:35 p.m.",
      "commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
      "commitAuthor": "Sebastian Bazley",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009-03-15, 11:35 p.m.",
          "commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2006-08-28, 2:21 a.m.",
          "commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 930.88,
          "commitsBetweenForRepo": 510,
          "commitsBetweenForFile": 1,
          "actualSource": "    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n        \n        boolean top \u003d (priorVariables \u003d\u003d null);\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer;  // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            String varName \u003d new String(chars, startPos + startMatchLen, \n                                                        pos - startPos - startMatchLen);\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            \n                            // on the first call initialize priorVariables\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            \n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            \n                            // resolve the variable\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                // recursive replace\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + (varLen - (endPos - startPos));\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;  // in case buffer was altered\n                            }\n                            \n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return (altered ? 1 : 0);\n        }\n        return lengthChange;\n    }",
          "path": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
          "functionStartLine": 536,
          "functionName": "substitute",
          "diff": "@@ -1,78 +1,78 @@\n-    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n         StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n         StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n         char escape \u003d getEscapeChar();\n         \n         boolean top \u003d (priorVariables \u003d\u003d null);\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer;  // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             String varName \u003d new String(chars, startPos + startMatchLen, \n                                                         pos - startPos - startMatchLen);\n                             pos +\u003d endMatchLen;\n                             int endPos \u003d pos;\n                             \n                             // on the first call initialize priorVariables\n                             if (priorVariables \u003d\u003d null) {\n-                                priorVariables \u003d new ArrayList();\n+                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             \n                             // handle cyclic substitution\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             \n                             // resolve the variable\n                             String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue !\u003d null) {\n                                 // recursive replace\n                                 int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + (varLen - (endPos - startPos));\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;  // in case buffer was altered\n                             }\n                             \n                             // remove variable from the cyclic stack\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return (altered ? 1 : 0);\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List]",
            "newValue": "[buf-StrBuilder, offset-int, length-int, priorVariables-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009-03-15, 11:35 p.m.",
          "commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2006-08-28, 2:21 a.m.",
          "commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 930.88,
          "commitsBetweenForRepo": 510,
          "commitsBetweenForFile": 1,
          "actualSource": "    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n        \n        boolean top \u003d (priorVariables \u003d\u003d null);\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer;  // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            String varName \u003d new String(chars, startPos + startMatchLen, \n                                                        pos - startPos - startMatchLen);\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            \n                            // on the first call initialize priorVariables\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            \n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            \n                            // resolve the variable\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                // recursive replace\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + (varLen - (endPos - startPos));\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;  // in case buffer was altered\n                            }\n                            \n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return (altered ? 1 : 0);\n        }\n        return lengthChange;\n    }",
          "path": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
          "functionStartLine": 536,
          "functionName": "substitute",
          "diff": "@@ -1,78 +1,78 @@\n-    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+    private int substitute(StrBuilder buf, int offset, int length, List\u003cString\u003e priorVariables) {\n         StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n         StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n         char escape \u003d getEscapeChar();\n         \n         boolean top \u003d (priorVariables \u003d\u003d null);\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer;  // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             String varName \u003d new String(chars, startPos + startMatchLen, \n                                                         pos - startPos - startMatchLen);\n                             pos +\u003d endMatchLen;\n                             int endPos \u003d pos;\n                             \n                             // on the first call initialize priorVariables\n                             if (priorVariables \u003d\u003d null) {\n-                                priorVariables \u003d new ArrayList();\n+                                priorVariables \u003d new ArrayList\u003cString\u003e();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             \n                             // handle cyclic substitution\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             \n                             // resolve the variable\n                             String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue !\u003d null) {\n                                 // recursive replace\n                                 int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + (varLen - (endPos - startPos));\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;  // in case buffer was altered\n                             }\n                             \n                             // remove variable from the cyclic stack\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return (altered ? 1 : 0);\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "927e7361037fa495cafece987c1c7d54b7e8128b": {
      "type": "Ybodychange",
      "commitMessage": "Give more power to StrSubstitutor subclasses\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@429507 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-08-07, 7:06 p.m.",
      "commitName": "927e7361037fa495cafece987c1c7d54b7e8128b",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2006-08-04, 2:35 a.m.",
      "commitNameOld": "2d4e279d1983870d88612afec782f18638b85ce7",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 3.69,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n        \n        boolean top \u003d (priorVariables \u003d\u003d null);\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer;  // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            String varName \u003d new String(chars, startPos + startMatchLen, \n                                                        pos - startPos - startMatchLen);\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            \n                            // on the first call initialize priorVariables\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            \n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            \n                            // resolve the variable\n                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                            if (varValue !\u003d null) {\n                                // recursive replace\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + (varLen - (endPos - startPos));\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;  // in case buffer was altered\n                            }\n                            \n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return (altered ? 1 : 0);\n        }\n        return lengthChange;\n    }",
      "path": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
      "functionStartLine": 398,
      "functionName": "substitute",
      "diff": "@@ -1,78 +1,78 @@\n     private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n         StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n         StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n         char escape \u003d getEscapeChar();\n         \n         boolean top \u003d (priorVariables \u003d\u003d null);\n         boolean altered \u003d false;\n         int lengthChange \u003d 0;\n         char[] chars \u003d buf.buffer;\n         int bufEnd \u003d offset + length;\n         int pos \u003d offset;\n         while (pos \u003c bufEnd) {\n             int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n             if (startMatchLen \u003d\u003d 0) {\n                 pos++;\n             } else {\n                 // found variable start marker\n                 if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n                     chars \u003d buf.buffer;  // in case buffer was altered\n                     lengthChange--;\n                     altered \u003d true;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n                     int startPos \u003d pos;\n                     pos +\u003d startMatchLen;\n                     int endMatchLen \u003d 0;\n                     while (pos \u003c bufEnd) {\n                         endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                         if (endMatchLen \u003d\u003d 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n                             String varName \u003d new String(chars, startPos + startMatchLen, \n                                                         pos - startPos - startMatchLen);\n                             pos +\u003d endMatchLen;\n                             int endPos \u003d pos;\n                             \n                             // on the first call initialize priorVariables\n                             if (priorVariables \u003d\u003d null) {\n                                 priorVariables \u003d new ArrayList();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             \n                             // handle cyclic substitution\n                             checkCyclicSubstitution(varName, priorVariables);\n                             priorVariables.add(varName);\n                             \n                             // resolve the variable\n-                            String varValue \u003d resolveVariable(varName);\n+                            String varValue \u003d resolveVariable(varName, buf, startPos, endPos);\n                             if (varValue !\u003d null) {\n                                 // recursive replace\n                                 int varLen \u003d varValue.length();\n                                 buf.replace(startPos, endPos, varValue);\n                                 altered \u003d true;\n                                 int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                 change \u003d change + (varLen - (endPos - startPos));\n                                 pos +\u003d change;\n                                 bufEnd +\u003d change;\n                                 lengthChange +\u003d change;\n                                 chars \u003d buf.buffer;  // in case buffer was altered\n                             }\n                             \n                             // remove variable from the cyclic stack\n                             priorVariables.remove(priorVariables.size() - 1);\n                             break;\n                         }\n                     }\n                 }\n             }\n         }\n         if (top) {\n             return (altered ? 1 : 0);\n         }\n         return lengthChange;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4bfa1f6cb94c368ffa4febc3a2236886ced2290f": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit of StrSubstitutor (VariableFormatter) for review\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@424871 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-07-23, 9:00 p.m.",
      "commitName": "4bfa1f6cb94c368ffa4febc3a2236886ced2290f",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,77 @@\n+    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n+        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n+        char escape \u003d getEscapeChar();\n+        \n+        boolean top \u003d (priorVariables \u003d\u003d null);\n+        boolean altered \u003d false;\n+        int lengthChange \u003d 0;\n+        char[] chars \u003d buf.buffer;\n+        int bufEnd \u003d offset + length;\n+        int pos \u003d offset;\n+        while (pos \u003c bufEnd) {\n+            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+            if (startMatchLen \u003d\u003d 0) {\n+                pos++;\n+            } else {\n+                // found variable start marker\n+                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n+                    // escaped\n+                    buf.deleteCharAt(pos - 1);\n+                    chars \u003d buf.buffer;  // in case buffer was altered\n+                    lengthChange--;\n+                    altered \u003d true;\n+                    bufEnd--;\n+                } else {\n+                    // find suffix\n+                    int startPos \u003d pos;\n+                    pos +\u003d startMatchLen;\n+                    int endMatchLen \u003d 0;\n+                    while (pos \u003c bufEnd) {\n+                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                        if (endMatchLen \u003d\u003d 0) {\n+                            pos++;\n+                        } else {\n+                            // found variable end marker\n+                            String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n+                            pos +\u003d endMatchLen;\n+                            int endPos \u003d pos;\n+                            \n+                            // on the first call initialize priorVariables\n+                            if (priorVariables \u003d\u003d null) {\n+                                priorVariables \u003d new ArrayList();\n+                                priorVariables.add(new String(chars, offset, length));\n+                            }\n+                            \n+                            // handle cyclic substitution\n+                            checkCyclicSubstitution(varName, priorVariables);\n+                            priorVariables.add(varName);\n+                            \n+                            // resolve the variable\n+                            String varValue \u003d resolveVariable(varName);\n+                            if (varValue !\u003d null) {\n+                                // recursive replace\n+                                int varLen \u003d varValue.length();\n+                                buf.replace(startPos, endPos, varValue);\n+                                altered \u003d true;\n+                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n+                                change \u003d change + (varLen - (endPos - startPos));\n+                                pos +\u003d change;\n+                                bufEnd +\u003d change;\n+                                lengthChange +\u003d change;\n+                                chars \u003d buf.buffer;  // in case buffer was altered\n+                            }\n+                            \n+                            // remove variable from the cyclic stack\n+                            priorVariables.remove(priorVariables.size() - 1);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (top) {\n+            return (altered ? 1 : 0);\n+        }\n+        return lengthChange;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n        StrMatcher prefixMatcher \u003d getVariablePrefixMatcher();\n        StrMatcher suffixMatcher \u003d getVariableSuffixMatcher();\n        char escape \u003d getEscapeChar();\n        \n        boolean top \u003d (priorVariables \u003d\u003d null);\n        boolean altered \u003d false;\n        int lengthChange \u003d 0;\n        char[] chars \u003d buf.buffer;\n        int bufEnd \u003d offset + length;\n        int pos \u003d offset;\n        while (pos \u003c bufEnd) {\n            int startMatchLen \u003d prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n            if (startMatchLen \u003d\u003d 0) {\n                pos++;\n            } else {\n                // found variable start marker\n                if (pos \u003e offset \u0026\u0026 chars[pos - 1] \u003d\u003d escape) {\n                    // escaped\n                    buf.deleteCharAt(pos - 1);\n                    chars \u003d buf.buffer;  // in case buffer was altered\n                    lengthChange--;\n                    altered \u003d true;\n                    bufEnd--;\n                } else {\n                    // find suffix\n                    int startPos \u003d pos;\n                    pos +\u003d startMatchLen;\n                    int endMatchLen \u003d 0;\n                    while (pos \u003c bufEnd) {\n                        endMatchLen \u003d suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n                        if (endMatchLen \u003d\u003d 0) {\n                            pos++;\n                        } else {\n                            // found variable end marker\n                            String varName \u003d new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n                            pos +\u003d endMatchLen;\n                            int endPos \u003d pos;\n                            \n                            // on the first call initialize priorVariables\n                            if (priorVariables \u003d\u003d null) {\n                                priorVariables \u003d new ArrayList();\n                                priorVariables.add(new String(chars, offset, length));\n                            }\n                            \n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n                            \n                            // resolve the variable\n                            String varValue \u003d resolveVariable(varName);\n                            if (varValue !\u003d null) {\n                                // recursive replace\n                                int varLen \u003d varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered \u003d true;\n                                int change \u003d substitute(buf, startPos, varLen, priorVariables);\n                                change \u003d change + (varLen - (endPos - startPos));\n                                pos +\u003d change;\n                                bufEnd +\u003d change;\n                                lengthChange +\u003d change;\n                                chars \u003d buf.buffer;  // in case buffer was altered\n                            }\n                            \n                            // remove variable from the cyclic stack\n                            priorVariables.remove(priorVariables.size() - 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (top) {\n            return (altered ? 1 : 0);\n        }\n        return lengthChange;\n    }",
      "path": "src/java/org/apache/commons/lang/text/StrSubstitutor.java",
      "functionStartLine": 391,
      "functionName": "substitute"
    }
  }
}