{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "H:\\Projects\\apache\\commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "EqualsBuilder.java",
  "functionName": "reflectionAppend",
  "functionId": "reflectionAppend___lhs-Object(modifiers-final)__rhs-Object(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
  "functionStartLine": 491,
  "functionEndLine": 554,
  "numCommitsSeen": 196,
  "timeTaken": 3776,
  "changeHistory": [
    "2e9f3a80146262511ca7bcdd3411f095dff4951d",
    "0f6a292a29fedd49741310cd517ac4ba907bf8d4",
    "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
    "aeb6f86bcdec061ee9c6be96066fa19c56523490",
    "9072a7615a54d5e753cf088326d9e14f1a5a6751",
    "f525bc3ccd9cfb69603bd9778998263a458415d0",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "1a60c21395fe7648188d1c91f62ac7baefa12742",
    "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "ca3a3baa651465310d31824250318bd500fa9e8b",
    "654fb75d80a63fa551ced73c3b652f4120573590",
    "8393f10b791c4fd28a1031f0a6427a2c9af04977",
    "d27569f61a49489dd72e4b8a1ed4b0648008b3d5",
    "984bc76cd36138514e8c3c2cd494cd952d22dd13",
    "5c40090fecdacd9366bba7e3e29d94f213cf2633"
  ],
  "changeHistoryShort": {
    "2e9f3a80146262511ca7bcdd3411f095dff4951d": "Ybodychange",
    "0f6a292a29fedd49741310cd517ac4ba907bf8d4": "Ybodychange",
    "0095d8adf26b9469115b1be0358cb09d1fcb5fd4": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": "Ybodychange",
    "aeb6f86bcdec061ee9c6be96066fa19c56523490": "Ybodychange",
    "9072a7615a54d5e753cf088326d9e14f1a5a6751": "Ybodychange",
    "f525bc3ccd9cfb69603bd9778998263a458415d0": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "1a60c21395fe7648188d1c91f62ac7baefa12742": "Ybodychange",
    "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "ca3a3baa651465310d31824250318bd500fa9e8b": "Ybodychange",
    "654fb75d80a63fa551ced73c3b652f4120573590": "Yparameterchange",
    "8393f10b791c4fd28a1031f0a6427a2c9af04977": "Ymultichange(Yparameterchange,Ybodychange)",
    "d27569f61a49489dd72e4b8a1ed4b0648008b3d5": "Ybodychange",
    "984bc76cd36138514e8c3c2cd494cd952d22dd13": "Ybodychange",
    "5c40090fecdacd9366bba7e3e29d94f213cf2633": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2e9f3a80146262511ca7bcdd3411f095dff4951d": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1356: Add bypass option for classes to recursive and reflective EqualsBuilder\n\nPatch supplied by Yathos UG\n",
      "commitDate": "2018-02-11, 2:43 p.m.",
      "commitName": "2e9f3a80146262511ca7bcdd3411f095dff4951d",
      "commitAuthor": "pascalschumacher",
      "commitDateOld": "2017-09-08, 12:19 p.m.",
      "commitNameOld": "3e08af573f8b50da5202f55df62c925f88a47f3d",
      "commitAuthorOld": "namannigam",
      "daysBetweenCommits": 156.14,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "actualSource": "    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs \u003d\u003d rhs) {\n            return this;\n        }\n        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n            isEquals \u003d false;\n            return this;\n        }\n\n        // Find the leaf class since there may be transients in the leaf\n        // class or in classes between the leaf and root.\n        // If we are not testing transients or a subclass has no ivars,\n        // then a subclass can test equals to a superclass.\n        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n        Class\u003c?\u003e testClass;\n        if (lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n            if (!rhsClass.isInstance(lhs)) {\n                // rhsClass is a subclass of lhsClass\n                testClass \u003d rhsClass;\n            }\n        } else if (rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n            if (!lhsClass.isInstance(rhs)) {\n                // lhsClass is a subclass of rhsClass\n                testClass \u003d lhsClass;\n            }\n        } else {\n            // The two classes are not related.\n            isEquals \u003d false;\n            return this;\n        }\n\n        try {\n            if (testClass.isArray()) {\n                append(lhs, rhs);\n            } else {\n                //If either class is being excluded, call normal object equals method on lhsClass.\n                if (bypassReflectionClasses !\u003d null\n                        \u0026\u0026 (bypassReflectionClasses.contains(lhsClass) || bypassReflectionClasses.contains(rhsClass))) {\n                    isEquals \u003d lhs.equals(rhs);\n                } else {\n                    reflectionAppend(lhs, rhs, testClass);\n                    while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                        testClass \u003d testClass.getSuperclass();\n                        reflectionAppend(lhs, rhs, testClass);\n                    }\n                }\n            }\n        } catch (final IllegalArgumentException e) {\n            // In this case, we tried to test a subclass vs. a superclass and\n            // the subclass has ivars or the ivars are transient and\n            // we are testing transients.\n            // If a subclass has ivars that we are trying to test them, we get an\n            // exception and we know that the objects are not equal.\n            isEquals \u003d false;\n            return this;\n        }\n        return this;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 491,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,58 +1,64 @@\n     public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n         if (!isEquals) {\n             return this;\n         }\n         if (lhs \u003d\u003d rhs) {\n             return this;\n         }\n         if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n             isEquals \u003d false;\n             return this;\n         }\n \n         // Find the leaf class since there may be transients in the leaf\n         // class or in classes between the leaf and root.\n         // If we are not testing transients or a subclass has no ivars,\n         // then a subclass can test equals to a superclass.\n         final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n         final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n         Class\u003c?\u003e testClass;\n         if (lhsClass.isInstance(rhs)) {\n             testClass \u003d lhsClass;\n             if (!rhsClass.isInstance(lhs)) {\n                 // rhsClass is a subclass of lhsClass\n                 testClass \u003d rhsClass;\n             }\n         } else if (rhsClass.isInstance(lhs)) {\n             testClass \u003d rhsClass;\n             if (!lhsClass.isInstance(rhs)) {\n                 // lhsClass is a subclass of rhsClass\n                 testClass \u003d lhsClass;\n             }\n         } else {\n             // The two classes are not related.\n             isEquals \u003d false;\n             return this;\n         }\n \n         try {\n             if (testClass.isArray()) {\n                 append(lhs, rhs);\n             } else {\n-                reflectionAppend(lhs, rhs, testClass);\n-                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n-                    testClass \u003d testClass.getSuperclass();\n+                //If either class is being excluded, call normal object equals method on lhsClass.\n+                if (bypassReflectionClasses !\u003d null\n+                        \u0026\u0026 (bypassReflectionClasses.contains(lhsClass) || bypassReflectionClasses.contains(rhsClass))) {\n+                    isEquals \u003d lhs.equals(rhs);\n+                } else {\n                     reflectionAppend(lhs, rhs, testClass);\n+                    while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                        testClass \u003d testClass.getSuperclass();\n+                        reflectionAppend(lhs, rhs, testClass);\n+                    }\n                 }\n             }\n         } catch (final IllegalArgumentException e) {\n             // In this case, we tried to test a subclass vs. a superclass and\n             // the subclass has ivars or the ivars are transient and\n             // we are testing transients.\n             // If a subclass has ivars that we are trying to test them, we get an\n             // exception and we know that the objects are not equal.\n             isEquals \u003d false;\n             return this;\n         }\n         return this;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0f6a292a29fedd49741310cd517ac4ba907bf8d4": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1034: Add support for recursive comparison to EqualsBuilder#reflectionEquals (closes #202)\n\nminimal clean-ups: remove getter methods, improve javadoc, add unit test for reflectionAppend\n",
      "commitDate": "2016-11-13, 12:47 p.m.",
      "commitName": "0f6a292a29fedd49741310cd517ac4ba907bf8d4",
      "commitAuthor": "pascalschumacher",
      "commitDateOld": "2016-11-13, 12:47 p.m.",
      "commitNameOld": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
      "commitAuthorOld": "pascalschumacher",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n        if (!isEquals) {\n            return this;\n        }\n        if (lhs \u003d\u003d rhs) {\n            return this;\n        }\n        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n            isEquals \u003d false;\n            return this;\n        }\n\n        // Find the leaf class since there may be transients in the leaf\n        // class or in classes between the leaf and root.\n        // If we are not testing transients or a subclass has no ivars,\n        // then a subclass can test equals to a superclass.\n        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n        Class\u003c?\u003e testClass;\n        if (lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n            if (!rhsClass.isInstance(lhs)) {\n                // rhsClass is a subclass of lhsClass\n                testClass \u003d rhsClass;\n            }\n        } else if (rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n            if (!lhsClass.isInstance(rhs)) {\n                // lhsClass is a subclass of rhsClass\n                testClass \u003d lhsClass;\n            }\n        } else {\n            // The two classes are not related.\n            isEquals \u003d false;\n            return this;\n        }\n\n        try {\n            if (testClass.isArray()) {\n                append(lhs, rhs);\n            } else {\n                reflectionAppend(lhs, rhs, testClass);\n                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                    testClass \u003d testClass.getSuperclass();\n                    reflectionAppend(lhs, rhs, testClass);\n                }\n            }\n        } catch (final IllegalArgumentException e) {\n            // In this case, we tried to test a subclass vs. a superclass and\n            // the subclass has ivars or the ivars are transient and\n            // we are testing transients.\n            // If a subclass has ivars that we are trying to test them, we get an\n            // exception and we know that the objects are not equal.\n            isEquals \u003d false;\n            return this;\n        }\n        return this;\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 465,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,57 +1,58 @@\n     public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n-        if(!isEquals)\n+        if (!isEquals) {\n             return this;\n-        \n+        }\n         if (lhs \u003d\u003d rhs) {\n             return this;\n         }\n         if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n             isEquals \u003d false;\n             return this;\n         }\n+\n         // Find the leaf class since there may be transients in the leaf\n         // class or in classes between the leaf and root.\n         // If we are not testing transients or a subclass has no ivars,\n         // then a subclass can test equals to a superclass.\n         final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n         final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n         Class\u003c?\u003e testClass;\n         if (lhsClass.isInstance(rhs)) {\n             testClass \u003d lhsClass;\n             if (!rhsClass.isInstance(lhs)) {\n                 // rhsClass is a subclass of lhsClass\n                 testClass \u003d rhsClass;\n             }\n         } else if (rhsClass.isInstance(lhs)) {\n             testClass \u003d rhsClass;\n             if (!lhsClass.isInstance(rhs)) {\n                 // lhsClass is a subclass of rhsClass\n                 testClass \u003d lhsClass;\n             }\n         } else {\n             // The two classes are not related.\n             isEquals \u003d false;\n             return this;\n         }\n-        \n+\n         try {\n             if (testClass.isArray()) {\n                 append(lhs, rhs);\n             } else {\n                 reflectionAppend(lhs, rhs, testClass);\n                 while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                     testClass \u003d testClass.getSuperclass();\n                     reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n         } catch (final IllegalArgumentException e) {\n             // In this case, we tried to test a subclass vs. a superclass and\n             // the subclass has ivars or the ivars are transient and\n             // we are testing transients.\n             // If a subclass has ivars that we are trying to test them, we get an\n             // exception and we know that the objects are not equal.\n             isEquals \u003d false;\n             return this;\n         }\n         return this;\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0095d8adf26b9469115b1be0358cb09d1fcb5fd4": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
      "commitDate": "2016-11-13, 12:47 p.m.",
      "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
      "commitAuthor": "pascalschumacher",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016-11-13, 12:47 p.m.",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016-10-23, 1:55 p.m.",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n        if(!isEquals)\n            return this;\n        \n        if (lhs \u003d\u003d rhs) {\n            return this;\n        }\n        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n            isEquals \u003d false;\n            return this;\n        }\n        // Find the leaf class since there may be transients in the leaf\n        // class or in classes between the leaf and root.\n        // If we are not testing transients or a subclass has no ivars,\n        // then a subclass can test equals to a superclass.\n        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n        Class\u003c?\u003e testClass;\n        if (lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n            if (!rhsClass.isInstance(lhs)) {\n                // rhsClass is a subclass of lhsClass\n                testClass \u003d rhsClass;\n            }\n        } else if (rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n            if (!lhsClass.isInstance(rhs)) {\n                // lhsClass is a subclass of rhsClass\n                testClass \u003d lhsClass;\n            }\n        } else {\n            // The two classes are not related.\n            isEquals \u003d false;\n            return this;\n        }\n        \n        try {\n            if (testClass.isArray()) {\n                append(lhs, rhs);\n            } else {\n                reflectionAppend(lhs, rhs, testClass);\n                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                    testClass \u003d testClass.getSuperclass();\n                    reflectionAppend(lhs, rhs, testClass);\n                }\n            }\n        } catch (final IllegalArgumentException e) {\n            // In this case, we tried to test a subclass vs. a superclass and\n            // the subclass has ivars or the ivars are transient and\n            // we are testing transients.\n            // If a subclass has ivars that we are trying to test them, we get an\n            // exception and we know that the objects are not equal.\n            isEquals \u003d false;\n            return this;\n        }\n        return this;\n    }",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "diff": "@@ -1,36 +1,57 @@\n-    private static void reflectionAppend(\n-        final Object lhs,\n-        final Object rhs,\n-        final Class\u003c?\u003e clazz,\n-        final EqualsBuilder builder,\n-        final boolean useTransients,\n-        final String[] excludeFields) {\n-\n-        if (isRegistered(lhs, rhs)) {\n-            return;\n+    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+        if(!isEquals)\n+            return this;\n+        \n+        if (lhs \u003d\u003d rhs) {\n+            return this;\n         }\n-\n+        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+            isEquals \u003d false;\n+            return this;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+        Class\u003c?\u003e testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass \u003d rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass \u003d lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            isEquals \u003d false;\n+            return this;\n+        }\n+        \n         try {\n-            register(lhs, rhs);\n-            final Field[] fields \u003d clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-                final Field f \u003d fields[i];\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    \u0026\u0026 !f.getName().contains(\"$\")\n-                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())\n-                    \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (final IllegalAccessException e) {\n-                        //this can\u0027t happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n-                    }\n+            if (testClass.isArray()) {\n+                append(lhs, rhs);\n+            } else {\n+                reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                    testClass \u003d testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n-        } finally {\n-            unregister(lhs, rhs);\n+        } catch (final IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            isEquals \u003d false;\n+            return this;\n         }\n+        return this;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final), clazz-Class\u003c?\u003e(modifiers-final), builder-EqualsBuilder(modifiers-final), useTransients-boolean(modifiers-final), excludeFields-String[](modifiers-final)]",
            "newValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final)]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016-11-13, 12:47 p.m.",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016-10-23, 1:55 p.m.",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n        if(!isEquals)\n            return this;\n        \n        if (lhs \u003d\u003d rhs) {\n            return this;\n        }\n        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n            isEquals \u003d false;\n            return this;\n        }\n        // Find the leaf class since there may be transients in the leaf\n        // class or in classes between the leaf and root.\n        // If we are not testing transients or a subclass has no ivars,\n        // then a subclass can test equals to a superclass.\n        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n        Class\u003c?\u003e testClass;\n        if (lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n            if (!rhsClass.isInstance(lhs)) {\n                // rhsClass is a subclass of lhsClass\n                testClass \u003d rhsClass;\n            }\n        } else if (rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n            if (!lhsClass.isInstance(rhs)) {\n                // lhsClass is a subclass of rhsClass\n                testClass \u003d lhsClass;\n            }\n        } else {\n            // The two classes are not related.\n            isEquals \u003d false;\n            return this;\n        }\n        \n        try {\n            if (testClass.isArray()) {\n                append(lhs, rhs);\n            } else {\n                reflectionAppend(lhs, rhs, testClass);\n                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                    testClass \u003d testClass.getSuperclass();\n                    reflectionAppend(lhs, rhs, testClass);\n                }\n            }\n        } catch (final IllegalArgumentException e) {\n            // In this case, we tried to test a subclass vs. a superclass and\n            // the subclass has ivars or the ivars are transient and\n            // we are testing transients.\n            // If a subclass has ivars that we are trying to test them, we get an\n            // exception and we know that the objects are not equal.\n            isEquals \u003d false;\n            return this;\n        }\n        return this;\n    }",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "diff": "@@ -1,36 +1,57 @@\n-    private static void reflectionAppend(\n-        final Object lhs,\n-        final Object rhs,\n-        final Class\u003c?\u003e clazz,\n-        final EqualsBuilder builder,\n-        final boolean useTransients,\n-        final String[] excludeFields) {\n-\n-        if (isRegistered(lhs, rhs)) {\n-            return;\n+    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+        if(!isEquals)\n+            return this;\n+        \n+        if (lhs \u003d\u003d rhs) {\n+            return this;\n         }\n-\n+        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+            isEquals \u003d false;\n+            return this;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+        Class\u003c?\u003e testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass \u003d rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass \u003d lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            isEquals \u003d false;\n+            return this;\n+        }\n+        \n         try {\n-            register(lhs, rhs);\n-            final Field[] fields \u003d clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-                final Field f \u003d fields[i];\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    \u0026\u0026 !f.getName().contains(\"$\")\n-                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())\n-                    \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (final IllegalAccessException e) {\n-                        //this can\u0027t happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n-                    }\n+            if (testClass.isArray()) {\n+                append(lhs, rhs);\n+            } else {\n+                reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                    testClass \u003d testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n-        } finally {\n-            unregister(lhs, rhs);\n+        } catch (final IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            isEquals \u003d false;\n+            return this;\n         }\n+        return this;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "EqualsBuilder"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016-11-13, 12:47 p.m.",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016-10-23, 1:55 p.m.",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n        if(!isEquals)\n            return this;\n        \n        if (lhs \u003d\u003d rhs) {\n            return this;\n        }\n        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n            isEquals \u003d false;\n            return this;\n        }\n        // Find the leaf class since there may be transients in the leaf\n        // class or in classes between the leaf and root.\n        // If we are not testing transients or a subclass has no ivars,\n        // then a subclass can test equals to a superclass.\n        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n        Class\u003c?\u003e testClass;\n        if (lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n            if (!rhsClass.isInstance(lhs)) {\n                // rhsClass is a subclass of lhsClass\n                testClass \u003d rhsClass;\n            }\n        } else if (rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n            if (!lhsClass.isInstance(rhs)) {\n                // lhsClass is a subclass of rhsClass\n                testClass \u003d lhsClass;\n            }\n        } else {\n            // The two classes are not related.\n            isEquals \u003d false;\n            return this;\n        }\n        \n        try {\n            if (testClass.isArray()) {\n                append(lhs, rhs);\n            } else {\n                reflectionAppend(lhs, rhs, testClass);\n                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                    testClass \u003d testClass.getSuperclass();\n                    reflectionAppend(lhs, rhs, testClass);\n                }\n            }\n        } catch (final IllegalArgumentException e) {\n            // In this case, we tried to test a subclass vs. a superclass and\n            // the subclass has ivars or the ivars are transient and\n            // we are testing transients.\n            // If a subclass has ivars that we are trying to test them, we get an\n            // exception and we know that the objects are not equal.\n            isEquals \u003d false;\n            return this;\n        }\n        return this;\n    }",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "diff": "@@ -1,36 +1,57 @@\n-    private static void reflectionAppend(\n-        final Object lhs,\n-        final Object rhs,\n-        final Class\u003c?\u003e clazz,\n-        final EqualsBuilder builder,\n-        final boolean useTransients,\n-        final String[] excludeFields) {\n-\n-        if (isRegistered(lhs, rhs)) {\n-            return;\n+    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+        if(!isEquals)\n+            return this;\n+        \n+        if (lhs \u003d\u003d rhs) {\n+            return this;\n         }\n-\n+        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+            isEquals \u003d false;\n+            return this;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+        Class\u003c?\u003e testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass \u003d rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass \u003d lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            isEquals \u003d false;\n+            return this;\n+        }\n+        \n         try {\n-            register(lhs, rhs);\n-            final Field[] fields \u003d clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-                final Field f \u003d fields[i];\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    \u0026\u0026 !f.getName().contains(\"$\")\n-                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())\n-                    \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (final IllegalAccessException e) {\n-                        //this can\u0027t happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n-                    }\n+            if (testClass.isArray()) {\n+                append(lhs, rhs);\n+            } else {\n+                reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                    testClass \u003d testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n-        } finally {\n-            unregister(lhs, rhs);\n+        } catch (final IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            isEquals \u003d false;\n+            return this;\n         }\n+        return this;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private, static]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016-11-13, 12:47 p.m.",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016-10-23, 1:55 p.m.",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n        if(!isEquals)\n            return this;\n        \n        if (lhs \u003d\u003d rhs) {\n            return this;\n        }\n        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n            isEquals \u003d false;\n            return this;\n        }\n        // Find the leaf class since there may be transients in the leaf\n        // class or in classes between the leaf and root.\n        // If we are not testing transients or a subclass has no ivars,\n        // then a subclass can test equals to a superclass.\n        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n        Class\u003c?\u003e testClass;\n        if (lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n            if (!rhsClass.isInstance(lhs)) {\n                // rhsClass is a subclass of lhsClass\n                testClass \u003d rhsClass;\n            }\n        } else if (rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n            if (!lhsClass.isInstance(rhs)) {\n                // lhsClass is a subclass of rhsClass\n                testClass \u003d lhsClass;\n            }\n        } else {\n            // The two classes are not related.\n            isEquals \u003d false;\n            return this;\n        }\n        \n        try {\n            if (testClass.isArray()) {\n                append(lhs, rhs);\n            } else {\n                reflectionAppend(lhs, rhs, testClass);\n                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                    testClass \u003d testClass.getSuperclass();\n                    reflectionAppend(lhs, rhs, testClass);\n                }\n            }\n        } catch (final IllegalArgumentException e) {\n            // In this case, we tried to test a subclass vs. a superclass and\n            // the subclass has ivars or the ivars are transient and\n            // we are testing transients.\n            // If a subclass has ivars that we are trying to test them, we get an\n            // exception and we know that the objects are not equal.\n            isEquals \u003d false;\n            return this;\n        }\n        return this;\n    }",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "diff": "@@ -1,36 +1,57 @@\n-    private static void reflectionAppend(\n-        final Object lhs,\n-        final Object rhs,\n-        final Class\u003c?\u003e clazz,\n-        final EqualsBuilder builder,\n-        final boolean useTransients,\n-        final String[] excludeFields) {\n-\n-        if (isRegistered(lhs, rhs)) {\n-            return;\n+    public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+        if(!isEquals)\n+            return this;\n+        \n+        if (lhs \u003d\u003d rhs) {\n+            return this;\n         }\n-\n+        if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+            isEquals \u003d false;\n+            return this;\n+        }\n+        // Find the leaf class since there may be transients in the leaf\n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars,\n+        // then a subclass can test equals to a superclass.\n+        final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+        final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+        Class\u003c?\u003e testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass \u003d rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass \u003d lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            isEquals \u003d false;\n+            return this;\n+        }\n+        \n         try {\n-            register(lhs, rhs);\n-            final Field[] fields \u003d clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-                final Field f \u003d fields[i];\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    \u0026\u0026 !f.getName().contains(\"$\")\n-                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())\n-                    \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (final IllegalAccessException e) {\n-                        //this can\u0027t happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n-                    }\n+            if (testClass.isArray()) {\n+                append(lhs, rhs);\n+            } else {\n+                reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                    testClass \u003d testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n                 }\n             }\n-        } finally {\n-            unregister(lhs, rhs);\n+        } catch (final IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and\n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            isEquals \u003d false;\n+            return this;\n         }\n+        return this;\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Remove useless parentheses\n",
      "commitDate": "2016-09-19, 7:56 a.m.",
      "commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2016-08-21, 1:14 p.m.",
      "commitNameOld": "b2c1afce7eb13ea44fc7d25562cc3bb83cc91b2f",
      "commitAuthorOld": "Philippe Marschall",
      "daysBetweenCommits": 28.78,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class\u003c?\u003e clazz,\n        final EqualsBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        if (isRegistered(lhs, rhs)) {\n            return;\n        }\n\n        try {\n            register(lhs, rhs);\n            final Field[] fields \u003d clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                final Field f \u003d fields[i];\n                if (!ArrayUtils.contains(excludeFields, f.getName())\n                    \u0026\u0026 !f.getName().contains(\"$\")\n                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())\n                    \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n                    try {\n                        builder.append(f.get(lhs), f.get(rhs));\n                    } catch (final IllegalAccessException e) {\n                        //this can\u0027t happen. Would get a Security exception instead\n                        //throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(lhs, rhs);\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 397,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,36 +1,36 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class\u003c?\u003e clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             final Field[] fields \u003d clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                 final Field f \u003d fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     \u0026\u0026 !f.getName().contains(\"$\")\n                     \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))\n-                    \u0026\u0026 (!f.isAnnotationPresent(EqualsExclude.class))) {\n+                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())\n+                    \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (final IllegalAccessException e) {\n                         //this can\u0027t happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aeb6f86bcdec061ee9c6be96066fa19c56523490": {
      "type": "Ybodychange",
      "commitMessage": "EqualsExlcude notation, HashCodeExclude notation and ToStringExludeNotation\n",
      "commitDate": "2015-05-03, 2:59 p.m.",
      "commitName": "aeb6f86bcdec061ee9c6be96066fa19c56523490",
      "commitAuthor": "Felipe Adorno",
      "commitDateOld": "2015-04-06, 3:44 p.m.",
      "commitNameOld": "11491d355da8a851d6badb6348b10d8c4acc9d8e",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 26.97,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class\u003c?\u003e clazz,\n        final EqualsBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        if (isRegistered(lhs, rhs)) {\n            return;\n        }\n\n        try {\n            register(lhs, rhs);\n            final Field[] fields \u003d clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                final Field f \u003d fields[i];\n                if (!ArrayUtils.contains(excludeFields, f.getName())\n                    \u0026\u0026 !f.getName().contains(\"$\")\n                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))\n                    \u0026\u0026 (!f.isAnnotationPresent(EqualsExclude.class))) {\n                    try {\n                        builder.append(f.get(lhs), f.get(rhs));\n                    } catch (final IllegalAccessException e) {\n                        //this can\u0027t happen. Would get a Security exception instead\n                        //throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(lhs, rhs);\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 393,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,35 +1,36 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class\u003c?\u003e clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             final Field[] fields \u003d clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                 final Field f \u003d fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     \u0026\u0026 !f.getName().contains(\"$\")\n                     \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())) {\n+                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))\n+                    \u0026\u0026 (!f.isAnnotationPresent(EqualsExclude.class))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (final IllegalAccessException e) {\n                         //this can\u0027t happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9072a7615a54d5e753cf088326d9e14f1a5a6751": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Useless parentheses\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671669 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015-04-06, 3:41 p.m.",
      "commitName": "9072a7615a54d5e753cf088326d9e14f1a5a6751",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2015-04-06, 3:37 p.m.",
      "commitNameOld": "f525bc3ccd9cfb69603bd9778998263a458415d0",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class\u003c?\u003e clazz,\n        final EqualsBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        if (isRegistered(lhs, rhs)) {\n            return;\n        }\n\n        try {\n            register(lhs, rhs);\n            final Field[] fields \u003d clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                final Field f \u003d fields[i];\n                if (!ArrayUtils.contains(excludeFields, f.getName())\n                    \u0026\u0026 !f.getName().contains(\"$\")\n                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())) {\n                    try {\n                        builder.append(f.get(lhs), f.get(rhs));\n                    } catch (final IllegalAccessException e) {\n                        //this can\u0027t happen. Would get a Security exception instead\n                        //throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(lhs, rhs);\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 393,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,35 +1,35 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class\u003c?\u003e clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             final Field[] fields \u003d clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                 final Field f \u003d fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    \u0026\u0026 (!f.getName().contains(\"$\"))\n+                    \u0026\u0026 !f.getName().contains(\"$\")\n                     \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+                    \u0026\u0026 !Modifier.isStatic(f.getModifiers())) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (final IllegalAccessException e) {\n                         //this can\u0027t happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f525bc3ccd9cfb69603bd9778998263a458415d0": {
      "type": "Ybodychange",
      "commitMessage": "Use not String.contains instead of indexOf \u003d\u003d -1\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015-04-06, 3:37 p.m.",
      "commitName": "f525bc3ccd9cfb69603bd9778998263a458415d0",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014-09-10, 7:32 a.m.",
      "commitNameOld": "2154d5fbf8cc02cc4d51b63d6a532af06cccd0fc",
      "commitAuthorOld": "Duncan Jones",
      "daysBetweenCommits": 208.34,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class\u003c?\u003e clazz,\n        final EqualsBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        if (isRegistered(lhs, rhs)) {\n            return;\n        }\n\n        try {\n            register(lhs, rhs);\n            final Field[] fields \u003d clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                final Field f \u003d fields[i];\n                if (!ArrayUtils.contains(excludeFields, f.getName())\n                    \u0026\u0026 (!f.getName().contains(\"$\"))\n                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                    try {\n                        builder.append(f.get(lhs), f.get(rhs));\n                    } catch (final IllegalAccessException e) {\n                        //this can\u0027t happen. Would get a Security exception instead\n                        //throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(lhs, rhs);\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 393,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,35 +1,35 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class\u003c?\u003e clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             final Field[] fields \u003d clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                 final Field f \u003d fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n-                    \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n+                    \u0026\u0026 (!f.getName().contains(\"$\"))\n                     \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                     \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (final IllegalAccessException e) {\n                         //this can\u0027t happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:09 a.m.",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013-01-22, 2:07 a.m.",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class\u003c?\u003e clazz,\n        final EqualsBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        if (isRegistered(lhs, rhs)) {\n            return;\n        }\n\n        try {\n            register(lhs, rhs);\n            final Field[] fields \u003d clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                final Field f \u003d fields[i];\n                if (!ArrayUtils.contains(excludeFields, f.getName())\n                    \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                    try {\n                        builder.append(f.get(lhs), f.get(rhs));\n                    } catch (final IllegalAccessException e) {\n                        //this can\u0027t happen. Would get a Security exception instead\n                        //throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(lhs, rhs);\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 384,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,35 +1,35 @@\n     private static void reflectionAppend(\n         final Object lhs,\n         final Object rhs,\n         final Class\u003c?\u003e clazz,\n         final EqualsBuilder builder,\n         final boolean useTransients,\n         final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n-            Field[] fields \u003d clazz.getDeclaredFields();\n+            final Field[] fields \u003d clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-                Field f \u003d fields[i];\n+                final Field f \u003d fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                     \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                     \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException e) {\n+                    } catch (final IllegalAccessException e) {\n                         //this can\u0027t happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:07 a.m.",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012-04-05, 1:53 p.m.",
      "commitNameOld": "b819343483d33cc529b785935cea9bfc2fc080e5",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 291.55,
      "commitsBetweenForRepo": 179,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class\u003c?\u003e clazz,\n        final EqualsBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        if (isRegistered(lhs, rhs)) {\n            return;\n        }\n\n        try {\n            register(lhs, rhs);\n            Field[] fields \u003d clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                Field f \u003d fields[i];\n                if (!ArrayUtils.contains(excludeFields, f.getName())\n                    \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                    try {\n                        builder.append(f.get(lhs), f.get(rhs));\n                    } catch (IllegalAccessException e) {\n                        //this can\u0027t happen. Would get a Security exception instead\n                        //throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(lhs, rhs);\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 384,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,35 +1,35 @@\n     private static void reflectionAppend(\n-        Object lhs,\n-        Object rhs,\n-        Class\u003c?\u003e clazz,\n-        EqualsBuilder builder,\n-        boolean useTransients,\n-        String[] excludeFields) {\n+        final Object lhs,\n+        final Object rhs,\n+        final Class\u003c?\u003e clazz,\n+        final EqualsBuilder builder,\n+        final boolean useTransients,\n+        final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n         }\n \n         try {\n             register(lhs, rhs);\n             Field[] fields \u003d clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                 Field f \u003d fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                     \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                     \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n                     } catch (IllegalAccessException e) {\n                         //this can\u0027t happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         } finally {\n             unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[lhs-Object, rhs-Object, clazz-Class\u003c?\u003e, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]",
        "newValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final), clazz-Class\u003c?\u003e(modifiers-final), builder-EqualsBuilder(modifiers-final), useTransients-boolean(modifiers-final), excludeFields-String[](modifiers-final)]"
      }
    },
    "1a60c21395fe7648188d1c91f62ac7baefa12742": {
      "type": "Ybodychange",
      "commitMessage": "Applying the copy of the HashCodeBuilder code to stop cyclic references over to EqualsBuilder per LANG-606 and Oliver Sauder\u0027s patch\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@925671 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-03-20, 4:16 p.m.",
      "commitName": "1a60c21395fe7648188d1c91f62ac7baefa12742",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2010-02-24, 8:28 p.m.",
      "commitNameOld": "43fca0d7499c99f9e82e0ee2e52b81acdc954f2c",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 23.78,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class\u003c?\u003e clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        \n        if (isRegistered(lhs, rhs)) {\n            return;\n        }\n        \n        try {\n            register(lhs, rhs);\n            Field[] fields \u003d clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n                Field f \u003d fields[i];\n                if (!ArrayUtils.contains(excludeFields, f.getName())\n                    \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                    try {\n                        builder.append(f.get(lhs), f.get(rhs));\n                    } catch (IllegalAccessException e) {\n                        //this can\u0027t happen. Would get a Security exception instead\n                        //throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(lhs, rhs);\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 442,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,25 +1,35 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class\u003c?\u003e clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n-        Field[] fields \u003d clazz.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-            Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName())\n-                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n-                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (IllegalAccessException e) {\n-                    //this can\u0027t happen. Would get a Security exception instead\n-                    //throw a runtime exception in case the impossible happens.\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+        \n+        if (isRegistered(lhs, rhs)) {\n+            return;\n+        }\n+        \n+        try {\n+            register(lhs, rhs);\n+            Field[] fields \u003d clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n+                Field f \u003d fields[i];\n+                if (!ArrayUtils.contains(excludeFields, f.getName())\n+                    \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n+                    \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                    \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+                    try {\n+                        builder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can\u0027t happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n                 }\n             }\n+        } finally {\n+            unregister(lhs, rhs);\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a": {
      "type": "Ybodychange",
      "commitMessage": "Replacing the creation of a List in the core of each Builder class to test contains on the excludeFields with a call to ArrayUtils.contains. Reported by Anthony Whitford in LANG-575\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@897421 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-01-09, 6:44 a.m.",
      "commitName": "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2010-01-02, 9:11 p.m.",
      "commitNameOld": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 6.4,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class\u003c?\u003e clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName())\n                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 315,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,26 +1,25 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class\u003c?\u003e clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n         Field[] fields \u003d clazz.getDeclaredFields();\n-        List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             Field f \u003d fields[i];\n-            if (!excludedFieldList.contains(f.getName())\n+            if (!ArrayUtils.contains(excludeFields, f.getName())\n                 \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                 \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can\u0027t happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-01-02, 9:11 p.m.",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010-01-02, 9:09 p.m.",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class\u003c?\u003e clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!excludedFieldList.contains(f.getName())\n                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 313,
      "functionName": "reflectionAppend",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
        "newPath": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-10, 6:33 a.m.",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-12-10, 6:31 a.m.",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class\u003c?\u003e clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!excludedFieldList.contains(f.getName())\n                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 313,
      "functionName": "reflectionAppend",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
        "newPath": "src/java/org/apache/commons/lang3/builder/EqualsBuilder.java"
      }
    },
    "ca3a3baa651465310d31824250318bd500fa9e8b": {
      "type": "Ybodychange",
      "commitMessage": "Genericizing excludeFieldList variablle - LANG-336\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@772548 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-05-07, 4:31 a.m.",
      "commitName": "ca3a3baa651465310d31824250318bd500fa9e8b",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-03-15, 11:35 p.m.",
      "commitNameOld": "654fb75d80a63fa551ced73c3b652f4120573590",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 52.21,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class\u003c?\u003e clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!excludedFieldList.contains(f.getName())\n                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 313,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,26 +1,26 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class\u003c?\u003e clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n         Field[] fields \u003d clazz.getDeclaredFields();\n-        List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n+        List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             Field f \u003d fields[i];\n             if (!excludedFieldList.contains(f.getName())\n                 \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                 \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can\u0027t happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "654fb75d80a63fa551ced73c3b652f4120573590": {
      "type": "Yparameterchange",
      "commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-03-15, 11:35 p.m.",
      "commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2008-11-06, 3:36 p.m.",
      "commitNameOld": "b1e8a26177324ece7c786da8cd063076bc131ea1",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 129.29,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class\u003c?\u003e clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!excludedFieldList.contains(f.getName())\n                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 313,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,26 +1,26 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n-        Class clazz,\n+        Class\u003c?\u003e clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n         Field[] fields \u003d clazz.getDeclaredFields();\n         List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             Field f \u003d fields[i];\n             if (!excludedFieldList.contains(f.getName())\n                 \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                 \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can\u0027t happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]",
        "newValue": "[lhs-Object, rhs-Object, clazz-Class\u003c?\u003e, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]"
      }
    },
    "8393f10b791c4fd28a1031f0a6427a2c9af04977": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-04-24, 3:00 a.m.",
      "commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
      "commitAuthor": "Henri Yandell",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006-04-24, 3:00 a.m.",
          "commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2005-04-14, 12:30 a.m.",
          "commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 375.1,
          "commitsBetweenForRepo": 266,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!excludedFieldList.contains(f.getName())\n                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
          "functionStartLine": 289,
          "functionName": "reflectionAppend",
          "diff": "@@ -1,23 +1,26 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class clazz,\n         EqualsBuilder builder,\n-        boolean useTransients) {\n+        boolean useTransients,\n+        String[] excludeFields) {\n         Field[] fields \u003d clazz.getDeclaredFields();\n+        List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             Field f \u003d fields[i];\n-            if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n+            if (!excludedFieldList.contains(f.getName())\n+                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                 \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can\u0027t happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean]",
            "newValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006-04-24, 3:00 a.m.",
          "commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2005-04-14, 12:30 a.m.",
          "commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 375.1,
          "commitsBetweenForRepo": 266,
          "commitsBetweenForFile": 1,
          "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!excludedFieldList.contains(f.getName())\n                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
          "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
          "functionStartLine": 289,
          "functionName": "reflectionAppend",
          "diff": "@@ -1,23 +1,26 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class clazz,\n         EqualsBuilder builder,\n-        boolean useTransients) {\n+        boolean useTransients,\n+        String[] excludeFields) {\n         Field[] fields \u003d clazz.getDeclaredFields();\n+        List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             Field f \u003d fields[i];\n-            if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n+            if (!excludedFieldList.contains(f.getName())\n+                \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                 \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can\u0027t happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d27569f61a49489dd72e4b8a1ed4b0648008b3d5": {
      "type": "Ybodychange",
      "commitMessage": "Severity\tDescription\tResource\tIn Folder\tLocation\tCreation Time\n\tThe static method setAccessible(AccessibleObject[], boolean) from the type AccessibleObject should be accessed directly \tEqualsBuilder.java\tApache Jakarta Commons/lang/src/java/org/apache/commons/lang/builder\tline 268\tJuly 19, 2003 6:10:35 PM\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137465 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-07-19, 9:11 p.m.",
      "commitName": "d27569f61a49489dd72e4b8a1ed4b0648008b3d5",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2003-07-14, 6:25 p.m.",
      "commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 5.12,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class clazz,\n        EqualsBuilder builder,\n        boolean useTransients) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 261,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,23 +1,23 @@\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class clazz,\n         EqualsBuilder builder,\n         boolean useTransients) {\n         Field[] fields \u003d clazz.getDeclaredFields();\n-        Field.setAccessible(fields, true);\n+        AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             Field f \u003d fields[i];\n             if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1)\n                 \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     //this can\u0027t happen. Would get a Security exception instead\n                     //throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "984bc76cd36138514e8c3c2cd494cd952d22dd13": {
      "type": "Ybodychange",
      "commitMessage": "Fix infinite recursion in inner classes reflection methods\nfrom Per Velschow\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137232 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-01-19, 1:49 p.m.",
      "commitName": "984bc76cd36138514e8c3c2cd494cd952d22dd13",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2003-01-19, 12:35 p.m.",
      "commitNameOld": "5c40090fecdacd9366bba7e3e29d94f213cf2633",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "    private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        Field.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026\n                (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026\n                (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can\u0027t happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 256,
      "functionName": "reflectionAppend",
      "diff": "@@ -1,17 +1,18 @@\n     private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n         Field[] fields \u003d clazz.getDeclaredFields();\n         Field.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             Field f \u003d fields[i];\n-            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n-                if (!Modifier.isStatic(f.getModifiers())) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException e) {\n-                        //this can\u0027t happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                    }\n+            if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026\n+                (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026\n+                (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can\u0027t happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c40090fecdacd9366bba7e3e29d94f213cf2633": {
      "type": "Yintroduced",
      "commitMessage": "Add superclass behaviour to builder classes\nfrom Gary Gregory\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137228 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-01-19, 12:35 p.m.",
      "commitName": "5c40090fecdacd9366bba7e3e29d94f213cf2633",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,17 @@\n+    private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n+        Field[] fields \u003d clazz.getDeclaredFields();\n+        Field.setAccessible(fields, true);\n+        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n+            Field f \u003d fields[i];\n+            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n+                if (!Modifier.isStatic(f.getModifiers())) {\n+                    try {\n+                        builder.append(f.get(lhs), f.get(rhs));\n+                    } catch (IllegalAccessException e) {\n+                        //this can\u0027t happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                    }\n+                }\n+            }\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n        Field[] fields \u003d clazz.getDeclaredFields();\n        Field.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n                if (!Modifier.isStatic(f.getModifiers())) {\n                    try {\n                        builder.append(f.get(lhs), f.get(rhs));\n                    } catch (IllegalAccessException e) {\n                        //this can\u0027t happen. Would get a Security exception instead\n                        //throw a runtime exception in case the impossible happens.\n                    }\n                }\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 256,
      "functionName": "reflectionAppend"
    }
  }
}