{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "H:\\Projects\\hibernate\\hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "SimpleValue.java",
  "functionName": "buildAttributeConverterTypeAdapter",
  "functionId": "buildAttributeConverterTypeAdapter",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
  "functionStartLine": 565,
  "functionEndLine": 660,
  "numCommitsSeen": 46,
  "timeTaken": 6060,
  "changeHistory": [
    "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54",
    "0d82dc7c8387a954edfa971af99c16a66e33c65a",
    "9229514ed407b1610a52ab7ba97806c435352ad2",
    "8f889e95d76f47945c9ec072fd08cb045767578c",
    "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f",
    "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
    "0cf66b85e03a997dc94f8f82598ca8edac04e889",
    "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
    "38c004431d006ac5173d0c095f97415b5e6267a6",
    "22730624fc267cd12bf1e6551158fa3057fd8d58",
    "498735aa3791097e0fc25e918d47336f359fa5ae",
    "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
    "9f86babd880b785b965f7f1b55d58dc6a6943ada",
    "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
    "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d"
  ],
  "changeHistoryShort": {
    "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54": "Ybodychange",
    "0d82dc7c8387a954edfa971af99c16a66e33c65a": "Ybodychange",
    "9229514ed407b1610a52ab7ba97806c435352ad2": "Ybodychange",
    "8f889e95d76f47945c9ec072fd08cb045767578c": "Ybodychange",
    "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f": "Ybodychange",
    "9aa164ed27b8338f592dee504a5793bc4e5bbfd9": "Ybodychange",
    "0cf66b85e03a997dc94f8f82598ca8edac04e889": "Ybodychange",
    "3ac508882c89ebd7c80af71d0e65ba26a017ebe3": "Ybodychange",
    "38c004431d006ac5173d0c095f97415b5e6267a6": "Ybodychange",
    "22730624fc267cd12bf1e6551158fa3057fd8d58": "Ybodychange",
    "498735aa3791097e0fc25e918d47336f359fa5ae": "Ybodychange",
    "1f6daa67854e1fd6c464fe3d2a98bda1047b252d": "Ybodychange",
    "9f86babd880b785b965f7f1b55d58dc6a6943ada": "Ybodychange",
    "bf168ca24ef0c328bd53d6d32e79f66b99ac56db": "Ybodychange",
    "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12410 - Cannot use AttributeConverter with spatial types\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018-03-30, 12:16 a.m.",
      "commitName": "c14180ea5b16b69cdd06eb5bb159f7da1ff4db54",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2018-03-28, 6:43 p.m.",
      "commitNameOld": "0d82dc7c8387a954edfa971af99c16a66e33c65a",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 1.23,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n\t\t\t\tnew JpaAttributeConverterCreationContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\t\t\treturn getMetadata()\n\t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n\t\t\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic org.hibernate.type.descriptor.java.spi.JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n\t\t\t\t\t\treturn metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\n\t\tfinal BasicJavaDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal SqlTypeDescriptor recommendedSqlType \u003d jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJdbcRecommendedSqlType(\n\t\t\t\t// todo (6.0) : handle the other JdbcRecommendedSqlTypeMappingContext methods\n\t\t\t\tmetadata::getTypeConfiguration\n\t\t);\n\t\tint jdbcTypeCode \u003d recommendedSqlType.getSqlType();\n\t\tif ( isLob() ) {\n\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata()\n\t\t\t\t.getMetadataBuildingOptions()\n\t\t\t\t.getServiceRegistry()\n\t\t\t\t.getService( JdbcServices.class )\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getDialect()\n\t\t\t\t.remapSqlTypeDescriptor(\n\t\t\t\t\t\tmetadata.getTypeConfiguration()\n\t\t\t\t\t\t\t\t.getSqlTypeDescriptorRegistry()\n\t\t\t\t\t\t\t\t.getDescriptor( jdbcTypeCode ) );\n\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 565,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,92 +1,96 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n \t\t\t\tnew JpaAttributeConverterCreationContext() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n \t\t\t\t\t\treturn getMetadata()\n \t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t\t\t\t\t.getServiceRegistry()\n \t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n \t\t\t\t\t}\n \n \t\t\t\t\t@Override\n-\t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n+\t\t\t\t\tpublic org.hibernate.type.descriptor.java.spi.JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n \t\t\t\t\t\treturn metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t);\n \n-\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n+\t\tfinal BasicJavaDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n-\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n+\t\tfinal SqlTypeDescriptor recommendedSqlType \u003d jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJdbcRecommendedSqlType(\n+\t\t\t\t// todo (6.0) : handle the other JdbcRecommendedSqlTypeMappingContext methods\n+\t\t\t\tmetadata::getTypeConfiguration\n+\t\t);\n+\t\tint jdbcTypeCode \u003d recommendedSqlType.getSqlType();\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata()\n \t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t.getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n \t\t\t\t.remapSqlTypeDescriptor(\n \t\t\t\t\t\tmetadata.getTypeConfiguration()\n \t\t\t\t\t\t\t\t.getSqlTypeDescriptorRegistry()\n \t\t\t\t\t\t\t\t.getDescriptor( jdbcTypeCode ) );\n \n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d82dc7c8387a954edfa971af99c16a66e33c65a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018-03-28, 6:43 p.m.",
      "commitName": "0d82dc7c8387a954edfa971af99c16a66e33c65a",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2018-03-28, 6:43 p.m.",
      "commitNameOld": "11462e786007f65f3cf9c2539e5b8259b05feaf3",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n\t\t\t\tnew JpaAttributeConverterCreationContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\t\t\treturn getMetadata()\n\t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n\t\t\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n\t\t\t\t\t\treturn metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n\t\tif ( isLob() ) {\n\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata()\n\t\t\t\t.getMetadataBuildingOptions()\n\t\t\t\t.getServiceRegistry()\n\t\t\t\t.getService( JdbcServices.class )\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getDialect()\n\t\t\t\t.remapSqlTypeDescriptor(\n\t\t\t\t\t\tmetadata.getTypeConfiguration()\n\t\t\t\t\t\t\t\t.getSqlTypeDescriptorRegistry()\n\t\t\t\t\t\t\t\t.getDescriptor( jdbcTypeCode ) );\n\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 565,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,89 +1,92 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n \t\t\t\tnew JpaAttributeConverterCreationContext() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n \t\t\t\t\t\treturn getMetadata()\n \t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t\t\t\t\t.getServiceRegistry()\n \t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n \t\t\t\t\t}\n \n \t\t\t\t\t@Override\n \t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n-\t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n+\t\t\t\t\t\treturn metadata.getTypeConfiguration().getJavaTypeDescriptorRegistry();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t);\n \n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata()\n \t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t.getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n-\t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n+\t\t\t\t.remapSqlTypeDescriptor(\n+\t\t\t\t\t\tmetadata.getTypeConfiguration()\n+\t\t\t\t\t\t\t\t.getSqlTypeDescriptorRegistry()\n+\t\t\t\t\t\t\t\t.getDescriptor( jdbcTypeCode ) );\n \n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9229514ed407b1610a52ab7ba97806c435352ad2": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018-03-28, 6:43 p.m.",
      "commitName": "9229514ed407b1610a52ab7ba97806c435352ad2",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2018-03-28, 6:43 p.m.",
      "commitNameOld": "8f889e95d76f47945c9ec072fd08cb045767578c",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n\t\t\t\tnew JpaAttributeConverterCreationContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\t\t\treturn getMetadata()\n\t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n\t\t\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n\t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n\t\tif ( isLob() ) {\n\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata()\n\t\t\t\t.getMetadataBuildingOptions()\n\t\t\t\t.getServiceRegistry()\n\t\t\t\t.getService( JdbcServices.class )\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getDialect()\n\t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 563,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,91 +1,89 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n \t\t\t\tnew JpaAttributeConverterCreationContext() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n-\t\t\t\t\t\treturn buildingContext\n-\t\t\t\t\t\t\t\t.getBootstrapContext()\n+\t\t\t\t\t\treturn getMetadata()\n \t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t\t\t\t\t.getServiceRegistry()\n \t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n \t\t\t\t\t}\n \n \t\t\t\t\t@Override\n \t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n \t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t);\n \n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n-\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d buildingContext\n-\t\t\t\t.getBootstrapContext()\n+\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d getMetadata()\n \t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t.getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n \t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n \n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8f889e95d76f47945c9ec072fd08cb045767578c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018-03-28, 6:43 p.m.",
      "commitName": "8f889e95d76f47945c9ec072fd08cb045767578c",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2018-03-07, 9:57 a.m.",
      "commitNameOld": "1e5a8d3c434c6791b89281c4ebf04ef08181fcd7",
      "commitAuthorOld": "Christian Beikov",
      "daysBetweenCommits": 21.32,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n\t\t\t\tnew JpaAttributeConverterCreationContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\t\t\treturn buildingContext\n\t\t\t\t\t\t\t\t.getBootstrapContext()\n\t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n\t\t\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n\t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n\t\tif ( isLob() ) {\n\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d buildingContext\n\t\t\t\t.getBootstrapContext()\n\t\t\t\t.getMetadataBuildingOptions()\n\t\t\t\t.getServiceRegistry()\n\t\t\t\t.getService( JdbcServices.class )\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getDialect()\n\t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 549,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,86 +1,91 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n \t\t\t\tnew JpaAttributeConverterCreationContext() {\n \t\t\t\t\t@Override\n \t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n-\t\t\t\t\t\treturn getMetadata().getMetadataBuildingOptions()\n+\t\t\t\t\t\treturn buildingContext\n+\t\t\t\t\t\t\t\t.getBootstrapContext()\n+\t\t\t\t\t\t\t\t.getMetadataBuildingOptions()\n \t\t\t\t\t\t\t\t.getServiceRegistry()\n \t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n \t\t\t\t\t}\n \n \t\t\t\t\t@Override\n \t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n \t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t);\n \n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n-\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry()\n+\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d buildingContext\n+\t\t\t\t.getBootstrapContext()\n+\t\t\t\t.getMetadataBuildingOptions()\n+\t\t\t\t.getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n \t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n \n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n \t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12135 - Support for AttributeConverters as CDI beans\n\ninitial work to get AttributeConverter support to be able to integrate with ManagedBeanRegistry.  There is a lot of \"infrastructure\" changes because the old code assumed we could instantiate the converter as soon as we knew the class which precludes lookup in the registry later.\n",
      "commitDate": "2017-12-15, 7:25 p.m.",
      "commitName": "90cabb43ad8b186d73cb6b310fb2fd6774ffe44f",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2016-09-29, 12:27 p.m.",
      "commitNameOld": "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 442.33,
      "commitsBetweenForRepo": 985,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n\t\t\t\tnew JpaAttributeConverterCreationContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\t\t\treturn getMetadata().getMetadataBuildingOptions()\n\t\t\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n\t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n\t\tif ( isLob() ) {\n\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry()\n\t\t\t\t.getService( JdbcServices.class )\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getDialect()\n\t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tjpaAttributeConverter,\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 535,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,81 +1,86 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n-\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n-\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n+\t\tfinal JpaAttributeConverter jpaAttributeConverter \u003d attributeConverterDescriptor.createJpaAttributeConverter(\n+\t\t\t\tnew JpaAttributeConverterCreationContext() {\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n+\t\t\t\t\t\treturn getMetadata().getMetadataBuildingOptions()\n+\t\t\t\t\t\t\t\t.getServiceRegistry()\n+\t\t\t\t\t\t\t\t.getService( ManagedBeanRegistry.class );\n+\t\t\t\t\t}\n \n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic JavaTypeDescriptorRegistry getJavaTypeDescriptorRegistry() {\n+\t\t\t\t\t\treturn JavaTypeDescriptorRegistry.INSTANCE;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t);\n \n-\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n-\t\t// the AttributeConverter to resolve the corresponding descriptor.\n-\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n+\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d jpaAttributeConverter.getDomainJavaTypeDescriptor();\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n-\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( jpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType() );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n+\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaTypeDescriptor.getJavaType() ) ) {\n \t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \n \t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry()\n \t\t\t\t.getService( JdbcServices.class )\n \t\t\t\t.getJdbcEnvironment()\n \t\t\t\t.getDialect()\n \t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n \n-\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n-\t\t// \t\tillustration, this should be the type descriptor for Strings\n-\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n-\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n-\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n+\t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptor,\n-\t\t\t\tintermediateJavaTypeDescriptor\n+\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor()\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n-\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n+\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + jpaAttributeConverter.getConverterJavaTypeDescriptor().getJavaType().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n-\t\t\t\tentityAttributeJavaType.getSimpleName(),\n-\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n+\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType().getSimpleName(),\n+\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType().getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n-\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n+\t\t\t\tjpaAttributeConverter,\n \t\t\t\tsqlTypeDescriptorAdapter,\n-\t\t\t\tentityAttributeJavaType,\n-\t\t\t\tdatabaseColumnJavaType,\n+\t\t\t\tjpaAttributeConverter.getDomainJavaTypeDescriptor().getJavaType(),\n+\t\t\t\tjpaAttributeConverter.getRelationalJavaTypeDescriptor().getJavaType(),\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9aa164ed27b8338f592dee504a5793bc4e5bbfd9": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10818 - Allow AttributeConverter on attributes marked as Lob (REALLY this time)\n",
      "commitDate": "2016-09-29, 12:27 p.m.",
      "commitName": "9aa164ed27b8338f592dee504a5793bc4e5bbfd9",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2016-07-14, 6:16 p.m.",
      "commitNameOld": "c893577efceff237f84d7200e1ef1a2895c95639",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 76.76,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\tif ( isLob() ) {\n\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry()\n\t\t\t\t.getService( JdbcServices.class )\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getDialect()\n\t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaType,\n\t\t\t\tdatabaseColumnJavaType,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 526,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,74 +1,81 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n \t\tfinal Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n \t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n-\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n-\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n+\n+\t\t// find the standard SqlTypeDescriptor for that JDBC type code (allow itr to be remapped if needed!)\n+\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d metadata.getMetadataBuildingOptions().getServiceRegistry()\n+\t\t\t\t.getService( JdbcServices.class )\n+\t\t\t\t.getJdbcEnvironment()\n+\t\t\t\t.getDialect()\n+\t\t\t\t.remapSqlTypeDescriptor( SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ) );\n+\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n+\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0cf66b85e03a997dc94f8f82598ca8edac04e889": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10050 - AttributeConverter should supports ParameterizedType if autoApply is true\n",
      "commitDate": "2015-10-06, 5:07 p.m.",
      "commitName": "0cf66b85e03a997dc94f8f82598ca8edac04e889",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015-10-03, 2:44 p.m.",
      "commitNameOld": "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\tif ( isLob() ) {\n\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaType,\n\t\t\t\tdatabaseColumnJavaType,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 476,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,74 +1,74 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n-\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n-\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n+\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDescriptor.getDomainType();\n+\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDescriptor.getJdbcType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\tif ( isLob() ) {\n \t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n \t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n \t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\tString.format(\n \t\t\t\t\t\t\t\t\tLocale.ROOT,\n \t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n \t\t\t\t\t\t\t\t\tjdbcTypeCode,\n \t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n \t\t\t\t\t\t\t)\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n-\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n-\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n+\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDescriptor.getAttributeConverter().getClass().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n-\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tattributeConverterDescriptor.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ac508882c89ebd7c80af71d0e65ba26a017ebe3": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9615 - Allow AttributeConverter on attributes marked as Lob\n",
      "commitDate": "2015-10-03, 2:44 p.m.",
      "commitName": "3ac508882c89ebd7c80af71d0e65ba26a017ebe3",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015-08-26, 3:55 p.m.",
      "commitNameOld": "5f5e5f82c4d3f64e799509d71acd08284e60670c",
      "commitAuthorOld": "Kamil Szymanski",
      "daysBetweenCommits": 37.95,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\tif ( isLob() ) {\n\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaType,\n\t\t\t\tdatabaseColumnJavaType,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 475,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,54 +1,74 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\tif ( isLob() ) {\n+\t\t\tif ( LobTypeMappings.INSTANCE.hasCorrespondingLobCode( jdbcTypeCode ) ) {\n+\t\t\t\tjdbcTypeCode \u003d LobTypeMappings.INSTANCE.getCorrespondingLobCode( jdbcTypeCode );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tif ( Serializable.class.isAssignableFrom( entityAttributeJavaType ) ) {\n+\t\t\t\t\tjdbcTypeCode \u003d Types.BLOB;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\tString.format(\n+\t\t\t\t\t\t\t\t\tLocale.ROOT,\n+\t\t\t\t\t\t\t\t\t\"JDBC type-code [%s (%s)] not known to have a corresponding LOB equivalent, and Java type is not Serializable (to use BLOB)\",\n+\t\t\t\t\t\t\t\t\tjdbcTypeCode,\n+\t\t\t\t\t\t\t\t\tJdbcTypeNameMapper.getTypeName( jdbcTypeCode )\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tif ( isNationalized() ) {\n \t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n \t\t}\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "38c004431d006ac5173d0c095f97415b5e6267a6": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9599 - AnnotationException occurs when applying @Nationalized and @Convert annotations to the same field\n",
      "commitDate": "2015-03-20, 5:55 p.m.",
      "commitName": "38c004431d006ac5173d0c095f97415b5e6267a6",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015-03-20, 12:17 p.m.",
      "commitNameOld": "22730624fc267cd12bf1e6551158fa3057fd8d58",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\tif ( isNationalized() ) {\n\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n\t\t}\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaType,\n\t\t\t\tdatabaseColumnJavaType,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 457,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,51 +1,54 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n-\t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\tint jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\tif ( isNationalized() ) {\n+\t\t\tjdbcTypeCode \u003d NationalizedTypeMappings.INSTANCE.getCorrespondingNationalizedCode( jdbcTypeCode );\n+\t\t}\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n \t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tdescription,\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22730624fc267cd12bf1e6551158fa3057fd8d58": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9042 - Envers fails with @Converter and AttributeConverter\n",
      "commitDate": "2015-03-20, 12:17 p.m.",
      "commitName": "22730624fc267cd12bf1e6551158fa3057fd8d58",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015-03-10, 5:53 p.m.",
      "commitNameOld": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 9.77,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n\t\tfinal String description \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tdescription,\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaType,\n\t\t\t\tdatabaseColumnJavaType,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 442,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,49 +1,51 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n-\t\tfinal String name \u003d String.format(\n+\t\tfinal String name \u003d AttributeConverterTypeAdapter.NAME_PREFIX + attributeConverterDefinition.getAttributeConverter().getClass().getName();\n+\t\tfinal String description \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n+\t\t\t\tdescription,\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaType,\n \t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "498735aa3791097e0fc25e918d47336f359fa5ae": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8478 - AttributeConverters need to be applied to JPQL and Criteria queries\n",
      "commitDate": "2013-09-23, 1:55 p.m.",
      "commitName": "498735aa3791097e0fc25e918d47336f359fa5ae",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013-09-06, 2:38 p.m.",
      "commitNameOld": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 16.97,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaType,\n\t\t\t\tdatabaseColumnJavaType,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 405,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,47 +1,49 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n \t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n+\t\t\t\tentityAttributeJavaType,\n+\t\t\t\tdatabaseColumnJavaType,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1f6daa67854e1fd6c464fe3d2a98bda1047b252d": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8469 - Application of JPA 2.1 AttributeConverters\n",
      "commitDate": "2013-09-06, 2:38 p.m.",
      "commitName": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013-08-22, 10:27 a.m.",
      "commitNameOld": "9f86babd880b785b965f7f1b55d58dc6a6943ada",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 15.17,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 405,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,47 +1,47 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n-\t\tfinal Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n-\t\tfinal Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n+\t\tfinal Class entityAttributeJavaType \u003d attributeConverterDefinition.getEntityAttributeType();\n+\t\tfinal Class databaseColumnJavaType \u003d attributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n-\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d String.format(\n \t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n \t\t\t\tentityAttributeJavaType.getSimpleName(),\n \t\t\t\tdatabaseColumnJavaType.getSimpleName()\n \t\t);\n \t\treturn new AttributeConverterTypeAdapter(\n \t\t\t\tname,\n-\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tattributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptorAdapter,\n \t\t\t\tentityAttributeJavaTypeDescriptor\n \t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9f86babd880b785b965f7f1b55d58dc6a6943ada": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8111 - AttributeConverter doesn\u0027t override built-in type mappings\n",
      "commitDate": "2013-08-22, 10:27 a.m.",
      "commitName": "9f86babd880b785b965f7f1b55d58dc6a6943ada",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013-08-19, 5:07 p.m.",
      "commitNameOld": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 2.72,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d String.format(\n\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n\t\t\t\tentityAttributeJavaType.getSimpleName(),\n\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n\t\t);\n\t\treturn new AttributeConverterTypeAdapter(\n\t\t\t\tname,\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptorAdapter,\n\t\t\t\tentityAttributeJavaTypeDescriptor\n\t\t);\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 405,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,38 +1,47 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n \t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n-\t\tfinal String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n-\t\treturn new AttributeConverterTypeAdapter( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name );\n+\t\tfinal String name \u003d String.format(\n+\t\t\t\t\"BasicType adapter for AttributeConverter\u003c%s,%s\u003e\",\n+\t\t\t\tentityAttributeJavaType.getSimpleName(),\n+\t\t\t\tdatabaseColumnJavaType.getSimpleName()\n+\t\t);\n+\t\treturn new AttributeConverterTypeAdapter(\n+\t\t\t\tname,\n+\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tsqlTypeDescriptorAdapter,\n+\t\t\t\tentityAttributeJavaTypeDescriptor\n+\t\t);\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bf168ca24ef0c328bd53d6d32e79f66b99ac56db": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8111 - AttributeConverter doesn\u0027t override built-in type mappings\n",
      "commitDate": "2013-08-19, 5:07 p.m.",
      "commitName": "bf168ca24ef0c328bd53d6d32e79f66b99ac56db",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013-08-19, 3:54 p.m.",
      "commitNameOld": "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n\t\treturn new AttributeConverterTypeAdapter( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name );\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 405,
      "functionName": "buildAttributeConverterTypeAdapter",
      "diff": "@@ -1,47 +1,38 @@\n \tprivate Type buildAttributeConverterTypeAdapter() {\n \t\t// todo : validate the number of columns present here?\n \n \t\tfinal Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n \t\tfinal Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n \n \n \t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n \t\t// the AttributeConverter to resolve the corresponding descriptor.\n \t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n \n \n \t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n \t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n \t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n \t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n \t\t// \t\tVARCHAR/CHAR\n \t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n \t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n \t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n \t\t// \t\tillustration, this should be the type descriptor for Strings\n \t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n \t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n \t\t// \t\tprocess...\n \t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n \t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n \t\t\t\tsqlTypeDescriptor,\n \t\t\t\tintermediateJavaTypeDescriptor\n \t\t);\n \n+\t\t// todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n \n \t\tfinal String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n-\t\tfinal Type type \u003d new AbstractSingleColumnStandardBasicType( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor ) {\n-\t\t\t@Override\n-\t\t\tpublic String getName() {\n-\t\t\t\treturn name;\n-\t\t\t}\n-\t\t};\n-\t\tlog.debug( \"Created : \" + name );\n-\n-\t\t// todo : cache the BasicType we just created in case that AttributeConverter is applied multiple times.\n-\n-\t\treturn type;\n+\t\treturn new AttributeConverterTypeAdapter( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name );\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d": {
      "type": "Yintroduced",
      "commitMessage": "HHH-8111 - AttributeConverter doesn\u0027t override built-in type mappings\n",
      "commitDate": "2013-08-19, 3:54 p.m.",
      "commitName": "7bcf161d36d5b1e59fba1ae32e8e2d692c2fd33d",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,47 @@\n+\tprivate Type buildAttributeConverterTypeAdapter() {\n+\t\t// todo : validate the number of columns present here?\n+\n+\t\tfinal Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n+\t\tfinal Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n+\n+\n+\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n+\t\t// the AttributeConverter to resolve the corresponding descriptor.\n+\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n+\n+\n+\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n+\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n+\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n+\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n+\t\t// \t\tVARCHAR/CHAR\n+\t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n+\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n+\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n+\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n+\t\t// \t\tillustration, this should be the type descriptor for Strings\n+\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n+\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n+\t\t// \t\tprocess...\n+\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n+\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n+\t\t\t\tsqlTypeDescriptor,\n+\t\t\t\tintermediateJavaTypeDescriptor\n+\t\t);\n+\n+\n+\t\tfinal String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n+\t\tfinal Type type \u003d new AbstractSingleColumnStandardBasicType( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor ) {\n+\t\t\t@Override\n+\t\t\tpublic String getName() {\n+\t\t\t\treturn name;\n+\t\t\t}\n+\t\t};\n+\t\tlog.debug( \"Created : \" + name );\n+\n+\t\t// todo : cache the BasicType we just created in case that AttributeConverter is applied multiple times.\n+\n+\t\treturn type;\n+\t}\n\\ No newline at end of file\n",
      "actualSource": "\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t// todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType \u003d jpaAttributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType \u003d jpaAttributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t// resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t// the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t// build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer \u003c-\u003e String\n\t\t//\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t//\t\tcorresponding to the AttributeConverter\u0027s declared \"databaseColumnJavaType\" (how we read that value out\n\t\t// \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t// \t\tVARCHAR/CHAR\n\t\tfinal int jdbcTypeCode \u003d JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t// find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor \u003d SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t// find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t// \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor \u003d JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t// and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction\n\t\t// \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter \u003d new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\n\t\tfinal String name \u003d \"BasicType adapter for AttributeConverter\u003c\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \"\u003e\";\n\t\tfinal Type type \u003d new AbstractSingleColumnStandardBasicType( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor ) {\n\t\t\t@Override\n\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t};\n\t\tlog.debug( \"Created : \" + name );\n\n\t\t// todo : cache the BasicType we just created in case that AttributeConverter is applied multiple times.\n\n\t\treturn type;\n\t}",
      "path": "hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java",
      "functionStartLine": 415,
      "functionName": "buildAttributeConverterTypeAdapter"
    }
  }
}