{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "H:\\Projects\\spring-projects\\spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "ConfigurationClassPostProcessor.java",
  "functionName": "processConfigBeanDefinitions",
  "functionId": "processConfigBeanDefinitions___registry-BeanDefinitionRegistry",
  "sourceFilePath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
  "functionStartLine": 261,
  "functionEndLine": 362,
  "numCommitsSeen": 229,
  "timeTaken": 9158,
  "changeHistory": [
    "4fef1fe820627e6462413f4c4b658d24146367a2",
    "139dc1d373cc6e32ee6b516504064a2c87e0008a",
    "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
    "fc64b8040f7c76f2bc85387cf944436424ce408c",
    "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
    "7818c650ba3ad567cff2975b408509679d03e663",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
    "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
    "4c59d85f690a29c45c644f9c3f13010d5cba84ed",
    "abc343f4076d45172587197480c41f79c23f3aac",
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
    "71c6eb2bb594f29803b6ec4a50de875def98be86",
    "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
    "eed1a323d10de122a08db26192dc602f9fb173f8",
    "e95bd9e25086bf1dad37f8d08293c948621faf6b",
    "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
    "239ce1466ce118294f5c7b8e842a80815fd813de",
    "7c7fdb07363791fb3c72f4946839f4c166196ebe",
    "b257253a2b6890ef532f27a662c441fc4fd21f3b",
    "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6",
    "0a42c80c1151380f7f492ec75de5648cfe62d250",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "4520ea8690fa8769a2d45658883eac51ea2453ed",
    "6fcea8b99da45f287149796ef2598f0d71758793",
    "57206db15271f865b542264c74980e6cbb4681fd",
    "c8bc54e0ccad49f0785856f911349283619eb8ba",
    "d0c31ad84cffd7af718a45d679483a1c51f9e552",
    "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
    "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
    "f480333d31d8307b8c96409e7bb4f06ec0cab0ca",
    "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
    "0a4463fb71e6901a943a5bafc9d1957da2229333",
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
    "a6124793fc44779b569fbbba6fd4ec8804b56558",
    "cea8f7f69e8939d4d20073862890f0b1c1824499",
    "b5d21108da24f8344be3bc708c7afdfca9a1d089",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
    "14bd47551900ced88eeacf2a5f63c187ff72028c",
    "cc713ad5241a90bc66b96364b91e5439f1ae6cb6",
    "1697932c57af5389fe07971e91866980e966403f",
    "2c0c523d7099ed1ad77864242f25d30e218b2a95",
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
    "ef02c61e581dcd1f3cf110608da72ed133777d62",
    "dc191bec2dfceb7ee052ac238c84eb564d27e1ee",
    "2e7e98248724f5f4fc054617765053e7d7b978cd",
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
    "c593f063970df90d7de7b85c6da5733aadcafde6",
    "6deb1acab435d18f024e07a564ac77147729e0ec",
    "d4fdad2202a16e2df11aefa2632b781ecef020ea",
    "e48fe0d89271113bcac4e7c41e86cb1d8230594e"
  ],
  "changeHistoryShort": {
    "4fef1fe820627e6462413f4c4b658d24146367a2": "Ybodychange",
    "139dc1d373cc6e32ee6b516504064a2c87e0008a": "Ybodychange",
    "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668": "Ybodychange",
    "fc64b8040f7c76f2bc85387cf944436424ce408c": "Ybodychange",
    "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3": "Ybodychange",
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ybodychange",
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038": "Ybodychange",
    "7818c650ba3ad567cff2975b408509679d03e663": "Ybodychange",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": "Ybodychange",
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc": "Ybodychange",
    "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d": "Ybodychange",
    "4c59d85f690a29c45c644f9c3f13010d5cba84ed": "Ybodychange",
    "abc343f4076d45172587197480c41f79c23f3aac": "Ybodychange",
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6": "Ybodychange",
    "71c6eb2bb594f29803b6ec4a50de875def98be86": "Ybodychange",
    "b6255128bf7a32384f03e985d79b8bb03c3dd8a0": "Ybodychange",
    "eed1a323d10de122a08db26192dc602f9fb173f8": "Ybodychange",
    "e95bd9e25086bf1dad37f8d08293c948621faf6b": "Ybodychange",
    "5efe894ee4969a7c3780a2fd4d2ceab695777c50": "Ybodychange",
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": "Ybodychange",
    "239ce1466ce118294f5c7b8e842a80815fd813de": "Ybodychange",
    "7c7fdb07363791fb3c72f4946839f4c166196ebe": "Ybodychange",
    "b257253a2b6890ef532f27a662c441fc4fd21f3b": "Ybodychange",
    "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6": "Ybodychange",
    "0a42c80c1151380f7f492ec75de5648cfe62d250": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "4520ea8690fa8769a2d45658883eac51ea2453ed": "Ymultichange(Yparameterchange,Ybodychange)",
    "6fcea8b99da45f287149796ef2598f0d71758793": "Ymultichange(Yparameterchange,Ybodychange)",
    "57206db15271f865b542264c74980e6cbb4681fd": "Ybodychange",
    "c8bc54e0ccad49f0785856f911349283619eb8ba": "Ybodychange",
    "d0c31ad84cffd7af718a45d679483a1c51f9e552": "Ybodychange",
    "cdb01cbd3795f273b751d0f0a45caa22d07c62da": "Ybodychange",
    "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4": "Ymultichange(Yparameterchange,Ybodychange)",
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592": "Ymultichange(Yparameterchange,Ybodychange)",
    "f480333d31d8307b8c96409e7bb4f06ec0cab0ca": "Ybodychange",
    "fbd797e50b2f1c5b0dfef944ee218d826f1a0694": "Ybodychange",
    "0a4463fb71e6901a943a5bafc9d1957da2229333": "Ybodychange",
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0": "Ybodychange",
    "a6124793fc44779b569fbbba6fd4ec8804b56558": "Ymodifierchange",
    "cea8f7f69e8939d4d20073862890f0b1c1824499": "Ymodifierchange",
    "b5d21108da24f8344be3bc708c7afdfca9a1d089": "Ybodychange",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": "Ybodychange",
    "14bd47551900ced88eeacf2a5f63c187ff72028c": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "cc713ad5241a90bc66b96364b91e5439f1ae6cb6": "Ybodychange",
    "1697932c57af5389fe07971e91866980e966403f": "Yfilerename",
    "2c0c523d7099ed1ad77864242f25d30e218b2a95": "Ybodychange",
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7": "Yfilerename",
    "ef02c61e581dcd1f3cf110608da72ed133777d62": "Yfilerename",
    "dc191bec2dfceb7ee052ac238c84eb564d27e1ee": "Ybodychange",
    "2e7e98248724f5f4fc054617765053e7d7b978cd": "Yfilerename",
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4": "Ybodychange",
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "c593f063970df90d7de7b85c6da5733aadcafde6": "Yfilerename",
    "6deb1acab435d18f024e07a564ac77147729e0ec": "Ybodychange",
    "d4fdad2202a16e2df11aefa2632b781ecef020ea": "Ymultichange(Yparameterchange,Ybodychange)",
    "e48fe0d89271113bcac4e7c41e86cb1d8230594e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4fef1fe820627e6462413f4c4b658d24146367a2": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2018-03-16, 1:49 p.m.",
      "commitName": "4fef1fe820627e6462413f4c4b658d24146367a2",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018-03-08, 12:11 p.m.",
      "commitNameOld": "139dc1d373cc6e32ee6b516504064a2c87e0008a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 8.03,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tconfigCandidates.sort((bd1, bd2) -\u003e {\n\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn Integer.compare(i1, i2);\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator !\u003d null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment \u003d\u003d null) {\n\t\t\tthis.environment \u003d new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr !\u003d null \u0026\u0026 !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 262,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,102 +1,102 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tconfigCandidates.sort((bd1, bd2) -\u003e {\n \t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n-\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n+\t\t\treturn Integer.compare(i1, i2);\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator !\u003d null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (this.environment \u003d\u003d null) {\n \t\t\tthis.environment \u003d new StandardEnvironment();\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr !\u003d null \u0026\u0026 !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "139dc1d373cc6e32ee6b516504064a2c87e0008a": {
      "type": "Ybodychange",
      "commitMessage": "Polishing (collapsed if checks, consistent downcasts, refined javadoc)\n",
      "commitDate": "2018-03-08, 12:11 p.m.",
      "commitName": "139dc1d373cc6e32ee6b516504064a2c87e0008a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-06-29, 7:54 p.m.",
      "commitNameOld": "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 251.72,
      "commitsBetweenForRepo": 1211,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tconfigCandidates.sort((bd1, bd2) -\u003e {\n\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator !\u003d null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment \u003d\u003d null) {\n\t\t\tthis.environment \u003d new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr !\u003d null \u0026\u0026 !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 262,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,104 +1,102 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tconfigCandidates.sort((bd1, bd2) -\u003e {\n \t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator !\u003d null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (this.environment \u003d\u003d null) {\n \t\t\tthis.environment \u003d new StandardEnvironment();\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n-\t\tif (sbr !\u003d null) {\n-\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n-\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n-\t\t\t}\n+\t\tif (sbr !\u003d null \u0026\u0026 !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668": {
      "type": "Ybodychange",
      "commitMessage": "@Nullable all the way: null-safety at field level\n\nThis commits extends nullability declarations to the field level, formalizing the interaction between methods and their underlying fields and therefore avoiding any nullability mismatch.\n\nIssue: SPR-15720\n",
      "commitDate": "2017-06-29, 7:54 p.m.",
      "commitName": "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-06-13, 3:42 a.m.",
      "commitNameOld": "fc64b8040f7c76f2bc85387cf944436424ce408c",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 16.67,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tconfigCandidates.sort((bd1, bd2) -\u003e {\n\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator !\u003d null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment \u003d\u003d null) {\n\t\t\tthis.environment \u003d new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr !\u003d null) {\n\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 262,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,100 +1,104 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tconfigCandidates.sort((bd1, bd2) -\u003e {\n \t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator !\u003d null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n+\t\tif (this.environment \u003d\u003d null) {\n+\t\t\tthis.environment \u003d new StandardEnvironment();\n+\t\t}\n+\n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr !\u003d null) {\n \t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc64b8040f7c76f2bc85387cf944436424ce408c": {
      "type": "Ybodychange",
      "commitMessage": "Polish \"Replace relevant code with lambda\"\n\nCloses gh-1454\n",
      "commitDate": "2017-06-13, 3:42 a.m.",
      "commitName": "fc64b8040f7c76f2bc85387cf944436424ce408c",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2017-06-13, 2:55 a.m.",
      "commitNameOld": "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
      "commitAuthorOld": "diguage",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tconfigCandidates.sort((bd1, bd2) -\u003e {\n\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator !\u003d null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr !\u003d null) {\n\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 258,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,100 +1,100 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n-\t\tCollections.sort(configCandidates, (bd1, bd2) -\u003e {\n+\t\tconfigCandidates.sort((bd1, bd2) -\u003e {\n \t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator !\u003d null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr !\u003d null) {\n \t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3": {
      "type": "Ybodychange",
      "commitMessage": "Replace relevant code with lambda\n\nSee gh-1454\n",
      "commitDate": "2017-06-13, 2:55 a.m.",
      "commitName": "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
      "commitAuthor": "diguage",
      "commitDateOld": "2017-06-07, 8:19 a.m.",
      "commitNameOld": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 5.78,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tCollections.sort(configCandidates, (bd1, bd2) -\u003e {\n\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator !\u003d null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr !\u003d null) {\n\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 260,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,103 +1,100 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n-\t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n-\t\t\t@Override\n-\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n-\t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n-\t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n-\t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n-\t\t\t}\n+\t\tCollections.sort(configCandidates, (bd1, bd2) -\u003e {\n+\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n+\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n+\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tif (generator !\u003d null) {\n \t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr !\u003d null) {\n \t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017-06-07, 8:19 a.m.",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017-05-31, 4:51 p.m.",
      "commitNameOld": "b494c53b40a76a3ce01a54b1bd384b6809f1a147",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\t\t\t@Override\n\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n\t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t\t}\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator !\u003d null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr !\u003d null) {\n\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 260,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,101 +1,103 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry sbr \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n-\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+\t\t\tif (!this.localBeanNameGeneratorSet) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n-\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n-\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n+\t\t\t\tif (generator !\u003d null) {\n+\t\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n+\t\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (sbr !\u003d null) {\n \t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2017-04-17, 9:05 a.m.",
      "commitName": "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-12-29, 4:39 p.m.",
      "commitNameOld": "fc629bb508f950fe4a0f62b42395299677f7819e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 108.64,
      "commitsBetweenForRepo": 645,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\t\t\t@Override\n\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n\t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t\t}\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr !\u003d null) {\n\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 257,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,101 +1,101 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n-\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n+\t\tSingletonBeanRegistry sbr \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n-\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n-\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n-\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+\t\t\tsbr \u003d (SingletonBeanRegistry) registry;\n+\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n-\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n-\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n-\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n-\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+\t\t\t\t\t\tBeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n+\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026\n+\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n+\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n-\t\tif (singletonRegistry !\u003d null) {\n-\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n-\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n+\t\tif (sbr !\u003d null) {\n+\t\t\tif (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+\t\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n \t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7818c650ba3ad567cff2975b408509679d03e663": {
      "type": "Ybodychange",
      "commitMessage": "Cache ASM metadata at the context level (if supported)\n\nIncludes streamlined ClassPathBeanDefinitionScanner setup.\n\nIssue: SPR-14654\n",
      "commitDate": "2016-12-27, 7:38 a.m.",
      "commitName": "7818c650ba3ad567cff2975b408509679d03e663",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016-12-20, 6:16 a.m.",
      "commitNameOld": "f6b2a212066c97eabdd861044cb72dca78b0f80d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 7.06,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\t\t\t@Override\n\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n\t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t\t}\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 257,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,99 +1,101 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n+\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n+\t\t\t// for a shared cache since it\u0027ll be cleared by the ApplicationContext.\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
      "type": "Ybodychange",
      "commitMessage": "Explicit type can be replaced by \u003c\u003e\n\nIssue: SPR-13188\n",
      "commitDate": "2016-07-05, 11:00 a.m.",
      "commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2016-05-02, 9:19 a.m.",
      "commitNameOld": "7737c3c7e5e3ffe19e6cc151f1929982f5bba35d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 64.07,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\t\t\t@Override\n\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n\t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t\t}\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 270,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,99 +1,99 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n+\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n-\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n-\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n+\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n+\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n-\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n+\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n-\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n-\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n+\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n+\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc": {
      "type": "Ybodychange",
      "commitMessage": "Removed unused fields from ConfigurationClassBeanDefinitionReader\n\nIssue: SPR-11740\nIssue: SPR-13280\n",
      "commitDate": "2015-07-28, 6:08 a.m.",
      "commitName": "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015-03-13, 1:18 p.m.",
      "commitNameOld": "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 136.7,
      "commitsBetweenForRepo": 821,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\t\t\t@Override\n\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n\t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t\t}\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 270,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,99 +1,99 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Sort by previously determined @Order value, if applicable\n \t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \t\t\t@Override\n \t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n \t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n \t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n \t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n \t\t\t}\n \t\t});\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n-\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n-\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n+\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n+\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n \t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d": {
      "type": "Ybodychange",
      "commitMessage": "@Configuration classes get processed according to their @Order (if applicable)\n\nIssue: SPR-12657\n",
      "commitDate": "2015-03-13, 1:18 p.m.",
      "commitName": "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-12-01, 1:16 p.m.",
      "commitNameOld": "c85686ac78a815d6113371334b8ddcc49f1384ac",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 101.96,
      "commitsBetweenForRepo": 342,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Sort by previously determined @Order value, if applicable\n\t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\t\t\t@Override\n\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n\t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n\t\t\t}\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 270,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,88 +1,99 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+\t\tList\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n+\t\t// Sort by previously determined @Order value, if applicable\n+\t\tCollections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n+\t\t\t@Override\n+\t\t\tpublic int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n+\t\t\t\tint i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n+\t\t\t\tint i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n+\t\t\t\treturn (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n+\t\t\t}\n+\t\t});\n+\n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n+\t\tSet\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n \t\tdo {\n-\t\t\tparser.parse(configCandidates);\n+\t\t\tparser.parse(candidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n-\t\t\tconfigCandidates.clear();\n+\t\t\tcandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n \t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n \t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n \t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n \t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026\n \t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n-\t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n-\t\twhile (!configCandidates.isEmpty());\n+\t\twhile (!candidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4c59d85f690a29c45c644f9c3f13010d5cba84ed": {
      "type": "Ybodychange",
      "commitMessage": "Be defensive adding additional imported configs\n\nRefine the logic introduced in commit 71c6eb2b so that additional\nimported @Configuration classes are not considered as candidates if\nthey have already been parsed.\n\nIssue: SPR-12233\n",
      "commitDate": "2014-09-22, 6:05 p.m.",
      "commitName": "4c59d85f690a29c45c644f9c3f13010d5cba84ed",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2014-09-03, 6:59 a.m.",
      "commitNameOld": "6563405be5308954394b67608f09af35e7d35b59",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 19.46,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(configCandidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tconfigCandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)\n\t\t\t\t\t\t\t\t\u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n\t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!configCandidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 266,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,83 +1,88 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(configCandidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tconfigCandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n+\t\t\t\tSet\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n+\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n+\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n+\t\t\t\t}\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n-\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)\n+\t\t\t\t\t\t\t\t\u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n \t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!configCandidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abc343f4076d45172587197480c41f79c23f3aac": {
      "type": "Ybodychange",
      "commitMessage": "Prevent incorrect ImportAware metdata injection\n\nUpdate ImportRegistry to track all import registrations that occur\nagainst an importing class (rather than just keeping the last). In\naddition, prune imported classes from the registry when a configuration\nclass is removed during the REGISTER_BEAN ConfigurationPhase.\n\nThis update prevents incorrect metadata from being injected into an\nImportAware class which is imported twice by different configurations\nclasses (when one of the configuration classes will be ultimately skipped\ndue to a @Condition).\n\nIssue: SPR-12128\n",
      "commitDate": "2014-09-02, 11:47 p.m.",
      "commitName": "abc343f4076d45172587197480c41f79c23f3aac",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2014-08-21, 4:43 p.m.",
      "commitNameOld": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 12.29,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(configCandidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tconfigCandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!configCandidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 267,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,83 +1,83 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n \t\tdo {\n \t\t\tparser.parse(configCandidates);\n \t\t\tparser.validate();\n \n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n-\t\t\t\t\t\tthis.importBeanNameGenerator);\n+\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tconfigCandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!configCandidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6": {
      "type": "Ybodychange",
      "commitMessage": "@PropertySource gets parsed as early as possible\n\nOther PropertySources and in particular @ComponentScan can benefit from previously declared property sources on the same configuration class.\n\nIssue: SPR-12110\nIssue: SPR-12111\n",
      "commitDate": "2014-08-21, 4:43 p.m.",
      "commitName": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-08-12, 11:23 a.m.",
      "commitNameOld": "71c6eb2bb594f29803b6ec4a50de875def98be86",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 9.22,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(configCandidates);\n\t\t\tparser.validate();\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator);\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tconfigCandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!configCandidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 267,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,102 +1,83 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n \n \t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \n \t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n-\t\tint propertySourceCount \u003d 0;\n \t\tdo {\n \t\t\tparser.parse(configCandidates);\n \t\t\tparser.validate();\n \n-\t\t\t// Handle any @PropertySource annotations\n-\t\t\tif (parser.getPropertySourceCount() \u003e propertySourceCount) {\n-\t\t\t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n-\t\t\t\tif (!parsedPropertySources.isEmpty()) {\n-\t\t\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n-\t\t\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n-\t\t\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n-\t\t\t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n-\t\t\t\t\t\t\tenvPropertySources.addLast(propertySource);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tpropertySourceCount \u003d parser.getPropertySourceCount();\n-\t\t\t}\n-\n \t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n \t\t\tconfigClasses.removeAll(alreadyParsed);\n \n \t\t\t// Read the model and create bean definitions based on its content\n \t\t\tif (this.reader \u003d\u003d null) {\n \t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\t\tthis.importBeanNameGenerator);\n \t\t\t}\n \t\t\tthis.reader.loadBeanDefinitions(configClasses);\n \t\t\talreadyParsed.addAll(configClasses);\n \n \t\t\tconfigCandidates.clear();\n \t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n \t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n \t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n \t\t\t\tfor (String candidateName : newCandidateNames) {\n \t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n \t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n \t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n \t\twhile (!configCandidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "71c6eb2bb594f29803b6ec4a50de875def98be86": {
      "type": "Ybodychange",
      "commitMessage": "Additional configuration classes get detected when imported through XML or registrars\n\nIssue: SPR-11430\nIssue: SPR-11723\n",
      "commitDate": "2014-08-12, 11:23 a.m.",
      "commitName": "71c6eb2bb594f29803b6ec4a50de875def98be86",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-06-25, 7:46 a.m.",
      "commitNameOld": "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 48.15,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n\t\tint propertySourceCount \u003d 0;\n\t\tdo {\n\t\t\tparser.parse(configCandidates);\n\t\t\tparser.validate();\n\n\t\t\t// Handle any @PropertySource annotations\n\t\t\tif (parser.getPropertySourceCount() \u003e propertySourceCount) {\n\t\t\t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\t\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n\t\t\t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n\t\t\t\t\t\t\tenvPropertySources.addLast(propertySource);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpropertySourceCount \u003d parser.getPropertySourceCount();\n\t\t\t}\n\n\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader \u003d\u003d null) {\n\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator);\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tconfigCandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames \u003d newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!configCandidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 271,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,73 +1,102 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n-\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\tString[] candidateNames \u003d registry.getBeanDefinitionNames();\n+\n+\t\tfor (String beanName : candidateNames) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n \t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n-\t\tparser.parse(configCandidates);\n-\t\tparser.validate();\n \n-\t\t// Handle any @PropertySource annotations\n-\t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n-\t\tif (!parsedPropertySources.isEmpty()) {\n-\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n-\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n-\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n-\t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n-\t\t\t\t\tenvPropertySources.addLast(propertySource);\n+\t\tSet\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n+\t\tint propertySourceCount \u003d 0;\n+\t\tdo {\n+\t\t\tparser.parse(configCandidates);\n+\t\t\tparser.validate();\n+\n+\t\t\t// Handle any @PropertySource annotations\n+\t\t\tif (parser.getPropertySourceCount() \u003e propertySourceCount) {\n+\t\t\t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n+\t\t\t\tif (!parsedPropertySources.isEmpty()) {\n+\t\t\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n+\t\t\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n+\t\t\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n+\t\t\t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n+\t\t\t\t\t\t\tenvPropertySources.addLast(propertySource);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tpropertySourceCount \u003d parser.getPropertySourceCount();\n+\t\t\t}\n+\n+\t\t\tSet\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n+\t\t\tconfigClasses.removeAll(alreadyParsed);\n+\n+\t\t\t// Read the model and create bean definitions based on its content\n+\t\t\tif (this.reader \u003d\u003d null) {\n+\t\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n+\t\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n+\t\t\t\t\t\tthis.importBeanNameGenerator);\n+\t\t\t}\n+\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n+\t\t\talreadyParsed.addAll(configClasses);\n+\n+\t\t\tconfigCandidates.clear();\n+\t\t\tif (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n+\t\t\t\tString[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n+\t\t\t\tSet\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n+\t\t\t\tfor (String candidateName : newCandidateNames) {\n+\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n+\t\t\t\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n+\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+\t\t\t\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcandidateNames \u003d newCandidateNames;\n \t\t\t}\n \t\t}\n-\n-\t\t// Read the model and create bean definitions based on its content\n-\t\tif (this.reader \u003d\u003d null) {\n-\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n-\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n-\t\t\t\t\tthis.importBeanNameGenerator);\n-\t\t}\n-\n-\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\twhile (!configCandidates.isEmpty());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b6255128bf7a32384f03e985d79b8bb03c3dd8a0": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassPostProcessor skips pre-processed bean definitions now (avoiding side effects in case of multiple CCPPs)\n\nIssue: SPR-11858\n",
      "commitDate": "2014-06-25, 7:46 a.m.",
      "commitName": "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014-04-09, 11:43 a.m.",
      "commitNameOld": "0041e245a1f80affba828c79fd8db13b0319fb85",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 76.84,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tparser.parse(configCandidates);\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n\t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n\t\t\t\t\tenvPropertySources.addLast(propertySource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\tthis.importBeanNameGenerator);\n\t\t}\n\n\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 270,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,67 +1,73 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n-\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n+\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n \t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n \t\t\t\t\tenvPropertySources.addLast(propertySource);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\tthis.importBeanNameGenerator);\n \t\t}\n \n \t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eed1a323d10de122a08db26192dc602f9fb173f8": {
      "type": "Ybodychange",
      "commitMessage": "Polishing (along with SPR-10992)\n",
      "commitDate": "2013-11-04, 5:44 p.m.",
      "commitName": "eed1a323d10de122a08db26192dc602f9fb173f8",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013-10-22, 2:15 p.m.",
      "commitNameOld": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 13.19,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tparser.parse(configCandidates);\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n\t\t\t\t\tenvPropertySources.addLast(propertySource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\tthis.importBeanNameGenerator);\n\t\t}\n\n\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 271,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,67 +1,67 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n \t\t\t\t\tenvPropertySources.addLast(propertySource);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\tthis.importBeanNameGenerator);\n \t\t}\n \n-\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e95bd9e25086bf1dad37f8d08293c948621faf6b": {
      "type": "Ybodychange",
      "commitMessage": "Add @PropertySources and ignoreResourceNotFound\n\nSupport repeatable @PropertySource annotations in Java 8 and add\n@PropertySources container annotation for Java 6/7. Also add an\nignoreResourceNotFound attribute to @PropertySource allowing missing\nproperty resources to be silently ignored.\n\nThis commit also introduces some generally useful methods to\nAnnotationUtils for working with @Repeatable annotations.\n\nIssue: SPR-8371\n",
      "commitDate": "2013-10-22, 2:15 p.m.",
      "commitName": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-08-28, 6:49 a.m.",
      "commitNameOld": "bb971cecf15e8c7983cbaf7767851236d132889c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 55.31,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tparser.parse(configCandidates);\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n\t\t\t\t\tenvPropertySources.addLast(propertySource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\tthis.importBeanNameGenerator);\n\t\t}\n\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 267,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,67 +1,67 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n-\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n+\t\tList\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n-\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n-\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n+\t\t\t\tfor (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n+\t\t\t\t\tenvPropertySources.addLast(propertySource);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n \t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n \t\t\t\t\tthis.importBeanNameGenerator);\n \t\t}\n \n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5efe894ee4969a7c3780a2fd4d2ceab695777c50": {
      "type": "Ybodychange",
      "commitMessage": "Not exposing ApplicationContext on ConditionContext anymore\n",
      "commitDate": "2013-08-27, 6:00 p.m.",
      "commitName": "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013-06-20, 11:21 p.m.",
      "commitNameOld": "a403e8f8b881c743e5e7a16a26690500595725be",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 67.78,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tparser.parse(configCandidates);\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n\t\t\t\t\tthis.importBeanNameGenerator);\n\t\t}\n\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 268,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,69 +1,67 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n-\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry,\n-\t\t\t\tthis.applicationContext);\n+\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n-\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\t\tregistry, this.applicationContext, this.sourceExtractor,\n-\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory,\n-\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n+\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor,\n+\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment,\n+\t\t\t\t\tthis.importBeanNameGenerator);\n \t\t}\n \n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": {
      "type": "Ybodychange",
      "commitMessage": "Improve support for @Conditional on @Configuration\n\nIntroduce new ConfigurationCondition interface allowing more\nfine-grained control for @Conditional when used with @Configuration\nbeans.\n\nPrimarily added so that the evaluation of conditions that inspect bean\ndefinitions can be deferred until all @Configuration classes have been\nparsed.\n\nIssue: SPR-10534\n",
      "commitDate": "2013-06-12, 2:45 p.m.",
      "commitName": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-06-04, 1:27 p.m.",
      "commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 8.05,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry,\n\t\t\t\tthis.applicationContext);\n\t\tparser.parse(configCandidates);\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\tregistry, this.applicationContext, this.sourceExtractor,\n\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory,\n\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n\t\t}\n\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 265,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,67 +1,69 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n-\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n+\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry,\n+\t\t\t\tthis.applicationContext);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n+\t\t\t\t\tregistry, this.applicationContext, this.sourceExtractor,\n+\t\t\t\t\tthis.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n \n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "239ce1466ce118294f5c7b8e842a80815fd813de": {
      "type": "Ybodychange",
      "commitMessage": "Update @Conditional processing logic\n\nDefer @Conditional processing on @Configuration classes until the bean\ndefinitions are loaded, rather than when the @Configuration class is\nparsed. This provides better support for @Conditional implementations\nthat inspect bean definitions.\n\nThis commit also fixes some minor problems with original implementation\nand replaces the ConditionalAnnotationHelper class with\nConditionEvaluator.\n\nIssue: SPR-10534\n",
      "commitDate": "2013-06-04, 1:27 p.m.",
      "commitName": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-05-13, 6:04 p.m.",
      "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthorOld": "Rob Winch",
      "daysBetweenCommits": 21.81,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tparser.parse(configCandidates);\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n\t\t}\n\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 254,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,71 +1,67 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n-\t\tfor (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n-\t\t\tif (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry,\n-\t\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n-\t\t\t\treader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n-\t\t\t}\n-\t\t}\n+\n+\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c7fdb07363791fb3c72f4946839f4c166196ebe": {
      "type": "Ybodychange",
      "commitMessage": "Add support for DeferredImportSelector\n\nAdd DeferredImportSelector interface that can be used to select imports\nafter all @Configuration beans have been processed.\n",
      "commitDate": "2013-05-08, 10:41 p.m.",
      "commitName": "7c7fdb07363791fb3c72f4946839f4c166196ebe",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-05-08, 10:41 p.m.",
      "commitNameOld": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tparser.parse(configCandidates);\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n\t\t}\n\t\tfor (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n\t\t\tif (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry,\n\t\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n\t\t\t\treader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n\t\t\t}\n\t\t}\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 250,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,84 +1,71 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n-\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n-\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n-\t\t\ttry {\n-\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n-\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch (IOException ex) {\n-\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n-\t\t\t}\n-\t\t}\n+\t\tparser.parse(configCandidates);\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n \t\tfor (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n \t\t\tif (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry,\n \t\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n \t\t\t\treader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n \t\t\t}\n \t\t}\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b257253a2b6890ef532f27a662c441fc4fd21f3b": {
      "type": "Ybodychange",
      "commitMessage": "Support for @Conditional configuration\n\nIntroduce new @Conditional annotation that can be used to filter\nwhich @Configuration classes or methods are loaded. @Conditional\ncan be used directly or as a meta-annotation. Condition implementations\nare provided via the \u0027Condition\u0027 interface and are free to filter based\non any criteria available at the time that they run. The\nConditionalContext provides access to the BeanDefinitionRegistry,\nEnvironment and ConfigurableListableBeanFactory along with a\nResourceLoader and ClassLoader.\n\nThe existing @Profile annotation has been refactored as a @Conditional\nwith the added benefit that it can now be used as a method level\nannotation.\n",
      "commitDate": "2013-05-08, 10:41 p.m.",
      "commitName": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013-01-02, 4:33 a.m.",
      "commitNameOld": "70eaf02b7fab9d8a023ddb50cedcab859e93c245",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 126.71,
      "commitsBetweenForRepo": 540,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n\t\t}\n\t\tfor (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n\t\t\tif (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry,\n\t\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n\t\t\t\treader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n\t\t\t}\n\t\t}\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 250,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,79 +1,84 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n-\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tfor (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n+\t\t\tif (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry,\n+\t\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n+\t\t\t\treader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n+\t\t\t}\n+\t\t}\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \n \t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n \t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6": {
      "type": "Ybodychange",
      "commitMessage": "Several enhancements with respect to CachingMetadataReaderFactory handling.\n\nAdded \"clearCache()\" method to CachingMetadataReaderFactory, for clearing the metadata cache once not needed anymore - in particular when the MetadataReaderFactory instance is long-lived. Also added \"setMetadataReaderFactory\" method to ClassPathScanningCandidateComponentProvider, analogous to ConfigurationClassPostProcessor.\n",
      "commitDate": "2012-12-11, 9:29 p.m.",
      "commitName": "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012-09-24, 5:26 a.m.",
      "commitNameOld": "dc4e0683aeccdabfa212d20a5335e81af13cd6d4",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 78.71,
      "commitsBetweenForRepo": 393,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n\t\t}\n\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 249,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,75 +1,79 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n \t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n \t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n \t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n \t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n \t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n \t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n \t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n \t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n \t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n+\n+\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n+\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n+\t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a42c80c1151380f7f492ec75de5648cfe62d250": {
      "type": "Ybodychange",
      "commitMessage": "@Import\u0027ed configuration classes get properly registered in case of same class name (second try)\n\nIssue: SPR-9243\n",
      "commitDate": "2012-09-10, 5:16 p.m.",
      "commitName": "0a42c80c1151380f7f492ec75de5648cfe62d250",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012-08-09, 6:38 p.m.",
      "commitNameOld": "92500ab9023ae2afd096be9c014423fcd4180c55",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 31.94,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry singletonRegistry \u003d null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n\t\t\t}\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tif (this.reader \u003d\u003d null) {\n\t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n\t\t}\n\t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (singletonRegistry !\u003d null) {\n\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 246,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,74 +1,75 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n \t\tSingletonBeanRegistry singletonRegistry \u003d null;\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tsingletonRegistry \u003d (SingletonBeanRegistry) registry;\n-\t\t\tif (singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n-\t\t\t\tthis.beanNameGenerator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+\t\t\tif (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+\t\t\t\tBeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+\t\t\t\tthis.componentScanBeanNameGenerator \u003d generator;\n+\t\t\t\tthis.importBeanNameGenerator \u003d generator;\n \t\t\t}\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n-\t\t\t\tthis.resourceLoader, this.beanNameGenerator, registry);\n+\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tif (this.reader \u003d\u003d null) {\n \t\t\tthis.reader \u003d new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter,\n-\t\t\t\t\tthis.metadataReaderFactory, this.resourceLoader, this.environment,\n-\t\t\t\t\tthis.beanNameGenerator);\n+\t\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory,\n+\t\t\t\t\tthis.resourceLoader, this.environment, this.importBeanNameGenerator);\n \t\t}\n \t\tthis.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (singletonRegistry !\u003d null) {\n-\t\t\tif (!singletonRegistry.containsSingleton(\"importRegistry\")) {\n-\t\t\t\tsingletonRegistry.registerSingleton(\"importRegistry\", parser.getImportRegistry());\n+\t\t\tif (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+\t\t\t\tsingletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012-01-31, 8:37 a.m.",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012-01-31, 8:37 a.m.",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tthis.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 212,
      "functionName": "processConfigBeanDefinitions",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
        "newPath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java"
      }
    },
    "4520ea8690fa8769a2d45658883eac51ea2453ed": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
      "commitDate": "2011-05-18, 4:53 a.m.",
      "commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
          "commitDate": "2011-05-18, 4:53 a.m.",
          "commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011-05-17, 3:15 p.m.",
          "commitNameOld": "6fcea8b99da45f287149796ef2598f0d71758793",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 0.57,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tthis.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 215,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,58 +1,58 @@\n-\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tthis.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]",
            "newValue": "[registry-BeanDefinitionRegistry]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
          "commitDate": "2011-05-18, 4:53 a.m.",
          "commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011-05-17, 3:15 p.m.",
          "commitNameOld": "6fcea8b99da45f287149796ef2598f0d71758793",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 0.57,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tthis.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 215,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,58 +1,58 @@\n-\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n \t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tthis.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6fcea8b99da45f287149796ef2598f0d71758793": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
      "commitDate": "2011-05-17, 3:15 p.m.",
      "commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
          "commitDate": "2011-05-17, 3:15 p.m.",
          "commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011-05-12, 8:27 a.m.",
          "commitNameOld": "57206db15271f865b542264c74980e6cbb4681fd",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.28,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 216,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,56 +1,58 @@\n-\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n+\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n+\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[parser-ConfigurationClassParser, reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]",
            "newValue": "[reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
          "commitDate": "2011-05-17, 3:15 p.m.",
          "commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011-05-12, 8:27 a.m.",
          "commitNameOld": "57206db15271f865b542264c74980e6cbb4681fd",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.28,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 216,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,56 +1,58 @@\n-\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n+\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(\n+\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n \t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n \t\tif (!parsedPropertySources.isEmpty()) {\n \t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n \t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n \t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n \t\t\t}\n \t\t\telse {\n \t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n \t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n \t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "57206db15271f865b542264c74980e6cbb4681fd": {
      "type": "Ybodychange",
      "commitMessage": "Refine ignored @PropertySource log warning\n\nIf the enclosing environment does not implement ConfigurableEnvironment,\nthen @PropertySource annotations are ignored because there is no way to\nadd them to the Environment. Now checking first to see if there are any\n@PropertySource annotations present before issuing the warning.\n\nIssue: SPR-8314\n",
      "commitDate": "2011-05-12, 8:27 a.m.",
      "commitName": "57206db15271f865b542264c74980e6cbb4681fd",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011-05-11, 9:28 a.m.",
      "commitNameOld": "c8bc54e0ccad49f0785856f911349283619eb8ba",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\tif (!parsedPropertySources.isEmpty()) {\n\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 218,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,54 +1,56 @@\n \tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Handle any @PropertySource annotations\n-\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n-\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n-\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n-\t\t}\n-\t\telse {\n-\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n-\t\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n-\t\t\twhile (!parsedPropertySources.isEmpty()) {\n-\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n+\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n+\t\tif (!parsedPropertySources.isEmpty()) {\n+\t\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n+\t\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n+\t\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n+\t\t\t\twhile (!parsedPropertySources.isEmpty()) {\n+\t\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c8bc54e0ccad49f0785856f911349283619eb8ba": {
      "type": "Ybodychange",
      "commitMessage": "Introduce @PropertySource\n\nAllows a convenient mechanism for contributing a PropertySource to the\nenclosing Spring Environment. See @PropertySource Javadoc for\ncomplete details and PropertySourceAnnotationTests for examples.\n\nIssue: SPR-8314\n",
      "commitDate": "2011-05-11, 9:28 a.m.",
      "commitName": "c8bc54e0ccad49f0785856f911349283619eb8ba",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011-05-08, 9:49 a.m.",
      "commitNameOld": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Handle any @PropertySource annotations\n\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n\t\t}\n\t\telse {\n\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n\t\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n\t\t\twhile (!parsedPropertySources.isEmpty()) {\n\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n\t\t\t}\n\t\t}\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 218,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,41 +1,54 @@\n \tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n+\t\t// Handle any @PropertySource annotations\n+\t\tif (!(this.environment instanceof ConfigurableEnvironment)) {\n+\t\t\tlogger.warn(\"Ignoring @PropertySource annotations. \" +\n+\t\t\t\t\t\"Reason: Environment must implement ConfigurableEnvironment\");\n+\t\t}\n+\t\telse {\n+\t\t\tMutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment)this.environment).getPropertySources();\n+\t\t\tStack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n+\t\t\twhile (!parsedPropertySources.isEmpty()) {\n+\t\t\t\tenvPropertySources.addLast(parsedPropertySources.pop());\n+\t\t\t}\n+\t\t}\n+\n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0c31ad84cffd7af718a45d679483a1c51f9e552": {
      "type": "Ybodychange",
      "commitMessage": "Allow recursive use of @ComponentScan\n\nPrior to this change, @ComponentScan annotations were only processed at\nthe first level of depth.  Now, the set of bean definitions resulting\nfrom each declaration of @ComponentScan is checked for configuration\nclasses that declare @ComponentScan, and recursion is performed as\nnecessary.\n\nCycles between @ComponentScan declarations are detected as well. See\nCircularComponentScanException.\n\nIssue: SPR-8307\n",
      "commitDate": "2011-05-08, 9:49 a.m.",
      "commitName": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011-05-06, 3:05 p.m.",
      "commitNameOld": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 214,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,41 +1,41 @@\n \tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n-\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \n \t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n \t\tif (registry instanceof SingletonBeanRegistry) {\n \t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n \t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cdb01cbd3795f273b751d0f0a45caa22d07c62da": {
      "type": "Ybodychange",
      "commitMessage": "Introduce ImportAware interface\n\n@Configuration classes may implement ImportAware in order to be injected\nwith the AnnotationMetadata of their @Import\u0027ing class.\n\nIncludes the introduction of a new PriorityOrdered\nImportAwareBeanPostProcessor that handles injection of the\nimporting class metadata.\n",
      "commitDate": "2011-05-06, 3:05 p.m.",
      "commitName": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011-05-06, 3:03 p.m.",
      "commitNameOld": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n\t\t\t}\n\t\t}\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 213,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,34 +1,41 @@\n \tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n+\n+\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n+\t\tif (registry instanceof SingletonBeanRegistry) {\n+\t\t\tif (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n+\t\t\t\t((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n+\t\t\t}\n+\t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
      "commitDate": "2011-05-06, 3:03 p.m.",
      "commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
          "commitDate": "2011-05-06, 3:03 p.m.",
          "commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011-03-15, 3:09 a.m.",
          "commitNameOld": "d471266d44199112b6e030615a395209e5265ec0",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 52.5,
          "commitsBetweenForRepo": 121,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 201,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,35 +1,34 @@\n-\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n+\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n-\t\t// Populate a new configuration model by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n+\t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[registry-BeanDefinitionRegistry, reader-ConfigurationClassBeanDefinitionReader]",
            "newValue": "[parser-ConfigurationClassParser, reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
          "commitDate": "2011-05-06, 3:03 p.m.",
          "commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011-03-15, 3:09 a.m.",
          "commitNameOld": "d471266d44199112b6e030615a395209e5265ec0",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 52.5,
          "commitsBetweenForRepo": 121,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 201,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,35 +1,34 @@\n-\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n+\tpublic void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n-\t\t// Populate a new configuration model by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n+\t\t// Parse each @Configuration class\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
      "commitDate": "2011-02-08, 9:42 a.m.",
      "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
          "commitDate": "2011-02-08, 9:42 a.m.",
          "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011-01-03, 4:04 a.m.",
          "commitNameOld": "b3ff9be78f62ff1d13ab874a4772f8fc6d189eb4",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 36.23,
          "commitsBetweenForRepo": 93,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 380,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,37 +1,35 @@\n-\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[registry-BeanDefinitionRegistry]",
            "newValue": "[registry-BeanDefinitionRegistry, reader-ConfigurationClassBeanDefinitionReader]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
          "commitDate": "2011-02-08, 9:42 a.m.",
          "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011-01-03, 4:04 a.m.",
          "commitNameOld": "b3ff9be78f62ff1d13ab874a4772f8fc6d189eb4",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 36.23,
          "commitsBetweenForRepo": 93,
          "commitsBetweenForFile": 1,
          "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 380,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,37 +1,35 @@\n-\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(\n-\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "f480333d31d8307b8c96409e7bb4f06ec0cab0ca": {
      "type": "Ybodychange",
      "commitMessage": "Merge 3.1.0 development branch into trunk\n\nBranch in question is \u0027env\u0027 branch from git://git.springsource.org/sandbox/cbeams.git; merged into\ngit-svn repository with:\n\n    git merge -s recursive -Xtheirs --no-commit env\n\nNo merge conflicts, but did need to\n\n    git rm spring-build\n\nprior to committing.\n\nWith this change, Spring 3.1.0 development is now happening on SVN\ntrunk. Further commits to the 3.0.x line will happen in an as-yet\nuncreated SVN branch.  3.1.0 snapshots will be available\nper the usual nightly CI build from trunk.\n",
      "commitDate": "2010-10-25, 3:48 p.m.",
      "commitName": "f480333d31d8307b8c96409e7bb4f06ec0cab0ca",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2010-06-07, 6:36 p.m.",
      "commitNameOld": "8446fd1b26719fd8ea9e8a8d8258ceec9f27b9ed",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 139.88,
      "commitsBetweenForRepo": 376,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(\n\t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 178,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,37 +1,37 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n+\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(\n \t\t\t\tregistry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n \t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fbd797e50b2f1c5b0dfef944ee218d826f1a0694": {
      "type": "Ybodychange",
      "commitMessage": "RESOLVED - issue SPR-6779: imported @Configuration classes do not get enhanced and fail to satisfy scoping requirements\nrefactoring, polishing.\n\n",
      "commitDate": "2010-01-29, 6:31 p.m.",
      "commitName": "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-11-06, 7:32 p.m.",
      "commitNameOld": "0a4463fb71e6901a943a5bafc9d1957da2229333",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 83.96,
      "commitsBetweenForRepo": 508,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tConfigurationClassBeanDefinitionReader reader \u003d\n\t\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 144,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,35 +1,37 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n-\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n+\t\t\tif (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n+\t\tConfigurationClassBeanDefinitionReader reader \u003d\n+\t\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n+\t\treader.loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a4463fb71e6901a943a5bafc9d1957da2229333": {
      "type": "Ybodychange",
      "commitMessage": "SPR-6158: Initial implementation and tests for @ImportXml\n\n",
      "commitDate": "2009-11-06, 7:32 p.m.",
      "commitName": "0a4463fb71e6901a943a5bafc9d1957da2229333",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-09-24, 6:45 a.m.",
      "commitNameOld": "b8c1130eec0732091426908a90db66e4eddeb25c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 43.57,
      "commitsBetweenForRepo": 294,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 154,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,35 +1,35 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0": {
      "type": "Ybodychange",
      "commitMessage": "added SourceExtractor support\n",
      "commitDate": "2009-05-12, 6:27 p.m.",
      "commitName": "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-05-12, 12:13 p.m.",
      "commitNameOld": "12d6aa232ab6066e885093e4a70a8386fdf9902d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 154,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,35 +1,35 @@\n \tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n-\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a6124793fc44779b569fbbba6fd4ec8804b56558": {
      "type": "Ymodifierchange",
      "commitMessage": "polishing\n",
      "commitDate": "2009-05-05, 5:36 a.m.",
      "commitName": "a6124793fc44779b569fbbba6fd4ec8804b56558",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-26, 7:41 a.m.",
      "commitNameOld": "cea8f7f69e8939d4d20073862890f0b1c1824499",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 126,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,35 +1,35 @@\n-\tprotected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[public]"
      }
    },
    "cea8f7f69e8939d4d20073862890f0b1c1824499": {
      "type": "Ymodifierchange",
      "commitMessage": "custom stereotype annotations can be meta-annotated with @Service, @Controller etc as well; @Scope and @Transactional are now supported as meta-annotations on custom annotations\n",
      "commitDate": "2009-04-26, 7:41 a.m.",
      "commitName": "cea8f7f69e8939d4d20073862890f0b1c1824499",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-24, 7:16 a.m.",
      "commitNameOld": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 126,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,35 +1,35 @@\n-\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\tprotected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n \t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configCandidates) {\n \t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n \t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n \t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n \t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[protected, final]",
        "newValue": "[protected]"
      }
    },
    "b5d21108da24f8344be3bc708c7afdfca9a1d089": {
      "type": "Ybodychange",
      "commitMessage": "@Configuration parsing fully relies on Spring\u0027s MetadataReader abstraction now\n",
      "commitDate": "2009-04-24, 7:16 a.m.",
      "commitName": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-22, 6:46 a.m.",
      "commitNameOld": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n\t\t\ttry {\n\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 124,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,30 +1,35 @@\n \tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+\t\tSet\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n-\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n-\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\tif (checkConfigurationClassCandidate(beanDef)) {\n+\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n-\t\tif (configBeanDefs.isEmpty()) {\n+\t\tif (configCandidates.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n \t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n-\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n-\t\t\tString beanClassName \u003d holder.getBeanDefinition().getBeanClassName();\n+\t\tfor (BeanDefinitionHolder holder : configCandidates) {\n+\t\t\tBeanDefinition bd \u003d holder.getBeanDefinition();\n \t\t\ttry {\n-\t\t\t\tparser.parse(beanClassName, holder.getBeanName());\n+\t\t\t\tif (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n+\t\t\t\t\tparser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tparser.parse(bd.getBeanClassName(), holder.getBeanName());\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcatch (IOException ex) {\n-\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n+\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n \t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": {
      "type": "Ybodychange",
      "commitMessage": "next cut of JavaConfig metadata reading revision: using cached MetadataReaders\n",
      "commitDate": "2009-04-22, 6:46 a.m.",
      "commitName": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009-04-19, 7:45 p.m.",
      "commitNameOld": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.46,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configBeanDefs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n\t\t\tString beanClassName \u003d holder.getBeanDefinition().getBeanClassName();\n\t\t\ttry {\n\t\t\t\tparser.parse(beanClassName, holder.getBeanName());\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n\t\t\t}\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 124,
      "functionName": "processConfigBeanDefinitions",
      "diff": "@@ -1,24 +1,30 @@\n \tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n \t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n \t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n \t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n \t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n \t\t\t}\n \t\t}\n \n \t\t// Return immediately if no @Configuration classes were found\n \t\tif (configBeanDefs.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Populate a new configuration model by parsing each @Configuration classes\n-\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n \t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n-\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t\tString beanClassName \u003d holder.getBeanDefinition().getBeanClassName();\n+\t\t\ttry {\n+\t\t\t\tparser.parse(beanClassName, holder.getBeanName());\n+\t\t\t}\n+\t\t\tcatch (IOException ex) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n+\t\t\t}\n \t\t}\n \t\tparser.validate();\n \n \t\t// Read the model and create bean definitions based on its content\n \t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14bd47551900ced88eeacf2a5f63c187ff72028c": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
      "commitDate": "2009-04-19, 7:45 p.m.",
      "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009-04-19, 7:45 p.m.",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-04-06, 5:23 p.m.",
          "commitNameOld": "254bf7e4038609f5d5c928fd07572184a58b0318",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 13.1,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configBeanDefs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,24 +1,24 @@\n-\tprivate void enhanceConfigurationClasses() {\n-\n-\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n-\n-\t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-\t\t\t// nothing to enhance -\u003e return immediately\n-\t\t\treturn;\n-\n-\t\tassertCglibIsPresent(configBeanDefs);\n-\n-\t\tConfigurationClassEnhancer enhancer \u003d new ConfigurationClassEnhancer(beanFactory);\n-\n-\t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n-\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n-\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n-\n-\t\t\tif (logger.isDebugEnabled())\n-\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n-\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n-\n-\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n+\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n+\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\t}\n \t\t}\n+\n+\t\t// Return immediately if no @Configuration classes were found\n+\t\tif (configBeanDefs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Populate a new configuration model by parsing each @Configuration classes\n+\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n+\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t}\n+\t\tparser.validate();\n+\n+\t\t// Read the model and create bean definitions based on its content\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "enhanceConfigurationClasses",
            "newValue": "processConfigBeanDefinitions"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009-04-19, 7:45 p.m.",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-04-06, 5:23 p.m.",
          "commitNameOld": "254bf7e4038609f5d5c928fd07572184a58b0318",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 13.1,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configBeanDefs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,24 +1,24 @@\n-\tprivate void enhanceConfigurationClasses() {\n-\n-\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n-\n-\t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-\t\t\t// nothing to enhance -\u003e return immediately\n-\t\t\treturn;\n-\n-\t\tassertCglibIsPresent(configBeanDefs);\n-\n-\t\tConfigurationClassEnhancer enhancer \u003d new ConfigurationClassEnhancer(beanFactory);\n-\n-\t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n-\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n-\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n-\n-\t\t\tif (logger.isDebugEnabled())\n-\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n-\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n-\n-\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n+\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n+\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\t}\n \t\t}\n+\n+\t\t// Return immediately if no @Configuration classes were found\n+\t\tif (configBeanDefs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Populate a new configuration model by parsing each @Configuration classes\n+\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n+\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t}\n+\t\tparser.validate();\n+\n+\t\t// Read the model and create bean definitions based on its content\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[registry-BeanDefinitionRegistry]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009-04-19, 7:45 p.m.",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-04-06, 5:23 p.m.",
          "commitNameOld": "254bf7e4038609f5d5c928fd07572184a58b0318",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 13.1,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configBeanDefs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,24 +1,24 @@\n-\tprivate void enhanceConfigurationClasses() {\n-\n-\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n-\n-\t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-\t\t\t// nothing to enhance -\u003e return immediately\n-\t\t\treturn;\n-\n-\t\tassertCglibIsPresent(configBeanDefs);\n-\n-\t\tConfigurationClassEnhancer enhancer \u003d new ConfigurationClassEnhancer(beanFactory);\n-\n-\t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n-\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n-\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n-\n-\t\t\tif (logger.isDebugEnabled())\n-\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n-\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n-\n-\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n+\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n+\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\t}\n \t\t}\n+\n+\t\t// Return immediately if no @Configuration classes were found\n+\t\tif (configBeanDefs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Populate a new configuration model by parsing each @Configuration classes\n+\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n+\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t}\n+\t\tparser.validate();\n+\n+\t\t// Read the model and create bean definitions based on its content\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected, final]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009-04-19, 7:45 p.m.",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009-04-06, 5:23 p.m.",
          "commitNameOld": "254bf7e4038609f5d5c928fd07572184a58b0318",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 13.1,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// Return immediately if no @Configuration classes were found\n\t\tif (configBeanDefs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Populate a new configuration model by parsing each @Configuration classes\n\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n\t\t}\n\t\tparser.validate();\n\n\t\t// Read the model and create bean definitions based on its content\n\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n\t}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "diff": "@@ -1,24 +1,24 @@\n-\tprivate void enhanceConfigurationClasses() {\n-\n-\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n-\n-\t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-\t\t\t// nothing to enhance -\u003e return immediately\n-\t\t\treturn;\n-\n-\t\tassertCglibIsPresent(configBeanDefs);\n-\n-\t\tConfigurationClassEnhancer enhancer \u003d new ConfigurationClassEnhancer(beanFactory);\n-\n-\t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n-\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n-\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n-\n-\t\t\tif (logger.isDebugEnabled())\n-\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n-\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n-\n-\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n+\tprotected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+\t\tSet\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+\t\tfor (String beanName : registry.getBeanDefinitionNames()) {\n+\t\t\tBeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+\t\t\tif (checkConfigurationClassBeanDefinition(beanDef)) {\n+\t\t\t\tconfigBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+\t\t\t}\n \t\t}\n+\n+\t\t// Return immediately if no @Configuration classes were found\n+\t\tif (configBeanDefs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// Populate a new configuration model by parsing each @Configuration classes\n+\t\tConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+\t\tfor (BeanDefinitionHolder holder : configBeanDefs) {\n+\t\t\tparser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+\t\t}\n+\t\tparser.validate();\n+\n+\t\t// Read the model and create bean definitions based on its content\n+\t\tnew ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "cc713ad5241a90bc66b96364b91e5439f1ae6cb6": {
      "type": "Ybodychange",
      "commitMessage": "RESOLVED - issue SPR-5600: Make naming of @Configuration class processing-related artifacts consistent\n",
      "commitDate": "2009-03-30, 11:26 a.m.",
      "commitName": "cc713ad5241a90bc66b96364b91e5439f1ae6cb6",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-27, 12:57 a.m.",
      "commitNameOld": "1697932c57af5389fe07971e91866980e966403f",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 3.44,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\n\t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n\t\t\t// nothing to enhance -\u003e return immediately\n\t\t\treturn;\n\n\t\tassertCglibIsPresent(configBeanDefs);\n\n\t\tConfigurationClassEnhancer enhancer \u003d new ConfigurationClassEnhancer(beanFactory);\n\n\t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 140,
      "functionName": "enhanceConfigurationClasses",
      "diff": "@@ -1,24 +1,24 @@\n \tprivate void enhanceConfigurationClasses() {\n \n \t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n \n \t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n \t\t\t// nothing to enhance -\u003e return immediately\n \t\t\treturn;\n \n \t\tassertCglibIsPresent(configBeanDefs);\n \n-\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n+\t\tConfigurationClassEnhancer enhancer \u003d new ConfigurationClassEnhancer(beanFactory);\n \n \t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n \t\t\tString configClassName \u003d beanDef.getBeanClassName();\n \t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n \n \t\t\tif (logger.isDebugEnabled())\n \t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n \t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n \n \t\t\tbeanDef.setBeanClassName(enhancedClassName);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1697932c57af5389fe07971e91866980e966403f": {
      "type": "Yfilerename",
      "commitMessage": "consolidated context.annotation.support -\u003e context.annotation\n\n",
      "commitDate": "2009-03-27, 12:57 a.m.",
      "commitName": "1697932c57af5389fe07971e91866980e966403f",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-26, 11:10 p.m.",
      "commitNameOld": "2c0c523d7099ed1ad77864242f25d30e218b2a95",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\n\t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n\t\t\t// nothing to enhance -\u003e return immediately\n\t\t\treturn;\n\n\t\tassertCglibIsPresent(configBeanDefs);\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\n\t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 140,
      "functionName": "enhanceConfigurationClasses",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationClassPostProcessor.java",
        "newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java"
      }
    },
    "2c0c523d7099ed1ad77864242f25d30e218b2a95": {
      "type": "Ybodychange",
      "commitMessage": "don\u0027t assert that CGLIB must be present unless there is at least one @Configuration class found\n\n",
      "commitDate": "2009-03-26, 11:10 p.m.",
      "commitName": "2c0c523d7099ed1ad77864242f25d30e218b2a95",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-26, 10:10 p.m.",
      "commitNameOld": "af058e599d4144347458fd02b448186bcf043a8c",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\n\t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n\t\t\t// nothing to enhance -\u003e return immediately\n\t\t\treturn;\n\n\t\tassertCglibIsPresent(configBeanDefs);\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\n\t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationClassPostProcessor.java",
      "functionStartLine": 142,
      "functionName": "enhanceConfigurationClasses",
      "diff": "@@ -1,20 +1,24 @@\n \tprivate void enhanceConfigurationClasses() {\n \n \t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n \n+\t\tif (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n+\t\t\t// nothing to enhance -\u003e return immediately\n+\t\t\treturn;\n+\n \t\tassertCglibIsPresent(configBeanDefs);\n \n \t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n \n \t\tfor (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n \t\t\tString configClassName \u003d beanDef.getBeanClassName();\n \t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n \n \t\t\tif (logger.isDebugEnabled())\n \t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n \t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n \n \t\t\tbeanDef.setBeanClassName(enhancedClassName);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7": {
      "type": "Yfilerename",
      "commitMessage": "+ Moving .config.java module -\u003e .context\n\n",
      "commitDate": "2009-03-23, 12:48 a.m.",
      "commitName": "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-23, 12:25 a.m.",
      "commitNameOld": "63b5c48461f69cc611f4378d52f46197998334db",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\n\t\tassertCglibIsPresent(configBeanDefs);\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\n\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationClassPostProcessor.java",
      "functionStartLine": 141,
      "functionName": "enhanceConfigurationClasses",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/ConfigurationClassPostProcessor.java",
        "newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationClassPostProcessor.java"
      }
    },
    "ef02c61e581dcd1f3cf110608da72ed133777d62": {
      "type": "Yfilerename",
      "commitMessage": "+ Repackaged src and test from .config.java.* -\u003e .context.annotation.*\n\n",
      "commitDate": "2009-03-23, 12:23 a.m.",
      "commitName": "ef02c61e581dcd1f3cf110608da72ed133777d62",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-23, 12:14 a.m.",
      "commitNameOld": "3f196517f99b7a7148e68531d1fa1b475ff81939",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\n\t\tassertCglibIsPresent(configBeanDefs);\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\n\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/ConfigurationClassPostProcessor.java",
      "functionStartLine": 141,
      "functionName": "enhanceConfigurationClasses",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationClassPostProcessor.java",
        "newPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/ConfigurationClassPostProcessor.java"
      }
    },
    "dc191bec2dfceb7ee052ac238c84eb564d27e1ee": {
      "type": "Ybodychange",
      "commitMessage": "Whitespace and license polish\n\n",
      "commitDate": "2009-03-07, 4:41 p.m.",
      "commitName": "dc191bec2dfceb7ee052ac238c84eb564d27e1ee",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-07, 1:14 a.m.",
      "commitNameOld": "5de6e2c3953ab594fd04c4f2e59a102633a0a64f",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.64,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\n\t\tassertCglibIsPresent(configBeanDefs);\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\n\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationClassPostProcessor.java",
      "functionStartLine": 150,
      "functionName": "enhanceConfigurationClasses",
      "diff": "@@ -1,20 +1,20 @@\n \tprivate void enhanceConfigurationClasses() {\n \n \t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n \n \t\tassertCglibIsPresent(configBeanDefs);\n \n \t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n \n \t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n \t\t\tString configClassName \u003d beanDef.getBeanClassName();\n \t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n \n \t\t\tif (logger.isDebugEnabled())\n-\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n-\t\t\t\t                    beanName, configClassName, enhancedClassName));\n+\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 \"\n+\t\t\t\t                  + \"with enhanced class name \u0027%s\u0027\", beanName, configClassName, enhancedClassName));\n \n \t\t\tbeanDef.setBeanClassName(enhancedClassName);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2e7e98248724f5f4fc054617765053e7d7b978cd": {
      "type": "Yfilerename",
      "commitMessage": "+ Renamed Scopes -\u003e StandardScopes\n+ Renamed ConfigurationPostProcessor -\u003e ConfigurationClassPostProcessor\n+ JavaDoc and polish for AbstractConfigurationClassProcessor\n\n",
      "commitDate": "2009-03-06, 1:55 a.m.",
      "commitName": "2e7e98248724f5f4fc054617765053e7d7b978cd",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-05, 10:27 p.m.",
      "commitNameOld": "8610c0bce8842d4467249e66d2bbaf928d6db2ad",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\n\t\tassertCglibIsPresent(configBeanDefs);\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\n\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n\t\t\t\t                    beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationClassPostProcessor.java",
      "functionStartLine": 159,
      "functionName": "enhanceConfigurationClasses",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationPostProcessor.java",
        "newPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationClassPostProcessor.java"
      }
    },
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4": {
      "type": "Ybodychange",
      "commitMessage": "+ Fleshed out, documented, tested and polished the ConfigurationPostProcessor implementation\n+ Removed @FactoryMethod indirection and extension point in favor of direct processing of @Bean annotations\n\n",
      "commitDate": "2009-03-05, 10:12 p.m.",
      "commitName": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-03-05, 3:22 p.m.",
      "commitNameOld": "93b558b1ce273add7115655d9b1ff9101d8b49e1",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\n\t\tassertCglibIsPresent(configBeanDefs);\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\n\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n\t\t\t\t                    beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationPostProcessor.java",
      "functionStartLine": 147,
      "functionName": "enhanceConfigurationClasses",
      "diff": "@@ -1,18 +1,20 @@\n \tprivate void enhanceConfigurationClasses() {\n \n-\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n-\t\t\n \t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n-\t\t\n+\n+\t\tassertCglibIsPresent(configBeanDefs);\n+\n+\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n+\n \t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n \t\t\tString configClassName \u003d beanDef.getBeanClassName();\n \t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n \n \t\t\tif (logger.isDebugEnabled())\n \t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n-\t\t\t                        beanName, configClassName, enhancedClassName));\n+\t\t\t\t                    beanName, configClassName, enhancedClassName));\n \n \t\t\tbeanDef.setBeanClassName(enhancedClassName);\n \t\t}\n \t}\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
      "commitDate": "2009-03-05, 3:08 p.m.",
      "commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
          "commitDate": "2009-03-05, 3:08 p.m.",
          "commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009-02-28, 1:18 a.m.",
          "commitNameOld": "f9918f9b2e9e97a8d3bebf66670b0463f11b274b",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.58,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\t\t\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\t\t\n\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n\t\t\t                        beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationPostProcessor.java",
          "functionStartLine": 170,
          "functionName": "enhanceConfigurationClasses",
          "diff": "@@ -1,32 +1,18 @@\n-\tprivate void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory,\n-\t        ConfigurationModel model) {\n+\tprivate void enhanceConfigurationClasses() {\n \n-\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n-\n-\t\tint configClassesEnhanced \u003d 0;\n-\n-\t\tfor (String beanName : beanFactory.getBeanDefinitionNames()) {\n+\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n+\t\t\n+\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n+\t\t\n+\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n-\n-\t\t\tif (!isConfigClass(beanDef))\n-\t\t\t\tcontinue;\n-\n \t\t\tString configClassName \u003d beanDef.getBeanClassName();\n-\n \t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n \n \t\t\tif (logger.isDebugEnabled())\n-\t\t\t\tlogger\n-\t\t\t\t        .debug(String\n-\t\t\t\t                .format(\n-\t\t\t\t                        \"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n-\t\t\t\t                        beanName, configClassName, enhancedClassName));\n+\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n+\t\t\t                        beanName, configClassName, enhancedClassName));\n \n \t\t\tbeanDef.setBeanClassName(enhancedClassName);\n-\n-\t\t\tconfigClassesEnhanced++;\n \t\t}\n-\n-\t\tif (configClassesEnhanced \u003d\u003d 0)\n-\t\t\tlogger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "enhanceAnyConfigurationClasses",
            "newValue": "enhanceConfigurationClasses"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
          "commitDate": "2009-03-05, 3:08 p.m.",
          "commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009-02-28, 1:18 a.m.",
          "commitNameOld": "f9918f9b2e9e97a8d3bebf66670b0463f11b274b",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.58,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\t\t\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\t\t\n\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n\t\t\t                        beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationPostProcessor.java",
          "functionStartLine": 170,
          "functionName": "enhanceConfigurationClasses",
          "diff": "@@ -1,32 +1,18 @@\n-\tprivate void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory,\n-\t        ConfigurationModel model) {\n+\tprivate void enhanceConfigurationClasses() {\n \n-\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n-\n-\t\tint configClassesEnhanced \u003d 0;\n-\n-\t\tfor (String beanName : beanFactory.getBeanDefinitionNames()) {\n+\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n+\t\t\n+\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n+\t\t\n+\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n-\n-\t\t\tif (!isConfigClass(beanDef))\n-\t\t\t\tcontinue;\n-\n \t\t\tString configClassName \u003d beanDef.getBeanClassName();\n-\n \t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n \n \t\t\tif (logger.isDebugEnabled())\n-\t\t\t\tlogger\n-\t\t\t\t        .debug(String\n-\t\t\t\t                .format(\n-\t\t\t\t                        \"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n-\t\t\t\t                        beanName, configClassName, enhancedClassName));\n+\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n+\t\t\t                        beanName, configClassName, enhancedClassName));\n \n \t\t\tbeanDef.setBeanClassName(enhancedClassName);\n-\n-\t\t\tconfigClassesEnhanced++;\n \t\t}\n-\n-\t\tif (configClassesEnhanced \u003d\u003d 0)\n-\t\t\tlogger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[beanFactory-DefaultListableBeanFactory, model-ConfigurationModel]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
          "commitDate": "2009-03-05, 3:08 p.m.",
          "commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009-02-28, 1:18 a.m.",
          "commitNameOld": "f9918f9b2e9e97a8d3bebf66670b0463f11b274b",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.58,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "\tprivate void enhanceConfigurationClasses() {\n\n\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n\t\t\n\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n\t\t\n\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n\t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\t\t\tString configClassName \u003d beanDef.getBeanClassName();\n\t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n\n\t\t\tif (logger.isDebugEnabled())\n\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n\t\t\t                        beanName, configClassName, enhancedClassName));\n\n\t\t\tbeanDef.setBeanClassName(enhancedClassName);\n\t\t}\n\t}",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationPostProcessor.java",
          "functionStartLine": 170,
          "functionName": "enhanceConfigurationClasses",
          "diff": "@@ -1,32 +1,18 @@\n-\tprivate void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory,\n-\t        ConfigurationModel model) {\n+\tprivate void enhanceConfigurationClasses() {\n \n-\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n-\n-\t\tint configClassesEnhanced \u003d 0;\n-\n-\t\tfor (String beanName : beanFactory.getBeanDefinitionNames()) {\n+\t\tConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory);\n+\t\t\n+\t\tBeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(true);\n+\t\t\n+\t\tfor(String beanName : configBeanDefs.getBeanDefinitionNames()) {\n \t\t\tBeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n-\n-\t\t\tif (!isConfigClass(beanDef))\n-\t\t\t\tcontinue;\n-\n \t\t\tString configClassName \u003d beanDef.getBeanClassName();\n-\n \t\t\tString enhancedClassName \u003d enhancer.enhance(configClassName);\n \n \t\t\tif (logger.isDebugEnabled())\n-\t\t\t\tlogger\n-\t\t\t\t        .debug(String\n-\t\t\t\t                .format(\n-\t\t\t\t                        \"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n-\t\t\t\t                        beanName, configClassName, enhancedClassName));\n+\t\t\t\tlogger.debug(format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n+\t\t\t                        beanName, configClassName, enhancedClassName));\n \n \t\t\tbeanDef.setBeanClassName(enhancedClassName);\n-\n-\t\t\tconfigClassesEnhanced++;\n \t\t}\n-\n-\t\tif (configClassesEnhanced \u003d\u003d 0)\n-\t\t\tlogger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n \t}\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "c593f063970df90d7de7b85c6da5733aadcafde6": {
      "type": "Yfilerename",
      "commitMessage": "Consolidating types and reducing visibility wherever possible. Non-internal public API is now at 18 types (21 including internal packages).\n",
      "commitDate": "2009-02-27, 10:43 p.m.",
      "commitName": "c593f063970df90d7de7b85c6da5733aadcafde6",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-02-27, 10:08 p.m.",
      "commitNameOld": "6deb1acab435d18f024e07a564ac77147729e0ec",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory, ConfigurationModel model) {\n        \n        ConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n\n        int configClassesEnhanced \u003d 0;\n\n        for (String beanName : beanFactory.getBeanDefinitionNames()) {\n            BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\n            if (!isConfigClass(beanDef))\n                continue;\n\n            String configClassName \u003d beanDef.getBeanClassName();\n\n            String enhancedClassName \u003d enhancer.enhance(configClassName);\n\n            if (logger.isDebugEnabled())\n                logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n                                           beanName, configClassName, enhancedClassName));\n\n            beanDef.setBeanClassName(enhancedClassName);\n\n            configClassesEnhanced++;\n        }\n\n        if (configClassesEnhanced \u003d\u003d 0)\n            logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n    }",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationPostProcessor.java",
      "functionStartLine": 119,
      "functionName": "enhanceAnyConfigurationClasses",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/internal/process/InternalConfigurationPostProcessor.java",
        "newPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationPostProcessor.java"
      }
    },
    "6deb1acab435d18f024e07a564ac77147729e0ec": {
      "type": "Ybodychange",
      "commitMessage": "Refactoring and repackaging\n",
      "commitDate": "2009-02-27, 10:08 p.m.",
      "commitName": "6deb1acab435d18f024e07a564ac77147729e0ec",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009-02-27, 8:35 p.m.",
      "commitNameOld": "d4fdad2202a16e2df11aefa2632b781ecef020ea",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    private void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory, ConfigurationModel model) {\n        \n        ConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n\n        int configClassesEnhanced \u003d 0;\n\n        for (String beanName : beanFactory.getBeanDefinitionNames()) {\n            BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\n            if (!isConfigClass(beanDef))\n                continue;\n\n            String configClassName \u003d beanDef.getBeanClassName();\n\n            String enhancedClassName \u003d enhancer.enhance(configClassName);\n\n            if (logger.isDebugEnabled())\n                logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n                                           beanName, configClassName, enhancedClassName));\n\n            beanDef.setBeanClassName(enhancedClassName);\n\n            configClassesEnhanced++;\n        }\n\n        if (configClassesEnhanced \u003d\u003d 0)\n            logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n    }",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/internal/process/InternalConfigurationPostProcessor.java",
      "functionStartLine": 108,
      "functionName": "enhanceAnyConfigurationClasses",
      "diff": "@@ -1,29 +1,28 @@\n     private void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory, ConfigurationModel model) {\n         \n         ConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n \n         int configClassesEnhanced \u003d 0;\n \n         for (String beanName : beanFactory.getBeanDefinitionNames()) {\n             BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n \n-            // is the beanDef marked as representing a configuration class?\n             if (!isConfigClass(beanDef))\n                 continue;\n \n             String configClassName \u003d beanDef.getBeanClassName();\n \n             String enhancedClassName \u003d enhancer.enhance(configClassName);\n \n             if (logger.isDebugEnabled())\n                 logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n                                            beanName, configClassName, enhancedClassName));\n \n             beanDef.setBeanClassName(enhancedClassName);\n \n             configClassesEnhanced++;\n         }\n \n         if (configClassesEnhanced \u003d\u003d 0)\n             logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d4fdad2202a16e2df11aefa2632b781ecef020ea": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "+ Further repackaging and consolidation\n+ Tested compatibility with @Value (works, but noticed and filed an unrelated-to-javaconfig improvement. See SPR-5530)\n",
      "commitDate": "2009-02-27, 8:35 p.m.",
      "commitName": "d4fdad2202a16e2df11aefa2632b781ecef020ea",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "+ Further repackaging and consolidation\n+ Tested compatibility with @Value (works, but noticed and filed an unrelated-to-javaconfig improvement. See SPR-5530)\n",
          "commitDate": "2009-02-27, 8:35 p.m.",
          "commitName": "d4fdad2202a16e2df11aefa2632b781ecef020ea",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009-02-26, 8:35 p.m.",
          "commitNameOld": "e48fe0d89271113bcac4e7c41e86cb1d8230594e",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "    private void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory, ConfigurationModel model) {\n        \n        ConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n\n        int configClassesEnhanced \u003d 0;\n\n        for (String beanName : beanFactory.getBeanDefinitionNames()) {\n            BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\n            // is the beanDef marked as representing a configuration class?\n            if (!isConfigClass(beanDef))\n                continue;\n\n            String configClassName \u003d beanDef.getBeanClassName();\n\n            String enhancedClassName \u003d enhancer.enhance(configClassName);\n\n            if (logger.isDebugEnabled())\n                logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n                                           beanName, configClassName, enhancedClassName));\n\n            beanDef.setBeanClassName(enhancedClassName);\n\n            configClassesEnhanced++;\n        }\n\n        if (configClassesEnhanced \u003d\u003d 0)\n            logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n    }",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/internal/process/InternalConfigurationPostProcessor.java",
          "functionStartLine": 90,
          "functionName": "enhanceAnyConfigurationClasses",
          "diff": "@@ -1,34 +1,29 @@\n-    private void enhanceAnyConfigurationClasses(ConfigurableListableBeanFactory clbf, ConfigurationModel model) {\n-        if(!(clbf instanceof DefaultListableBeanFactory))\n-            throw new IllegalStateException(\"beanFactory must be of type \"\n-                    + DefaultListableBeanFactory.class.getSimpleName());\n+    private void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory, ConfigurationModel model) {\n         \n-        DefaultListableBeanFactory beanFactory \u003d (DefaultListableBeanFactory)clbf;\n-        \n-        ConfigurationEnhancer enhancer \u003d new CglibConfigurationEnhancer(beanFactory, model);\n+        ConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n \n         int configClassesEnhanced \u003d 0;\n \n         for (String beanName : beanFactory.getBeanDefinitionNames()) {\n             BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n \n             // is the beanDef marked as representing a configuration class?\n             if (!isConfigClass(beanDef))\n                 continue;\n \n             String configClassName \u003d beanDef.getBeanClassName();\n \n             String enhancedClassName \u003d enhancer.enhance(configClassName);\n \n             if (logger.isDebugEnabled())\n                 logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n                                            beanName, configClassName, enhancedClassName));\n \n             beanDef.setBeanClassName(enhancedClassName);\n \n             configClassesEnhanced++;\n         }\n \n         if (configClassesEnhanced \u003d\u003d 0)\n             logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[clbf-ConfigurableListableBeanFactory, model-ConfigurationModel]",
            "newValue": "[beanFactory-DefaultListableBeanFactory, model-ConfigurationModel]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "+ Further repackaging and consolidation\n+ Tested compatibility with @Value (works, but noticed and filed an unrelated-to-javaconfig improvement. See SPR-5530)\n",
          "commitDate": "2009-02-27, 8:35 p.m.",
          "commitName": "d4fdad2202a16e2df11aefa2632b781ecef020ea",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009-02-26, 8:35 p.m.",
          "commitNameOld": "e48fe0d89271113bcac4e7c41e86cb1d8230594e",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "    private void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory, ConfigurationModel model) {\n        \n        ConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n\n        int configClassesEnhanced \u003d 0;\n\n        for (String beanName : beanFactory.getBeanDefinitionNames()) {\n            BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\n            // is the beanDef marked as representing a configuration class?\n            if (!isConfigClass(beanDef))\n                continue;\n\n            String configClassName \u003d beanDef.getBeanClassName();\n\n            String enhancedClassName \u003d enhancer.enhance(configClassName);\n\n            if (logger.isDebugEnabled())\n                logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n                                           beanName, configClassName, enhancedClassName));\n\n            beanDef.setBeanClassName(enhancedClassName);\n\n            configClassesEnhanced++;\n        }\n\n        if (configClassesEnhanced \u003d\u003d 0)\n            logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n    }",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/internal/process/InternalConfigurationPostProcessor.java",
          "functionStartLine": 90,
          "functionName": "enhanceAnyConfigurationClasses",
          "diff": "@@ -1,34 +1,29 @@\n-    private void enhanceAnyConfigurationClasses(ConfigurableListableBeanFactory clbf, ConfigurationModel model) {\n-        if(!(clbf instanceof DefaultListableBeanFactory))\n-            throw new IllegalStateException(\"beanFactory must be of type \"\n-                    + DefaultListableBeanFactory.class.getSimpleName());\n+    private void enhanceAnyConfigurationClasses(DefaultListableBeanFactory beanFactory, ConfigurationModel model) {\n         \n-        DefaultListableBeanFactory beanFactory \u003d (DefaultListableBeanFactory)clbf;\n-        \n-        ConfigurationEnhancer enhancer \u003d new CglibConfigurationEnhancer(beanFactory, model);\n+        ConfigurationEnhancer enhancer \u003d new ConfigurationEnhancer(beanFactory, model);\n \n         int configClassesEnhanced \u003d 0;\n \n         for (String beanName : beanFactory.getBeanDefinitionNames()) {\n             BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n \n             // is the beanDef marked as representing a configuration class?\n             if (!isConfigClass(beanDef))\n                 continue;\n \n             String configClassName \u003d beanDef.getBeanClassName();\n \n             String enhancedClassName \u003d enhancer.enhance(configClassName);\n \n             if (logger.isDebugEnabled())\n                 logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n                                            beanName, configClassName, enhancedClassName));\n \n             beanDef.setBeanClassName(enhancedClassName);\n \n             configClassesEnhanced++;\n         }\n \n         if (configClassesEnhanced \u003d\u003d 0)\n             logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e48fe0d89271113bcac4e7c41e86cb1d8230594e": {
      "type": "Yintroduced",
      "commitMessage": "Initial cut at migrating JavaConfig essentials into Core. test.basic.BasicTests successfully excercises the simplest possible @Configuration class (contains a single @Bean method). 39 classes were pulled in from from JavaConfig to support this use case.\n\n",
      "commitDate": "2009-02-26, 8:35 p.m.",
      "commitName": "e48fe0d89271113bcac4e7c41e86cb1d8230594e",
      "commitAuthor": "Chris Beams",
      "diff": "@@ -0,0 +1,34 @@\n+    private void enhanceAnyConfigurationClasses(ConfigurableListableBeanFactory clbf, ConfigurationModel model) {\n+        if(!(clbf instanceof DefaultListableBeanFactory))\n+            throw new IllegalStateException(\"beanFactory must be of type \"\n+                    + DefaultListableBeanFactory.class.getSimpleName());\n+        \n+        DefaultListableBeanFactory beanFactory \u003d (DefaultListableBeanFactory)clbf;\n+        \n+        ConfigurationEnhancer enhancer \u003d new CglibConfigurationEnhancer(beanFactory, model);\n+\n+        int configClassesEnhanced \u003d 0;\n+\n+        for (String beanName : beanFactory.getBeanDefinitionNames()) {\n+            BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n+\n+            // is the beanDef marked as representing a configuration class?\n+            if (!isConfigClass(beanDef))\n+                continue;\n+\n+            String configClassName \u003d beanDef.getBeanClassName();\n+\n+            String enhancedClassName \u003d enhancer.enhance(configClassName);\n+\n+            if (logger.isDebugEnabled())\n+                logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n+                                           beanName, configClassName, enhancedClassName));\n+\n+            beanDef.setBeanClassName(enhancedClassName);\n+\n+            configClassesEnhanced++;\n+        }\n+\n+        if (configClassesEnhanced \u003d\u003d 0)\n+            logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void enhanceAnyConfigurationClasses(ConfigurableListableBeanFactory clbf, ConfigurationModel model) {\n        if(!(clbf instanceof DefaultListableBeanFactory))\n            throw new IllegalStateException(\"beanFactory must be of type \"\n                    + DefaultListableBeanFactory.class.getSimpleName());\n        \n        DefaultListableBeanFactory beanFactory \u003d (DefaultListableBeanFactory)clbf;\n        \n        ConfigurationEnhancer enhancer \u003d new CglibConfigurationEnhancer(beanFactory, model);\n\n        int configClassesEnhanced \u003d 0;\n\n        for (String beanName : beanFactory.getBeanDefinitionNames()) {\n            BeanDefinition beanDef \u003d beanFactory.getBeanDefinition(beanName);\n\n            // is the beanDef marked as representing a configuration class?\n            if (!isConfigClass(beanDef))\n                continue;\n\n            String configClassName \u003d beanDef.getBeanClassName();\n\n            String enhancedClassName \u003d enhancer.enhance(configClassName);\n\n            if (logger.isDebugEnabled())\n                logger.debug(String.format(\"Replacing bean definition \u0027%s\u0027 existing class name \u0027%s\u0027 with enhanced class name \u0027%s\u0027\",\n                                           beanName, configClassName, enhancedClassName));\n\n            beanDef.setBeanClassName(enhancedClassName);\n\n            configClassesEnhanced++;\n        }\n\n        if (configClassesEnhanced \u003d\u003d 0)\n            logger.warn(\"Found no @Configuration class BeanDefinitions within \" + beanFactory);\n    }",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/internal/process/InternalConfigurationPostProcessor.java",
      "functionStartLine": 87,
      "functionName": "enhanceAnyConfigurationClasses"
    }
  }
}