{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "H:\\Projects\\apache\\commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "NumberUtils.java",
  "functionName": "createNumber",
  "functionId": "createNumber___str-String(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
  "functionStartLine": 450,
  "functionEndLine": 617,
  "numCommitsSeen": 123,
  "timeTaken": 5540,
  "changeHistory": [
    "b610707cd072f07efb816074a4844bb1b31e482c",
    "214cc7fd596b575ed07a7d7c1006b46d5c75613d",
    "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284",
    "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435",
    "dfd69e038cc7035031d1807c4ade870d2a7e2ece",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
    "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
    "b877fb9abef4a19eec9cc7329acbd433648b8f7b",
    "45a6467088a08e447d7f2983551021b91c70ab49",
    "d1a45e9738de5b3e299bb51e987565dcce55fee6",
    "8a1042959df80c06dbfa83896594caa8e20ff9d6",
    "d80be57d6eecc99411a77ab9575e1991bb616abc",
    "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
    "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "d844d1eb5e5b530a82b77302f1f284fd2f924be3",
    "350cf8c2da08ccde6b4d71b19bb3df97256ea368",
    "c7adc7e86f118a92ac4eee5a3c6775eec11af115",
    "41326bf5266ecc6472bab28481b77cecd6f7fb5c",
    "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c",
    "50c1fdecb4ed33ec1bb0d449f294c299d5369701",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "26bc3fe010d5154d3ccac526ec22c429fc3af499",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "5beb105d6b4188e6babefd89e19b06df1d71886c",
    "15360774099b2a7230e020751acdf6979b6e3f58",
    "073222372614fcff2f4824d46a817c44e4b03d09",
    "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f",
    "b73111983b7916b3944e2178d079f1326cd8df06",
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
    "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25",
    "3b19309d76817dfacb40299b474ecbc27a471e11",
    "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb"
  ],
  "changeHistoryShort": {
    "b610707cd072f07efb816074a4844bb1b31e482c": "Ybodychange",
    "214cc7fd596b575ed07a7d7c1006b46d5c75613d": "Ybodychange",
    "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284": "Yexceptionschange",
    "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435": "Ybodychange",
    "dfd69e038cc7035031d1807c4ade870d2a7e2ece": "Ybodychange",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": "Ybodychange",
    "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c": "Ybodychange",
    "b877fb9abef4a19eec9cc7329acbd433648b8f7b": "Ybodychange",
    "45a6467088a08e447d7f2983551021b91c70ab49": "Ybodychange",
    "d1a45e9738de5b3e299bb51e987565dcce55fee6": "Ybodychange",
    "8a1042959df80c06dbfa83896594caa8e20ff9d6": "Ybodychange",
    "d80be57d6eecc99411a77ab9575e1991bb616abc": "Ybodychange",
    "b3db6ed9efd0b8ed8a940f2735abb156030d10f9": "Ybodychange",
    "ad43a49dabd5cc14e8ff4b91dbb03477063c1314": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "d844d1eb5e5b530a82b77302f1f284fd2f924be3": "Ybodychange",
    "350cf8c2da08ccde6b4d71b19bb3df97256ea368": "Ybodychange",
    "c7adc7e86f118a92ac4eee5a3c6775eec11af115": "Ybodychange",
    "41326bf5266ecc6472bab28481b77cecd6f7fb5c": "Ybodychange",
    "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c": "Ybodychange",
    "50c1fdecb4ed33ec1bb0d449f294c299d5369701": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "26bc3fe010d5154d3ccac526ec22c429fc3af499": "Ybodychange",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "5beb105d6b4188e6babefd89e19b06df1d71886c": "Ybodychange",
    "15360774099b2a7230e020751acdf6979b6e3f58": "Ybodychange",
    "073222372614fcff2f4824d46a817c44e4b03d09": "Ybodychange",
    "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f": "Ybodychange",
    "b73111983b7916b3944e2178d079f1326cd8df06": "Ybodychange",
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": "Ybodychange",
    "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25": "Ybodychange",
    "3b19309d76817dfacb40299b474ecbc27a471e11": "Ybodychange",
    "af6aba957f4dc4d19d5f295172b4ddc941ca1681": "Ymultichange(Yparameterchange,Ybodychange)",
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b610707cd072f07efb816074a4844bb1b31e482c": {
      "type": "Ybodychange",
      "commitMessage": "removes unnecessary class reference of static method calls which are declared in the same class\n",
      "commitDate": "2018-06-20, 7:28 a.m.",
      "commitName": "b610707cd072f07efb816074a4844bb1b31e482c",
      "commitAuthor": "Igor Curdvanovschi",
      "commitDateOld": "2018-06-20, 6:05 a.m.",
      "commitNameOld": "214cc7fd596b575ed07a7d7c1006b46d5c75613d",
      "commitAuthorOld": "Igor Curdvanovschi",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        if (decPos \u003e -1) { // there is a decimal point\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (!numeric.isEmpty() \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d createDouble(str);\n                        if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            final Double d \u003d createDouble(str);\n            if (!f.isInfinite()\n                    \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                    \u0026\u0026 f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                final BigDecimal b \u003d createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos \u003e -1) { // there is a decimal point\n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d getMantissa(str, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d getMantissa(str, expPos);\n             } else {\n                 mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (!numeric.isEmpty() \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n-                        final Float f \u003d NumberUtils.createFloat(str);\n+                        final Float f \u003d createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n-                        final Double d \u003d NumberUtils.createDouble(str);\n+                        final Double d \u003d createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             final Float f \u003d createFloat(str);\n             final Double d \u003d createDouble(str);\n             if (!f.isInfinite()\n                     \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                     \u0026\u0026 f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                 final BigDecimal b \u003d createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "214cc7fd596b575ed07a7d7c1006b46d5c75613d": {
      "type": "Ybodychange",
      "commitMessage": "replaces \u0027size() \u003d\u003d 0\u0027 and \u0027length() \u003d\u003d 0\u0027 with \u0027isEmpty()\u0027\n",
      "commitDate": "2018-06-20, 6:05 a.m.",
      "commitName": "214cc7fd596b575ed07a7d7c1006b46d5c75613d",
      "commitAuthor": "Igor Curdvanovschi",
      "commitDateOld": "2018-06-20, 2:03 a.m.",
      "commitNameOld": "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284",
      "commitAuthorOld": "Igor Curdvanovschi",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        if (decPos \u003e -1) { // there is a decimal point\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (!numeric.isEmpty() \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(str);\n                        if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            final Double d \u003d createDouble(str);\n            if (!f.isInfinite()\n                    \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                    \u0026\u0026 f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                final BigDecimal b \u003d createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos \u003e -1) { // there is a decimal point\n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d getMantissa(str, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d getMantissa(str, expPos);\n             } else {\n                 mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n-                        \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        \u0026\u0026 (!numeric.isEmpty() \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             final Float f \u003d createFloat(str);\n             final Double d \u003d createDouble(str);\n             if (!f.isInfinite()\n                     \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                     \u0026\u0026 f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                 final BigDecimal b \u003d createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284": {
      "type": "Yexceptionschange",
      "commitMessage": "removes unchecked exceptions declared in \u0027throws\u0027 clause\n",
      "commitDate": "2018-06-20, 2:03 a.m.",
      "commitName": "e767af7e7eb8ff7724d5f72709ee4bb7a72d2284",
      "commitAuthor": "Igor Curdvanovschi",
      "commitDateOld": "2018-03-10, 8:16 p.m.",
      "commitNameOld": "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435",
      "commitAuthorOld": "Gary Gregory",
      "daysBetweenCommits": 101.2,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        if (decPos \u003e -1) { // there is a decimal point\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(str);\n                        if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            final Double d \u003d createDouble(str);\n            if (!f.isInfinite()\n                    \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                    \u0026\u0026 f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                final BigDecimal b \u003d createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,168 +1,168 @@\n-    public static Number createNumber(final String str) throws NumberFormatException {\n+    public static Number createNumber(final String str) {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos \u003e -1) { // there is a decimal point\n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d getMantissa(str, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d getMantissa(str, expPos);\n             } else {\n                 mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             final Float f \u003d createFloat(str);\n             final Double d \u003d createDouble(str);\n             if (!f.isInfinite()\n                     \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                     \u0026\u0026 f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                 final BigDecimal b \u003d createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[NumberFormatException]",
        "newValue": "[]"
      }
    },
    "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435": {
      "type": "Ybodychange",
      "commitMessage": "[LANG-1385] NumberUtils.createNumber() throws\nStringIndexOutOfBoundsException instead of NumberFormatException.",
      "commitDate": "2018-03-10, 8:16 p.m.",
      "commitName": "8b62c114cfc5fd347bd8cb5a391fdfa8cb539435",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": "2018-02-11, 6:08 a.m.",
      "commitNameOld": "c8e61afdb89c58ea8ffaf04593da41ff0888d30e",
      "commitAuthorOld": "Piotr Kosmala",
      "daysBetweenCommits": 27.59,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        if (decPos \u003e -1) { // there is a decimal point\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(str);\n                        if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            final Double d \u003d createDouble(str);\n            if (!f.isInfinite()\n                    \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                    \u0026\u0026 f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                final BigDecimal b \u003d createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos \u003e -1) { // there is a decimal point\n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d getMantissa(str, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d getMantissa(str, expPos);\n             } else {\n                 mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n-                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        \u0026\u0026 (numeric.length() \u003e 0 \u0026\u0026 numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             final Float f \u003d createFloat(str);\n             final Double d \u003d createDouble(str);\n             if (!f.isInfinite()\n                     \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                     \u0026\u0026 f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                 final BigDecimal b \u003d createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dfd69e038cc7035031d1807c4ade870d2a7e2ece": {
      "type": "Ybodychange",
      "commitMessage": "Fix unbox warning. Show when we are unboxing.",
      "commitDate": "2016-11-18, 4:38 p.m.",
      "commitName": "dfd69e038cc7035031d1807c4ade870d2a7e2ece",
      "commitAuthor": "Gary Gregory",
      "commitDateOld": "2016-10-23, 1:55 p.m.",
      "commitNameOld": "aadb9a31ed969fc72cc87d486ec02383faa5bd06",
      "commitAuthorOld": "Gary Gregory",
      "daysBetweenCommits": 26.16,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        if (decPos \u003e -1) { // there is a decimal point\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(str);\n                        if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            final Double d \u003d createDouble(str);\n            if (!f.isInfinite()\n                    \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                    \u0026\u0026 f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                final BigDecimal b \u003d createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 451,
      "functionName": "createNumber",
      "diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos \u003e -1) { // there is a decimal point\n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d getMantissa(str, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d getMantissa(str, expPos);\n             } else {\n                 mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             final Float f \u003d createFloat(str);\n             final Double d \u003d createDouble(str);\n             if (!f.isInfinite()\n                     \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                     \u0026\u0026 f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                 final BigDecimal b \u003d createBigDecimal(str);\n-                if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n+                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) \u003d\u003d 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Remove useless parentheses\n",
      "commitDate": "2016-09-19, 7:56 a.m.",
      "commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2016-09-11, 1:00 p.m.",
      "commitNameOld": "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01",
      "commitAuthorOld": "Rob Tompkins",
      "daysBetweenCommits": 7.79,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        if (decPos \u003e -1) { // there is a decimal point\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(str);\n                        if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            final Double d \u003d createDouble(str);\n            if (!f.isInfinite()\n                    \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                    \u0026\u0026 f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                final BigDecimal b \u003d createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 451,
      "functionName": "createNumber",
      "diff": "@@ -1,168 +1,168 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n-            if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n+            if (hexDigits \u003e 16 || hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for Long\n                 return createBigInteger(str);\n             }\n-            if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n+            if (hexDigits \u003e 8 || hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos \u003e -1) { // there is a decimal point\n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d getMantissa(str, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d getMantissa(str, expPos);\n             } else {\n                 mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(str);\n-                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                        if (!(f.isInfinite() || f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(str);\n-                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                        if (!(d.isInfinite() || d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             final Float f \u003d createFloat(str);\n             final Double d \u003d createDouble(str);\n             if (!f.isInfinite()\n                     \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                     \u0026\u0026 f.toString().equals(d.toString())) {\n                 return f;\n             }\n             if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                 final BigDecimal b \u003d createBigDecimal(str);\n                 if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n                     return d;\n                 }\n                 return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1018: Fix precision loss on NumberUtils.createNumber(String) (closes #156)\n",
      "commitDate": "2016-06-12, 7:23 a.m.",
      "commitName": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
      "commitAuthor": "Nick Manley",
      "commitDateOld": "2016-06-03, 11:07 a.m.",
      "commitNameOld": "faeaa303b903139f36c15751c8e48ef982222842",
      "commitAuthorOld": "Eric Wannemacher",
      "daysBetweenCommits": 8.84,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        if (decPos \u003e -1) { // there is a decimal point\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(str);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(str);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            final Double d \u003d createDouble(str);\n            if (!f.isInfinite()\n                    \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n                    \u0026\u0026 f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n                final BigDecimal b \u003d createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,174 +1,168 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n-        int numDecimals \u003d 0; // Check required precision (LANG-693)\n         if (decPos \u003e -1) { // there is a decimal point\n-\n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d getMantissa(str, decPos);\n-            numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d getMantissa(str, expPos);\n             } else {\n                 mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n-            if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n-                final Float f \u003d createFloat(str);\n-                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n-                    return f;\n-                }\n+            final Float f \u003d createFloat(str);\n+            final Double d \u003d createDouble(str);\n+            if (!f.isInfinite()\n+                    \u0026\u0026 !(f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros)\n+                    \u0026\u0026 f.toString().equals(d.toString())) {\n+                return f;\n             }\n-        } catch (final NumberFormatException nfe) { // NOPMD\n-            // ignore the bad number\n-        }\n-        try {\n-            if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n-                final Double d \u003d createDouble(str);\n-                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+            if (!d.isInfinite() \u0026\u0026 !(d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros)) {\n+                final BigDecimal b \u003d createBigDecimal(str);\n+                if (b.compareTo(BigDecimal.valueOf(d)) \u003d\u003d 0) {\n                     return d;\n                 }\n+                return b;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n-\n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b877fb9abef4a19eec9cc7329acbd433648b8f7b": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1205: NumberUtils.createNumber() behaves inconsistently with NumberUtils.isNumber()\nThis closes github #87 thanks to pbrose\n",
      "commitDate": "2016-04-23, 11:35 p.m.",
      "commitName": "b877fb9abef4a19eec9cc7329acbd433648b8f7b",
      "commitAuthor": "Chas Honton",
      "commitDateOld": "2016-02-25, 11:52 p.m.",
      "commitNameOld": "69e97c8b42b9ad0880618132a613466f4e4779d3",
      "commitAuthorOld": "Hen",
      "daysBetweenCommits": 57.95,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals \u003d 0; // Check required precision (LANG-693)\n        if (decPos \u003e -1) { // there is a decimal point\n\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n            numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(str);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(str);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,174 +1,174 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         int numDecimals \u003d 0; // Check required precision (LANG-693)\n         if (decPos \u003e -1) { // there is a decimal point\n \n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d getMantissa(str, decPos);\n             numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d getMantissa(str, expPos);\n             } else {\n                 mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n-                        final Float f \u003d NumberUtils.createFloat(numeric);\n+                        final Float f \u003d NumberUtils.createFloat(str);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n-                        final Double d \u003d NumberUtils.createDouble(numeric);\n+                        final Double d \u003d NumberUtils.createDouble(str);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45a6467088a08e447d7f2983551021b91c70ab49": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1087: NumberUtils#createNumber() returns positive BigDecimal when negative Float is expected. Thanks to Renat Zhilkibaev.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1663129 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015-03-01, 11:48 a.m.",
      "commitName": "45a6467088a08e447d7f2983551021b91c70ab49",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014-12-12, 4:15 p.m.",
      "commitNameOld": "05763470e5a067eb153533d47baa73174ad9bd46",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 78.81,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals \u003d 0; // Check required precision (LANG-693)\n        if (decPos \u003e -1) { // there is a decimal point\n\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d getMantissa(str, decPos);\n            numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d getMantissa(str, expPos);\n            } else {\n                mant \u003d getMantissa(str);\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 451,
      "functionName": "createNumber",
      "diff": "@@ -1,174 +1,174 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             char firstSigDigit \u003d 0; // strip leading zeroes\n             for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                 firstSigDigit \u003d str.charAt(i);\n                 if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                     pfxLen++;\n                 } else {\n                     break;\n                 }\n             }\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         int numDecimals \u003d 0; // Check required precision (LANG-693)\n         if (decPos \u003e -1) { // there is a decimal point\n \n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n-            mant \u003d str.substring(0, decPos);\n+            mant \u003d getMantissa(str, decPos);\n             numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n-                mant \u003d str.substring(0, expPos);\n+                mant \u003d getMantissa(str, expPos);\n             } else {\n-                mant \u003d str;\n+                mant \u003d getMantissa(str);\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d1a45e9738de5b3e299bb51e987565dcce55fee6": {
      "type": "Ybodychange",
      "commitMessage": "LANG-747 NumberUtils does not handle Long Hex numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1507169 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-07-25, 9:03 p.m.",
      "commitName": "d1a45e9738de5b3e299bb51e987565dcce55fee6",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013-05-19, 6:22 a.m.",
      "commitNameOld": "8a1042959df80c06dbfa83896594caa8e20ff9d6",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 67.61,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            char firstSigDigit \u003d 0; // strip leading zeroes\n            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n                firstSigDigit \u003d str.charAt(i);\n                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals \u003d 0; // Check required precision (LANG-693)\n        if (decPos \u003e -1) { // there is a decimal point\n\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n            numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,165 +1,174 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n+            char firstSigDigit \u003d 0; // strip leading zeroes\n+            for(int i \u003d pfxLen; i \u003c str.length(); i++) {\n+                firstSigDigit \u003d str.charAt(i);\n+                if (firstSigDigit \u003d\u003d \u00270\u0027) { // count leading zeroes\n+                    pfxLen++;\n+                } else {\n+                    break;\n+                }\n+            }\n             final int hexDigits \u003d str.length() - pfxLen;\n-            if (hexDigits \u003e 16) { // too many for Long\n+            if (hexDigits \u003e 16 || (hexDigits \u003d\u003d 16 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for Long\n                 return createBigInteger(str);\n             }\n-            if (hexDigits \u003e 8) { // too many for an int\n+            if (hexDigits \u003e 8 || (hexDigits \u003d\u003d 8 \u0026\u0026 firstSigDigit \u003e \u00277\u0027)) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         int numDecimals \u003d 0; // Check required precision (LANG-693)\n         if (decPos \u003e -1) { // there is a decimal point\n \n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n             numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f \u003d createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d \u003d createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8a1042959df80c06dbfa83896594caa8e20ff9d6": {
      "type": "Ybodychange",
      "commitMessage": "LANG-693 Method createNumber from NumberUtils doesn\u0027t work for floating point numbers other than Float\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1484263 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-05-19, 6:22 a.m.",
      "commitName": "8a1042959df80c06dbfa83896594caa8e20ff9d6",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013-03-27, 12:29 p.m.",
      "commitNameOld": "d80be57d6eecc99411a77ab9575e1991bb616abc",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 52.74,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals \u003d 0; // Check required precision (LANG-693)\n        if (decPos \u003e -1) { // there is a decimal point\n\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n            numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f \u003d createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d \u003d createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,159 +1,165 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n+        int numDecimals \u003d 0; // Check required precision (LANG-693)\n         if (decPos \u003e -1) { // there is a decimal point\n \n             if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n+            numDecimals \u003d dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n-            final Float f \u003d createFloat(str);\n-            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n-                return f;\n+            if(numDecimals \u003c\u003d 7){// If number has 7 or fewer digits past the decimal point then make it a float\n+                final Float f \u003d createFloat(str);\n+                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                    return f;\n+                }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n-            final Double d \u003d createDouble(str);\n-            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n-                return d;\n+            if(numDecimals \u003c\u003d 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n+                final Double d \u003d createDouble(str);\n+                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                    return d;\n+                }\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d80be57d6eecc99411a77ab9575e1991bb616abc": {
      "type": "Ybodychange",
      "commitMessage": "Document why double exponent (e and E) seems to work even though the index will be wrong\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461697 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-03-27, 12:29 p.m.",
      "commitName": "d80be57d6eecc99411a77ab9575e1991bb616abc",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013-03-27, 11:52 a.m.",
      "commitNameOld": "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        if (decPos \u003e -1) { // there is a decimal point\n\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                return f;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            final Double d \u003d createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                return d;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,157 +1,159 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) { // we have a hex number\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n-        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // TODO assumes both not present\n+        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // assumes both not present\n+        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n+        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n \n         if (decPos \u003e -1) { // there is a decimal point\n \n             if (expPos \u003e -1) { // there is an exponent\n-                if (expPos \u003c decPos || expPos \u003e str.length()) {\n+                if (expPos \u003c decPos || expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n-                if (expPos \u003e str.length()) {\n+                if (expPos \u003e str.length()) { // prevents double exponent causing IOOBE\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n             //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n         }\n \n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             final Float f \u003d createFloat(str);\n             if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                 return f;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             final Double d \u003d createDouble(str);\n             if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                 return d;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b3db6ed9efd0b8ed8a940f2735abb156030d10f9": {
      "type": "Ybodychange",
      "commitMessage": "LANG-881 NumberUtils.createNumber() Javadoc says it does not work for octal numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461671 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-03-27, 11:52 a.m.",
      "commitName": "b3db6ed9efd0b8ed8a940f2735abb156030d10f9",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013-03-27, 9:04 a.m.",
      "commitNameOld": "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) { // we have a hex number\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // TODO assumes both not present\n\n        if (decPos \u003e -1) { // there is a decimal point\n\n            if (expPos \u003e -1) { // there is an exponent\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                return f;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            final Double d \u003d createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                return d;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 450,
      "functionName": "createNumber",
      "diff": "@@ -1,157 +1,157 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n-        if (pfxLen \u003e 0) {\n+        if (pfxLen \u003e 0) { // we have a hex number\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n-        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n+        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1; // TODO assumes both not present\n \n-        if (decPos \u003e -1) {\n+        if (decPos \u003e -1) { // there is a decimal point\n \n-            if (expPos \u003e -1) {\n+            if (expPos \u003e -1) { // there is an exponent\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         }\n         //User doesn\u0027t have a preference on the return type, so let\u0027s start\n         //small and go from there...\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n             exp \u003d str.substring(expPos + 1, str.length());\n         } else {\n             exp \u003d null;\n         }\n-        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n-            //Must be an int,long,bigint\n+        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) { // no decimal point and no exponent\n+            //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n-\n         }\n-        //Must be a float,double,BigDec\n+\n+        //Must be a Float, Double, BigDecimal\n         final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         try {\n             final Float f \u003d createFloat(str);\n             if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                 return f;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n             final Double d \u003d createDouble(str);\n             if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                 return d;\n             }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n \n         return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad43a49dabd5cc14e8ff4b91dbb03477063c1314": {
      "type": "Ybodychange",
      "commitMessage": "Statements unnecessarily nested within else clauses.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1461559 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-03-27, 9:04 a.m.",
      "commitName": "ad43a49dabd5cc14e8ff4b91dbb03477063c1314",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013-02-20, 11:47 a.m.",
      "commitNameOld": "99ff604efaee6c501efa62a910c0284f00761bec",
      "commitAuthorOld": "Thomas Neidhart",
      "daysBetweenCommits": 34.85,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) {\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n        //small and go from there...\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n            exp \u003d str.substring(expPos + 1, str.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        }\n        //Must be a float,double,BigDec\n        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        try {\n            final Float f \u003d createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                return f;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            final Double d \u003d createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                return d;\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 446,
      "functionName": "createNumber",
      "diff": "@@ -1,160 +1,157 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) {\n             final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         final int decPos \u003d str.indexOf(\u0027.\u0027);\n         final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             final String numeric \u003d str.substring(0, str.length() - 1);\n             final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         final Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         final Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n-        } else {\n-            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n-            //small and go from there...\n-            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n-                exp \u003d str.substring(expPos + 1, str.length());\n-            } else {\n-                exp \u003d null;\n-            }\n-            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n-                //Must be an int,long,bigint\n-                try {\n-                    return createInteger(str);\n-                } catch (final NumberFormatException nfe) { // NOPMD\n-                    // ignore the bad number\n-                }\n-                try {\n-                    return createLong(str);\n-                } catch (final NumberFormatException nfe) { // NOPMD\n-                    // ignore the bad number\n-                }\n-                return createBigInteger(str);\n-\n-            } else {\n-                //Must be a float,double,BigDec\n-                final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n-                try {\n-                    final Float f \u003d createFloat(str);\n-                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n-                        return f;\n-                    }\n-                } catch (final NumberFormatException nfe) { // NOPMD\n-                    // ignore the bad number\n-                }\n-                try {\n-                    final Double d \u003d createDouble(str);\n-                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n-                        return d;\n-                    }\n-                } catch (final NumberFormatException nfe) { // NOPMD\n-                    // ignore the bad number\n-                }\n-\n-                return createBigDecimal(str);\n-\n-            }\n         }\n+        //User doesn\u0027t have a preference on the return type, so let\u0027s start\n+        //small and go from there...\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+            exp \u003d str.substring(expPos + 1, str.length());\n+        } else {\n+            exp \u003d null;\n+        }\n+        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n+            //Must be an int,long,bigint\n+            try {\n+                return createInteger(str);\n+            } catch (final NumberFormatException nfe) { // NOPMD\n+                // ignore the bad number\n+            }\n+            try {\n+                return createLong(str);\n+            } catch (final NumberFormatException nfe) { // NOPMD\n+                // ignore the bad number\n+            }\n+            return createBigInteger(str);\n+\n+        }\n+        //Must be a float,double,BigDec\n+        final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+        try {\n+            final Float f \u003d createFloat(str);\n+            if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                return f;\n+            }\n+        } catch (final NumberFormatException nfe) { // NOPMD\n+            // ignore the bad number\n+        }\n+        try {\n+            final Double d \u003d createDouble(str);\n+            if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                return d;\n+            }\n+        } catch (final NumberFormatException nfe) { // NOPMD\n+            // ignore the bad number\n+        }\n+\n+        return createBigDecimal(str);\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:09 a.m.",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013-01-22, 2:07 a.m.",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) {\n            final int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos \u003d str.indexOf(\u0027.\u0027);\n        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            final String numeric \u003d str.substring(0, str.length() - 1);\n            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        final Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        final Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    final Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    final Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 446,
      "functionName": "createNumber",
      "diff": "@@ -1,160 +1,160 @@\n     public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n-        for(String pfx : hex_prefixes) {\n+        for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) {\n-            int hexDigits \u003d str.length() - pfxLen;\n+            final int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n-        char lastChar \u003d str.charAt(str.length() - 1);\n+        final char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n-        int decPos \u003d str.indexOf(\u0027.\u0027);\n-        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n+        final int decPos \u003d str.indexOf(\u0027.\u0027);\n+        final int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n-            String numeric \u003d str.substring(0, str.length() - 1);\n-            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+            final String numeric \u003d str.substring(0, str.length() - 1);\n+            final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n-                        } catch (NumberFormatException nfe) { // NOPMD\n+                        } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n-                        Float f \u003d NumberUtils.createFloat(numeric);\n+                        final Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n-                    } catch (NumberFormatException nfe) { // NOPMD\n+                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n-                        Double d \u003d NumberUtils.createDouble(numeric);\n+                        final Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n-                    } catch (NumberFormatException nfe) { // NOPMD\n+                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n-                    } catch (NumberFormatException e) { // NOPMD\n+                    } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n-                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+                final boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n-                    Float f \u003d createFloat(str);\n+                    final Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n-                    Double d \u003d createDouble(str);\n+                    final Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013-01-22, 2:07 a.m.",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012-11-13, 8:21 a.m.",
      "commitNameOld": "f5a83bb90cf7b318ac72823e6b99d01d060abe41",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 69.74,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) {\n            int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 446,
      "functionName": "createNumber",
      "diff": "@@ -1,160 +1,160 @@\n-    public static Number createNumber(String str) throws NumberFormatException {\n+    public static Number createNumber(final String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen \u003d 0;\n         for(String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen +\u003d pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen \u003e 0) {\n             int hexDigits \u003d str.length() - pfxLen;\n             if (hexDigits \u003e 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[str-String]",
        "newValue": "[str-String(modifiers-final)]"
      }
    },
    "d844d1eb5e5b530a82b77302f1f284fd2f924be3": {
      "type": "Ybodychange",
      "commitMessage": "LANG-854 NumberUtils#createNumber - does not allow for hex numbers to be larger than Long\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1408537 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012-11-12, 8:39 p.m.",
      "commitName": "d844d1eb5e5b530a82b77302f1f284fd2f924be3",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2012-11-12, 7:59 p.m.",
      "commitNameOld": "c1f9320476ab9e5f262fdf8a5b3e1ff70199aed8",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen \u003d 0;\n        for(String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen +\u003d pfx.length();\n                break;\n            }\n        }\n        if (pfxLen \u003e 0) {\n            int hexDigits \u003d str.length() - pfxLen;\n            if (hexDigits \u003e 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 445,
      "functionName": "createNumber",
      "diff": "@@ -1,151 +1,160 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n-        }  \n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n-            int hexDigits \u003d str.length() - 2; // drop 0x\n-            if (str.startsWith(\"-\")) { // drop -\n-                hexDigits--;\n+        }\n+        // Need to deal with all possible hex prefixes here\n+        final String[] hex_prefixes \u003d {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n+        int pfxLen \u003d 0;\n+        for(String pfx : hex_prefixes) {\n+            if (str.startsWith(pfx)) {\n+                pfxLen +\u003d pfx.length();\n+                break;\n+            }\n+        }\n+        if (pfxLen \u003e 0) {\n+            int hexDigits \u003d str.length() - pfxLen;\n+            if (hexDigits \u003e 16) { // too many for Long\n+                return createBigInteger(str);\n             }\n             if (hexDigits \u003e 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n-        }   \n+        }\n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "350cf8c2da08ccde6b4d71b19bb3df97256ea368": {
      "type": "Ybodychange",
      "commitMessage": "LANG-822: NumberUtils#createNumber - bad behaviour for leading \"--\" \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1407973 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012-11-11, 8:16 a.m.",
      "commitName": "350cf8c2da08ccde6b4d71b19bb3df97256ea368",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2012-11-11, 8:00 a.m.",
      "commitNameOld": "a7b467a74cbe1160d676dc070a19d19764e132a3",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits \u003d str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n                hexDigits--;\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 445,
      "functionName": "createNumber",
      "diff": "@@ -1,158 +1,151 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n-            // this is protection for poorness in java.lang.BigDecimal.\n-            // it accepts this as a legal value, but it does not appear \n-            // to be in specification of class. OS X Java parses it to \n-            // a wrong value.\n-            return null;\n-        }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits \u003d str.length() - 2; // drop 0x\n             if (str.startsWith(\"-\")) { // drop -\n                 hexDigits--;\n             }\n             if (hexDigits \u003e 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7adc7e86f118a92ac4eee5a3c6775eec11af115": {
      "type": "Ybodychange",
      "commitMessage": "LANG-747 NumberUtils does not handle Long Hex numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1384126 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012-09-12, 5:10 p.m.",
      "commitName": "c7adc7e86f118a92ac4eee5a3c6775eec11af115",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2011-11-09, 11:11 a.m.",
      "commitNameOld": "163731256b63f03cd2b676baac88fe7ad61b2a6f",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 308.21,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits \u003d str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n                hexDigits--;\n            }\n            if (hexDigits \u003e 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 445,
      "functionName": "createNumber",
      "diff": "@@ -1,151 +1,158 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n+            int hexDigits \u003d str.length() - 2; // drop 0x\n+            if (str.startsWith(\"-\")) { // drop -\n+                hexDigits--;\n+            }\n+            if (hexDigits \u003e 8) { // too many for an int\n+                return createLong(str);\n+            }\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "41326bf5266ecc6472bab28481b77cecd6f7fb5c": {
      "type": "Ybodychange",
      "commitMessage": "LANG-746 NumberUtils does not handle upper-case hex: 0X and -0X\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1160660 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-08-23, 8:32 a.m.",
      "commitName": "41326bf5266ecc6472bab28481b77cecd6f7fb5c",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2011-08-03, 9:53 a.m.",
      "commitNameOld": "f5026c122d042e316fe1ee6314de6e8cab2708c5",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 19.94,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 444,
      "functionName": "createNumber",
      "diff": "@@ -1,151 +1,151 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c": {
      "type": "Ybodychange",
      "commitMessage": "Adding NOPMD tags for various empty catch blocks\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1089736 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011-04-07, 12:39 a.m.",
      "commitName": "d6fe7f67896642373a9c1fe3e2d75076d29b8e0c",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2011-04-05, 1:31 a.m.",
      "commitNameOld": "3a0c152c22b6e96fc809fdee2d6ea5b816a139e6",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 444,
      "functionName": "createNumber",
      "diff": "@@ -1,151 +1,151 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 if (expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n-                        } catch (NumberFormatException nfe) {\n-                            //Too big for a long\n+                        } catch (NumberFormatException nfe) { // NOPMD\n+                            // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n-                    } catch (NumberFormatException nfe) {\n+                    } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n-                    } catch (NumberFormatException nfe) {\n+                    } catch (NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n-                    } catch (NumberFormatException e) {\n+                    } catch (NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n-                } catch (NumberFormatException nfe) {\n+                } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n-                } catch (NumberFormatException nfe) {\n+                } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n-                } catch (NumberFormatException nfe) {\n+                } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n-                } catch (NumberFormatException nfe) {\n+                } catch (NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "50c1fdecb4ed33ec1bb0d449f294c299d5369701": {
      "type": "Ybodychange",
      "commitMessage": "Making it so that NumberUtils.createNumber throws a NumberFormatException instead of a StringIndexOutOfBoundsException when Strings such as 1eE are passed in. Thanks to Ingo Heinrich\u0027s report and patch in LANG-638\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@981736 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-08-03, 12:41 a.m.",
      "commitName": "50c1fdecb4ed33ec1bb0d449f294c299d5369701",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2010-02-24, 8:28 p.m.",
      "commitNameOld": "43fca0d7499c99f9e82e0ee2e52b81acdc954f2c",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 159.13,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                if (expPos \u003e str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 452,
      "functionName": "createNumber",
      "diff": "@@ -1,148 +1,151 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n-                if (expPos \u003c decPos) {\n+                if (expPos \u003c decPos || expPos \u003e str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n+                if (expPos \u003e str.length()) {\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                }\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010-01-02, 9:11 p.m.",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010-01-02, 9:09 p.m.",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 448,
      "functionName": "createNumber",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
      }
    },
    "26bc3fe010d5154d3ccac526ec22c429fc3af499": {
      "type": "Ybodychange",
      "commitMessage": "isNumber(String) and createNumber(String) both modified to support \"2.\". LANG-521\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@893088 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-22, 1:52 a.m.",
      "commitName": "26bc3fe010d5154d3ccac526ec22c429fc3af499",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-12-10, 6:56 a.m.",
      "commitNameOld": "c6e8f706dc7a236cc2a49f979d857ee92d0abd7c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 448,
      "functionName": "createNumber",
      "diff": "@@ -1,148 +1,148 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n-        if (!Character.isDigit(lastChar)) {\n+        if (!Character.isDigit(lastChar) \u0026\u0026 lastChar !\u003d \u0027.\u0027) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-12-10, 6:33 a.m.",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009-12-10, 6:31 a.m.",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 448,
      "functionName": "createNumber",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/math/NumberUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java"
      }
    },
    "5beb105d6b4188e6babefd89e19b06df1d71886c": {
      "type": "Ybodychange",
      "commitMessage": "Use Eclipse comment-style to suppress drop-thru warning\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@819700 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009-09-28, 4:07 p.m.",
      "commitName": "5beb105d6b4188e6babefd89e19b06df1d71886c",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2009-06-25, 3:09 a.m.",
      "commitNameOld": "f3ac86a292acd3fc57a2100978f3d9d2705238d2",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 95.54,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 448,
      "functionName": "createNumber",
      "diff": "@@ -1,148 +1,148 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n-                    //Fall through\n+                    //$FALL-THROUGH$\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                         // ignore the bad number\n                     }\n-                    //Fall through\n+                    //$FALL-THROUGH$\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15360774099b2a7230e020751acdf6979b6e3f58": {
      "type": "Ybodychange",
      "commitMessage": "Fixing LANG-300 (reported by Jeremy Lemaire) - 1L to 9L incorrectly throw exceptions when passed into NumberUtils.createNumber. Fixed in both the math.NumbersUtils and the deprecated NumberUtils classes. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@488819 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006-12-19, 4:50 p.m.",
      "commitName": "15360774099b2a7230e020751acdf6979b6e3f58",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006-11-05, 11:02 p.m.",
      "commitNameOld": "d8a6e05b5f23458ddd57ad838f43936520689ff7",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 43.74,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 397,
      "functionName": "createNumber",
      "diff": "@@ -1,149 +1,148 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n-                        \u0026\u0026 isDigits(numeric.substring(1))\n-                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n+                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                         // ignore the bad number\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "073222372614fcff2f4824d46a817c44e4b03d09": {
      "type": "Ybodychange",
      "commitMessage": "removed empty statement from catch block that takes no action, using comment only to denote no action;\nadded super to empty constructors\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@209373 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005-07-05, 9:15 p.m.",
      "commitName": "073222372614fcff2f4824d46a817c44e4b03d09",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2005-06-27, 4:24 p.m.",
      "commitNameOld": "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 8.2,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 397,
      "functionName": "createNumber",
      "diff": "@@ -1,149 +1,149 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 isDigits(numeric.substring(1))\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n-                            ; //Too big for a long\n+                            //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n-                      ; // empty catch\n+                        // ignore the bad number\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n-                      ; // empty constructor\n+                        // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n-                      ; // empty constructor\n+                        // ignore the bad number\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n-                  ; // empty contructor\n+                    // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n-                  ; // empty constructor\n+                    // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n-                  ; // empty constructor\n+                    // ignore the bad number\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n-                  ; // empty constructor\n+                    // ignore the bad number\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f": {
      "type": "Ybodychange",
      "commitMessage": "added empty statement to empty catch blocks\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@202043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005-06-27, 4:24 p.m.",
      "commitName": "12431fdb8fccfd0474c2a0d7666dcd2c0eed6e5f",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2005-06-26, 1:45 p.m.",
      "commitNameOld": "b73111983b7916b3944e2178d079f1326cd8df06",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            ; //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                      ; // empty catch\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                      ; // empty constructor\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                      ; // empty constructor\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                  ; // empty contructor\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                  ; // empty constructor\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                  ; // empty constructor\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                  ; // empty constructor\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 397,
      "functionName": "createNumber",
      "diff": "@@ -1,149 +1,149 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 isDigits(numeric.substring(1))\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n-                            //Too big for a long\n+                            ; //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                       ; // empty catch\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                       ; // empty constructor\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                       ; // empty constructor\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                   ; // empty contructor\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                   ; // empty constructor\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                   ; // empty constructor\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                   ; // empty constructor\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b73111983b7916b3944e2178d079f1326cd8df06": {
      "type": "Ybodychange",
      "commitMessage": "corrected style issues (mostly empty blocks and missing javadocs)\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@201882 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005-06-26, 1:45 p.m.",
      "commitName": "b73111983b7916b3944e2178d079f1326cd8df06",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "2005-04-14, 12:30 a.m.",
      "commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 73.55,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                      ; // empty catch\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                      ; // empty constructor\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                      ; // empty constructor\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                  ; // empty contructor\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                  ; // empty constructor\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                  ; // empty constructor\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                  ; // empty constructor\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 397,
      "functionName": "createNumber",
      "diff": "@@ -1,142 +1,149 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 isDigits(numeric.substring(1))\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n+                      ; // empty catch\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n+                      ; // empty constructor\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n+                      ; // empty constructor\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n+                  ; // empty contructor\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n+                  ; // empty constructor\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n+                  ; // empty constructor\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n+                  ; // empty constructor\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": {
      "type": "Ybodychange",
      "commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-09-07, 10:32 a.m.",
      "commitName": "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "2003-09-05, 11:55 a.m.",
      "commitNameOld": "69b8f445d74f22ba99a75c47a38d97d5e85248cc",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 334,
      "functionName": "createNumber",
      "diff": "@@ -1,142 +1,142 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n         if (str \u003d\u003d null) {\n             return null;\n         }\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 isDigits(numeric.substring(1))\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n-                            //has non-zeros in it, then float doens\u0027t have the presision we want\n+                            //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25": {
      "type": "Ybodychange",
      "commitMessage": "Redo null/empty string checking for performance\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137522 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-07-28, 5:37 p.m.",
      "commitName": "4f1528447ccc588f9ff6dbcf98ff3bd587c91c25",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2003-07-26, 3:12 p.m.",
      "commitNameOld": "3b19309d76817dfacb40299b474ecbc27a471e11",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float doens\u0027t have the presision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 220,
      "functionName": "createNumber",
      "diff": "@@ -1,139 +1,142 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n-        if (!validateNumber(str)) {\n+        if (str \u003d\u003d null) {\n             return null;\n         }\n+        if (StringUtils.isBlank(str)) {\n+            throw new NumberFormatException(\"A blank string is not a valid number\");\n+        }  \n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 isDigits(numeric.substring(1))\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float doens\u0027t have the presision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b19309d76817dfacb40299b474ecbc27a471e11": {
      "type": "Ybodychange",
      "commitMessage": "Fix http://nagoya.apache.org/bugzilla/show_bug.cgi?id\u003d21904 as suggested (but with the guard clause factored in a method.)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137520 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-07-26, 3:12 p.m.",
      "commitName": "3b19309d76817dfacb40299b474ecbc27a471e11",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2003-07-26, 11:39 a.m.",
      "commitNameOld": "9410b31864bc0bddb53779883dfb15763abb5ade",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (!validateNumber(str)) {\n            return null;\n        }\n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float doens\u0027t have the presision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 220,
      "functionName": "createNumber",
      "diff": "@@ -1,142 +1,139 @@\n     public static Number createNumber(String str) throws NumberFormatException {\n-        if (str \u003d\u003d null) {\n+        if (!validateNumber(str)) {\n             return null;\n         }\n-        if (str.length() \u003d\u003d 0) {\n-            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n-        }\n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n         int decPos \u003d str.indexOf(\u0027.\u0027);\n         int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n                 dec \u003d str.substring(decPos + 1);\n             }\n             mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n                 mant \u003d str.substring(0, expPos);\n             } else {\n                 mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n             String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 isDigits(numeric.substring(1))\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float doens\u0027t have the presision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n             if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                 exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n                     Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n                 return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af6aba957f4dc4d19d5f295172b4ddc941ca1681": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-07-20, 12:03 p.m.",
      "commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003-07-20, 12:03 p.m.",
          "commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003-07-14, 6:25 p.m.",
          "commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 5.73,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (str.length() \u003d\u003d 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float doens\u0027t have the presision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
          "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
          "functionStartLine": 218,
          "functionName": "createNumber",
          "diff": "@@ -1,142 +1,142 @@\n-    public static Number createNumber(String val) throws NumberFormatException {\n-        if (val \u003d\u003d null) {\n+    public static Number createNumber(String str) throws NumberFormatException {\n+        if (str \u003d\u003d null) {\n             return null;\n         }\n-        if (val.length() \u003d\u003d 0) {\n+        if (str.length() \u003d\u003d 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n-        if (val.startsWith(\"--\")) {\n+        if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n-            return createInteger(val);\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+            return createInteger(str);\n         }   \n-        char lastChar \u003d val.charAt(val.length() - 1);\n+        char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n-        int decPos \u003d val.indexOf(\u0027.\u0027);\n-        int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n+        int decPos \u003d str.indexOf(\u0027.\u0027);\n+        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n-                dec \u003d val.substring(decPos + 1, expPos);\n+                dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n-                dec \u003d val.substring(decPos + 1);\n+                dec \u003d str.substring(decPos + 1);\n             }\n-            mant \u003d val.substring(0, decPos);\n+            mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n-                mant \u003d val.substring(0, expPos);\n+                mant \u003d str.substring(0, expPos);\n             } else {\n-                mant \u003d val;\n+                mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n-            if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-                exp \u003d val.substring(expPos + 1, val.length() - 1);\n+            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+                exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n-            String numeric \u003d val.substring(0, val.length() - 1);\n+            String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 isDigits(numeric.substring(1))\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float doens\u0027t have the presision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n-            if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-                exp \u003d val.substring(expPos + 1, val.length());\n+            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+                exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n-                    return createInteger(val);\n+                    return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n-                    return createLong(val);\n+                    return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n-                return createBigInteger(val);\n+                return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n-                    Float f \u003d createFloat(val);\n+                    Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n-                    Double d \u003d createDouble(val);\n+                    Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n-                return createBigDecimal(val);\n+                return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[val-String]",
            "newValue": "[str-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Update null handling behaviour and documentation\nbug 21734, from Phil Steiz\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137476 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2003-07-20, 12:03 p.m.",
          "commitName": "af6aba957f4dc4d19d5f295172b4ddc941ca1681",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2003-07-14, 6:25 p.m.",
          "commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 5.73,
          "commitsBetweenForRepo": 59,
          "commitsBetweenForFile": 1,
          "actualSource": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str \u003d\u003d null) {\n            return null;\n        }\n        if (str.length() \u003d\u003d 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar \u003d str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d str.indexOf(\u0027.\u0027);\n        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec \u003d str.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d str.substring(decPos + 1);\n            }\n            mant \u003d str.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d str.substring(0, expPos);\n            } else {\n                mant \u003d str;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d str.substring(0, str.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float doens\u0027t have the presision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n                exp \u003d str.substring(expPos + 1, str.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d \u003d createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
          "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
          "functionStartLine": 218,
          "functionName": "createNumber",
          "diff": "@@ -1,142 +1,142 @@\n-    public static Number createNumber(String val) throws NumberFormatException {\n-        if (val \u003d\u003d null) {\n+    public static Number createNumber(String str) throws NumberFormatException {\n+        if (str \u003d\u003d null) {\n             return null;\n         }\n-        if (val.length() \u003d\u003d 0) {\n+        if (str.length() \u003d\u003d 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n-        if (val.startsWith(\"--\")) {\n+        if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n-            return createInteger(val);\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+            return createInteger(str);\n         }   \n-        char lastChar \u003d val.charAt(val.length() - 1);\n+        char lastChar \u003d str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n-        int decPos \u003d val.indexOf(\u0027.\u0027);\n-        int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n+        int decPos \u003d str.indexOf(\u0027.\u0027);\n+        int expPos \u003d str.indexOf(\u0027e\u0027) + str.indexOf(\u0027E\u0027) + 1;\n \n         if (decPos \u003e -1) {\n \n             if (expPos \u003e -1) {\n                 if (expPos \u003c decPos) {\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n-                dec \u003d val.substring(decPos + 1, expPos);\n+                dec \u003d str.substring(decPos + 1, expPos);\n             } else {\n-                dec \u003d val.substring(decPos + 1);\n+                dec \u003d str.substring(decPos + 1);\n             }\n-            mant \u003d val.substring(0, decPos);\n+            mant \u003d str.substring(0, decPos);\n         } else {\n             if (expPos \u003e -1) {\n-                mant \u003d val.substring(0, expPos);\n+                mant \u003d str.substring(0, expPos);\n             } else {\n-                mant \u003d val;\n+                mant \u003d str;\n             }\n             dec \u003d null;\n         }\n         if (!Character.isDigit(lastChar)) {\n-            if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-                exp \u003d val.substring(expPos + 1, val.length() - 1);\n+            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+                exp \u003d str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp \u003d null;\n             }\n             //Requesting a specific type..\n-            String numeric \u003d val.substring(0, val.length() - 1);\n+            String numeric \u003d str.substring(0, str.length() - 1);\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             switch (lastChar) {\n                 case \u0027l\u0027 :\n                 case \u0027L\u0027 :\n                     if (dec \u003d\u003d null\n                         \u0026\u0026 exp \u003d\u003d null\n                         \u0026\u0026 isDigits(numeric.substring(1))\n                         \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n                         return createBigInteger(numeric);\n \n                     }\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 case \u0027f\u0027 :\n                 case \u0027F\u0027 :\n                     try {\n                         Float f \u003d NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                             //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                             //has non-zeros in it, then float doens\u0027t have the presision we want\n                             return f;\n                         }\n \n                     } catch (NumberFormatException nfe) {\n                     }\n                     //Fall through\n                 case \u0027d\u0027 :\n                 case \u0027D\u0027 :\n                     try {\n                         Double d \u003d NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                             return d;\n                         }\n                     } catch (NumberFormatException nfe) {\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n                     } catch (NumberFormatException e) {\n                     }\n                     //Fall through\n                 default :\n-                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n \n             }\n         } else {\n             //User doesn\u0027t have a preference on the return type, so let\u0027s start\n             //small and go from there...\n-            if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n-                exp \u003d val.substring(expPos + 1, val.length());\n+            if (expPos \u003e -1 \u0026\u0026 expPos \u003c str.length() - 1) {\n+                exp \u003d str.substring(expPos + 1, str.length());\n             } else {\n                 exp \u003d null;\n             }\n             if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                 //Must be an int,long,bigint\n                 try {\n-                    return createInteger(val);\n+                    return createInteger(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n-                    return createLong(val);\n+                    return createLong(str);\n                 } catch (NumberFormatException nfe) {\n                 }\n-                return createBigInteger(val);\n+                return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n                 boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                 try {\n-                    Float f \u003d createFloat(val);\n+                    Float f \u003d createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n-                    Double d \u003d createDouble(val);\n+                    Double d \u003d createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n \n-                return createBigDecimal(val);\n+                return createBigDecimal(str);\n \n             }\n         }\n     }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb": {
      "type": "Yintroduced",
      "commitMessage": "NumberUtils moved to math subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137379 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003-06-24, 5:14 p.m.",
      "commitName": "2d06a7ce861432fc702168fd4c94bc00ddfc39eb",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,142 @@\n+    public static Number createNumber(String val) throws NumberFormatException {\n+        if (val \u003d\u003d null) {\n+            return null;\n+        }\n+        if (val.length() \u003d\u003d 0) {\n+            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+        }\n+        if (val.startsWith(\"--\")) {\n+            // this is protection for poorness in java.lang.BigDecimal.\n+            // it accepts this as a legal value, but it does not appear \n+            // to be in specification of class. OS X Java parses it to \n+            // a wrong value.\n+            return null;\n+        }\n+        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n+            return createInteger(val);\n+        }   \n+        char lastChar \u003d val.charAt(val.length() - 1);\n+        String mant;\n+        String dec;\n+        String exp;\n+        int decPos \u003d val.indexOf(\u0027.\u0027);\n+        int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n+\n+        if (decPos \u003e -1) {\n+\n+            if (expPos \u003e -1) {\n+                if (expPos \u003c decPos) {\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                }\n+                dec \u003d val.substring(decPos + 1, expPos);\n+            } else {\n+                dec \u003d val.substring(decPos + 1);\n+            }\n+            mant \u003d val.substring(0, decPos);\n+        } else {\n+            if (expPos \u003e -1) {\n+                mant \u003d val.substring(0, expPos);\n+            } else {\n+                mant \u003d val;\n+            }\n+            dec \u003d null;\n+        }\n+        if (!Character.isDigit(lastChar)) {\n+            if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n+                exp \u003d val.substring(expPos + 1, val.length() - 1);\n+            } else {\n+                exp \u003d null;\n+            }\n+            //Requesting a specific type..\n+            String numeric \u003d val.substring(0, val.length() - 1);\n+            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+            switch (lastChar) {\n+                case \u0027l\u0027 :\n+                case \u0027L\u0027 :\n+                    if (dec \u003d\u003d null\n+                        \u0026\u0026 exp \u003d\u003d null\n+                        \u0026\u0026 isDigits(numeric.substring(1))\n+                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n+                        try {\n+                            return createLong(numeric);\n+                        } catch (NumberFormatException nfe) {\n+                            //Too big for a long\n+                        }\n+                        return createBigInteger(numeric);\n+\n+                    }\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                case \u0027f\u0027 :\n+                case \u0027F\u0027 :\n+                    try {\n+                        Float f \u003d NumberUtils.createFloat(numeric);\n+                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n+                            //has non-zeros in it, then float doens\u0027t have the presision we want\n+                            return f;\n+                        }\n+\n+                    } catch (NumberFormatException nfe) {\n+                    }\n+                    //Fall through\n+                case \u0027d\u0027 :\n+                case \u0027D\u0027 :\n+                    try {\n+                        Double d \u003d NumberUtils.createDouble(numeric);\n+                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                            return d;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                    }\n+                    try {\n+                        return createBigDecimal(numeric);\n+                    } catch (NumberFormatException e) {\n+                    }\n+                    //Fall through\n+                default :\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+\n+            }\n+        } else {\n+            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n+            //small and go from there...\n+            if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n+                exp \u003d val.substring(expPos + 1, val.length());\n+            } else {\n+                exp \u003d null;\n+            }\n+            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n+                //Must be an int,long,bigint\n+                try {\n+                    return createInteger(val);\n+                } catch (NumberFormatException nfe) {\n+                }\n+                try {\n+                    return createLong(val);\n+                } catch (NumberFormatException nfe) {\n+                }\n+                return createBigInteger(val);\n+\n+            } else {\n+                //Must be a float,double,BigDec\n+                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+                try {\n+                    Float f \u003d createFloat(val);\n+                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                        return f;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                }\n+                try {\n+                    Double d \u003d createDouble(val);\n+                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                }\n+\n+                return createBigDecimal(val);\n+\n+            }\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public static Number createNumber(String val) throws NumberFormatException {\n        if (val \u003d\u003d null) {\n            return null;\n        }\n        if (val.length() \u003d\u003d 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar \u003d val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos \u003d val.indexOf(\u0027.\u0027);\n        int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n\n        if (decPos \u003e -1) {\n\n            if (expPos \u003e -1) {\n                if (expPos \u003c decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec \u003d val.substring(decPos + 1, expPos);\n            } else {\n                dec \u003d val.substring(decPos + 1);\n            }\n            mant \u003d val.substring(0, decPos);\n        } else {\n            if (expPos \u003e -1) {\n                mant \u003d val.substring(0, expPos);\n            } else {\n                mant \u003d val;\n            }\n            dec \u003d null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n                exp \u003d val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp \u003d null;\n            }\n            //Requesting a specific type..\n            String numeric \u003d val.substring(0, val.length() - 1);\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            switch (lastChar) {\n                case \u0027l\u0027 :\n                case \u0027L\u0027 :\n                    if (dec \u003d\u003d null\n                        \u0026\u0026 exp \u003d\u003d null\n                        \u0026\u0026 isDigits(numeric.substring(1))\n                        \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case \u0027f\u0027 :\n                case \u0027F\u0027 :\n                    try {\n                        Float f \u003d NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                            //If it\u0027s too big for a float or the float value \u003d 0 and the string\n                            //has non-zeros in it, then float doens\u0027t have the presision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                    }\n                    //Fall through\n                case \u0027d\u0027 :\n                case \u0027D\u0027 :\n                    try {\n                        Double d \u003d NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn\u0027t have a preference on the return type, so let\u0027s start\n            //small and go from there...\n            if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n                exp \u003d val.substring(expPos + 1, val.length());\n            } else {\n                exp \u003d null;\n            }\n            if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n                try {\n                    Float f \u003d createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d \u003d createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n\n                return createBigDecimal(val);\n\n            }\n        }\n    }",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 206,
      "functionName": "createNumber"
    }
  }
}