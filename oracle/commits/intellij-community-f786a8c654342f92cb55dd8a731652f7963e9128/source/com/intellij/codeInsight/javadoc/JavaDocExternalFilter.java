package com.intellij.codeInsight.javadoc;

import com.intellij.codeInsight.CodeInsightBundle;
import com.intellij.ide.BrowserUtil;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vfs.VirtualFileManager;
import com.intellij.psi.PsiManager;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.util.net.HttpConfigurable;

import javax.swing.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.net.URL;

import org.jetbrains.annotations.NonNls;

/**
 * Created by IntelliJ IDEA.
 * User: db
 * Date: May 2, 2003
 * Time: 8:35:34 PM
 * To change this template use Options | File Templates.
 */

public class JavaDocExternalFilter {
  private static final Logger LOG = Logger.getInstance("#com.intellij.codeInsight.javadoc.JavaDocExternalFilter");

  private Project myProject;
  private PsiManager myManager;

  private static @NonNls Pattern ourHTMLsuffix = Pattern.compile("[.][hH][tT][mM][lL]?");
  private static @NonNls Pattern ourParentFolderprefix = Pattern.compile("^[.][.]/");
  private static @NonNls Pattern ourAnchorsuffix = Pattern.compile("#(.*)$");
  private static @NonNls Pattern ourHTMLFilesuffix = Pattern.compile("/[^/]*[.][hH][tT][mM][lL]?$");
  private static @NonNls Pattern ourHREFselector = Pattern.compile("<A[ \\t\\n\\r\\f]+HREF=\"([^>]*)\"");
  private static @NonNls Pattern ourAnnihilator = Pattern.compile("/[^/^.]*/[.][.]/");
  private static @NonNls Pattern ourIMGselector = Pattern.compile("<IMG[ \\t\\n\\r\\f]+SRC=\"([^>]*)\"");
  private static @NonNls Pattern ourMethodHeading = Pattern.compile("<H3>(.+)</H3>");
  private static @NonNls final String DOC_ELEMENT_PROTOCOL = "doc_element://";
  private static @NonNls final String PSI_ELEMENT_PROTOCOL = "psi_element://";
  private static @NonNls final String JAR_PROTOCOL = "jar:";
  private static @NonNls final String DOC_START_MARKER = "Generated by javadoc";

private static abstract class RefConvertor {
    private Pattern mySelector;

    public RefConvertor(Pattern selector) {
      mySelector = selector;
    }

    protected abstract String convertReference(String root, String href);

    public String refFilter(String root, String read) {
      String toMatch = read.toUpperCase();
      StringBuffer ready = new StringBuffer();
      int prev = 0;
      Matcher matcher = mySelector.matcher(toMatch);

      while (matcher.find()) {
        String before = read.substring(prev, matcher.start(1) - 1);     // Before reference
        String href = read.substring(matcher.start(1), matcher.end(1)); // The URL

        prev = matcher.end(1) + 1;
        ready.append(before);
        ready.append("\"");
        ready.append(convertReference(root, href));
        ready.append("\"");
      }

      ready.append(read.substring(prev, read.length()));

      return ready.toString();
    }
  }

  private RefConvertor myIMGConvertor = new RefConvertor(ourIMGselector) {
    protected String convertReference(String root, String href) {
      if (StringUtil.startsWithChar(href, '#')) {
        return DOC_ELEMENT_PROTOCOL + root + href;
      }

      return ourHTMLFilesuffix.matcher(root).replaceAll("/") + href;
    }
  };

  private RefConvertor[] myReferenceConvertors = new RefConvertor[]{
    new RefConvertor(ourHREFselector) {
      protected String convertReference(String root, String href) {
        if (BrowserUtil.isAbsoluteURL(href)) {
          return href;
        }

        if (StringUtil.startsWithChar(href, '#')) {
          return DOC_ELEMENT_PROTOCOL + root + href;
        }

        String nakedRoot = ourHTMLFilesuffix.matcher(root).replaceAll("/");

        String stripped = ourHTMLsuffix.matcher(href).replaceAll("");
        int len = stripped.length();

        do stripped = ourParentFolderprefix.matcher(stripped).replaceAll(""); while (len > (len = stripped.length()));

        final String elementRef = stripped.replaceAll("/", ".");
        final String classRef = ourAnchorsuffix.matcher(elementRef).replaceAll("");

        return
          (myManager.findClass(classRef, GlobalSearchScope.allScope(myProject)) != null)
          ? PSI_ELEMENT_PROTOCOL + elementRef
          : DOC_ELEMENT_PROTOCOL + doAnnihilate(nakedRoot + href);
      }
    },

    myIMGConvertor
  };

  public JavaDocExternalFilter(Project project) {
    myProject = project;
    myManager = PsiManager.getInstance(myProject);
  }

  private static String doAnnihilate(String path) {
    int len = path.length();

    do {
      path = ourAnnihilator.matcher(path).replaceAll("/");
    }
    while (len > (len = path.length()));

    return path;
  }

  private interface Waiter{
    void sayYes();

    boolean runMe();
  }

  public static boolean isJavaDocURL(String url) {
    final InputStream stream = getStreamByUrl(url);

    if (stream == null) {
      return false;
    }

    final Waiter waiter = new Waiter(){
      Boolean key = Boolean.FALSE;
      final Object LOCK = new Object();

      public void sayYes(){
        key = Boolean.TRUE;
        synchronized (LOCK) {
          LOCK.notify();
        }
      }

      public boolean runMe(){
        try {
          synchronized (LOCK) {
            LOCK.wait(600);
          }
        }
        catch (InterruptedException e) {
          return false;
        }

        return key.booleanValue();
      }
    };

    new Thread(new Runnable() {
      public void run() {
        try {
          BufferedReader reader = null;
          try {
            reader = new BufferedReader(new InputStreamReader(stream));
            int lookUp = 6;

            while (lookUp > 0) {
              if (reader.readLine().indexOf(DOC_START_MARKER) != -1) {
                waiter.sayYes();
              }

              lookUp--;
            }
          }
          finally {
            if (reader != null) {
              reader.close();
            }
          }


        }
        catch (final Exception e) {
          showErrorMessage(e);
        }
      }
    }).start();

    return waiter.runMe();
  }

  private String correctRefs(String root, String read) {
    String result = read;

    for (RefConvertor myReferenceConvertor : myReferenceConvertors) {
      result = myReferenceConvertor.refFilter(root, result);
    }

    return result;
  }

  public String filterInternalDocInfo(String text, String surl) {
    if (text == null) {
      return null;
    }

    text = JavaDocUtil.fixupText(text);

    if (surl == null) {
      return text;
    }

    String root = ourAnchorsuffix.matcher(surl).replaceAll("");

    return correctRefs(root, text);
  }


  private static InputStream getStreamByUrl(final String surl) {
    try {
      if (surl.startsWith(JAR_PROTOCOL)) {
        VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(BrowserUtil.getDocURL(surl));

        if (file == null) {
          return null;
        }

        return file.getInputStream();
      }

      URL url = BrowserUtil.getURL(surl);
      HttpConfigurable.getInstance().prepareURL(url.toString());
      return url.openStream();
    }
    catch (final IOException e) {
      showErrorMessage(e);
    }

    return null;
  }

  private static void showErrorMessage(final Exception e) {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        Messages.showMessageDialog(CodeInsightBundle.message("javadoc.external.fetch.error.message", e.getLocalizedMessage()),
                                   CodeInsightBundle.message("javadoc.external.fetch.error.title"),
                                   Messages.getErrorIcon());
      }
    });
  }

  @SuppressWarnings({"HardCodedStringLiteral"})
  public String getExternalDocInfo(String surl) {
    if (surl == null) {
      return null;
    }

    Matcher anchorMatcher = ourAnchorsuffix.matcher(surl);
    String startSection = "<!-- ======== START OF CLASS DATA ======== -->";
    String endSection = "SUMMARY ======== -->";
    boolean isClassDoc = true;

    if (anchorMatcher.find()) {
      isClassDoc = false;
      startSection = "<A NAME=\"" + anchorMatcher.group(1).toUpperCase() + "\"";
      endSection = "<A NAME=";
    }

    final String root = ourAnchorsuffix.matcher(surl).replaceAll("");

    InputStream stream = getStreamByUrl(surl);

    if (stream == null) {
      return null;
    }

    BufferedReader buf = null;

    StringBuffer data = new StringBuffer();

    data.append("<HTML>\n");



    try {

      buf = new BufferedReader(new InputStreamReader(stream));

      String read;

      do {
        read = buf.readLine();
      }
      while (read != null && read.toUpperCase().indexOf(startSection) == -1);


      if (read == null) {
        return null;
      }

      data.append(read);

      if (isClassDoc) {
        boolean skip = false;

        while (((read = buf.readLine()) != null) && !read.toUpperCase().equals("<DL>")) {
          if (read.toUpperCase().indexOf("</H2>") != -1) { // read=class name in <H2>
            data.append("</H2>\n");
            skip = true;
          }
          else if (!skip) data.append(read); //correctRefs(root, read));
        }

        data.append("<DL>\n");

        StringBuffer classDetails = new StringBuffer();

        while (((read = buf.readLine()) != null) && !read.toUpperCase().equals("<HR>")) {
          classDetails.append(read); //correctRefs(root, read));
          classDetails.append("\n");
        }

        while (((read = buf.readLine()) != null) && !read.toUpperCase().equals("<P>")) {
          data.append(read); //correctRefs(root, read));
          data.append("\n");
        }

        data.append(classDetails);
        data.append("<P>\n");
      }

      while (((read = buf.readLine()) != null) && read.indexOf(endSection) == -1) {

        if (read.toUpperCase().indexOf("<HR>") == -1) {
          data.append(read); //correctRefs(root, read));
          data.append("\n");
        }
      }

      data.append("</HTML>\n");

    }
    catch (final IOException e) {
      showErrorMessage(e);
    }
    finally {
      if (buf != null) {
        try {
          buf.close();
        }
        catch (IOException e) {
          showErrorMessage(e);
        }
      }
    }

    String docText = correctRefs(root, data.toString());

    if (LOG.isDebugEnabled()) {
      LOG.debug("Filtered JavaDoc: " + docText + "\n");
    }

    return JavaDocUtil.fixupText(docText);
  }

  public String getExternalDocInfoForElement(final String docURL, final PsiElement element) {
    String externalDoc = getExternalDocInfo(docURL);
    if (externalDoc != null) {
      if (element instanceof PsiMethod) {
        String className = ((PsiMethod) element).getContainingClass().getQualifiedName();
        Matcher matcher = ourMethodHeading.matcher(externalDoc);
        //noinspection HardCodedStringLiteral
        return matcher.replaceFirst("<H3>" + className + "</H3>");

      }
    }
    return externalDoc;
  }
}
