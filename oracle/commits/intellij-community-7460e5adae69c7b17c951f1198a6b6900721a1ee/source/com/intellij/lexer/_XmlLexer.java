/* The following code was generated by JFlex 1.4 on 1/13/05 11:58 AM */

/* It's an automatically generated code. Do not modify it. */
 package com.intellij.lexer;

 import com.intellij.psi.tree.IElementType;
 import com.intellij.psi.*;
 import com.intellij.psi.xml.*;


 /**
* This class is a scanner generated by
* <a href="http://www.jflex.de/">JFlex</a> 1.4
* on 1/13/05 11:58 AM from the specification file
* <tt>_XmlLexer.flex</tt>
*/
 public class _XmlLexer implements Lexer, Cloneable {
 /** initial size of the lookahead buffer */
 private static final int ZZ_BUFFERSIZE = 16384;

 /** lexical states */
 public static final int PROCESSING_INSTRUCTION = 9;
 public static final int ATTR_LIST = 4;
 public static final int END_TAG = 2;
 public static final int ATTR_VALUE_DQ = 7;
 public static final int DTD_MARKUP = 6;
 public static final int CDATA = 11;
 public static final int ATTR = 5;
 public static final int TAG = 1;
 public static final int YYINITIAL = 0;
 public static final int ATTR_VALUE_START = 6;
 public static final int COMMENT = 3;
 public static final int DOCTYPE = 10;
 public static final int ATTR_VALUE_SQ = 8;

 /**
  * Translates characters to character classes
  */
 private static final String ZZ_CMAP_PACKED =
   "\11\0\2\3\1\0\2\3\22\0\1\3\1\7\1\51\1\34\2\0"+
   "\1\17\1\52\5\0\1\5\1\4\1\54\12\2\1\1\1\22\1\6"+
   "\1\55\1\16\1\53\1\0\1\13\1\46\1\11\1\12\1\42\1\36"+
   "\2\1\1\50\2\1\1\47\1\44\1\1\1\37\1\41\2\1\1\43"+
   "\1\14\1\45\3\1\1\40\1\1\1\10\1\0\1\15\1\0\1\1"+
   "\1\0\1\23\1\32\4\36\1\20\4\1\1\20\1\33\1\31\1\25"+
   "\1\24\1\27\1\1\1\26\1\21\1\30\2\1\1\35\2\1\uff85\0";

 /**
  * Translates characters to character classes
  */
 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

 /**
  * Translates DFA states to action switch labels.
  */
 private static final int [] ZZ_ACTION = zzUnpackAction();

 private static final String ZZ_ACTION_PACKED_0 =
   "\3\0\1\1\3\0\2\2\3\0\1\3\1\4\1\5"+
   "\2\6\1\7\1\6\1\10\1\6\1\11\1\1\1\0"+
   "\1\12\3\13\1\14\1\15\1\16\3\2\1\17\2\2"+
   "\1\20\1\6\1\21\1\6\1\22\2\21\2\6\1\3"+
   "\1\0\1\23\1\24\7\0\1\25\2\0\2\2\1\26"+
   "\1\0\1\27\1\0\2\21\1\0\1\2\5\0\1\30"+
   "\10\0\1\31\4\2\2\21\1\32\1\33\2\0\1\34"+
   "\2\0\1\33\1\2\1\33\1\2\2\21\2\0\2\2"+
   "\2\21\2\0\2\2\1\35\1\36\2\0\2\2\2\0"+
   "\2\2\1\37\1\40\2\37";

 private static int [] zzUnpackAction() {
   int [] result = new int[128];
   int offset = 0;
   offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackAction(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }


 /**
  * Translates a state to a row index in the transition table
  */
 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

 private static final String ZZ_ROWMAP_PACKED_0 =
   "\0\0\0\56\0\134\0\212\0\270\0\346\0\u0114\0\u0142"+
   "\0\u0170\0\u019e\0\u01cc\0\u01fa\0\u0228\0\u0256\0\u0284\0\u02b2"+
   "\0\u0228\0\u02e0\0\u030e\0\u0228\0\u033c\0\u036a\0\u0398\0\u03c6"+
   "\0\u03f4\0\u0228\0\u030e\0\u02b2\0\u0228\0\u0228\0\u0228\0\u0422"+
   "\0\u0450\0\u02b2\0\u0228\0\u047e\0\u04ac\0\u04da\0\u0508\0\u0536"+
   "\0\u0564\0\u0228\0\u0592\0\u05c0\0\u05ee\0\u061c\0\u064a\0\u0678"+
   "\0\u0228\0\u0228\0\u06a6\0\u06d4\0\u0702\0\u0730\0\u075e\0\u078c"+
   "\0\u07ba\0\u0228\0\u07e8\0\u0816\0\u0844\0\u0872\0\u0228\0\u0564"+
   "\0\u0228\0\u08a0\0\u08ce\0\u08fc\0\u05ee\0\u0228\0\u061c\0\u092a"+
   "\0\u0958\0\u0986\0\u09b4\0\u0228\0\u09e2\0\u0a10\0\u0a3e\0\u0a6c"+
   "\0\u0a9a\0\u0ac8\0\u0af6\0\u0b24\0\u0228\0\u0b52\0\u0b80\0\u0bae"+
   "\0\u0bdc\0\u0c0a\0\u0c38\0\u0228\0\u0228\0\u0c66\0\u0c94\0\u0228"+
   "\0\u0cc2\0\u0cf0\0\u0422\0\u0d1e\0\u047e\0\u0d4c\0\u0d7a\0\u0da8"+
   "\0\u0dd6\0\u0e04\0\u0e32\0\u0e60\0\u0e8e\0\u0ebc\0\u0eea\0\u0f18"+
   "\0\u0f46\0\u0f74\0\u0536\0\u0536\0\u0fa2\0\u0fd0\0\u0ffe\0\u102c"+
   "\0\u105a\0\u1088\0\u10b6\0\u10e4\0\u0228\0\u0228\0\u0422\0\u047e";

 private static int [] zzUnpackRowMap() {
   int [] result = new int[128];
   int offset = 0;
   offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
   int i = 0;  /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int high = packed.charAt(i++) << 16;
     result[j++] = high | packed.charAt(i++);
   }
   return j;
 }

 /**
  * The transition table of the DFA
  */
 private static final int [] ZZ_TRANS = zzUnpackTrans();

 private static final String ZZ_TRANS_PACKED_0 =
   "\3\15\1\16\2\15\1\17\10\15\1\20\36\15\1\21"+
   "\1\22\1\21\1\16\2\21\1\23\2\21\4\22\1\21"+
   "\1\24\1\20\2\22\1\21\11\22\1\21\14\22\3\21"+
   "\1\25\2\21\1\26\1\21\1\16\2\21\1\23\2\21"+
   "\4\26\1\21\1\24\1\20\2\26\1\21\11\26\1\21"+
   "\14\26\5\21\5\27\1\30\50\27\1\21\1\31\1\21"+
   "\1\16\2\21\1\23\2\21\4\31\2\21\1\20\2\31"+
   "\1\21\11\31\1\21\14\31\5\21\3\32\1\16\2\32"+
   "\1\33\10\32\1\34\31\32\1\35\1\36\2\32\1\37"+
   "\6\21\1\23\10\21\1\20\36\21\6\40\1\41\10\40"+
   "\1\42\31\40\1\43\4\40\6\44\1\45\10\44\1\42"+
   "\32\44\1\43\3\44\1\21\1\46\4\21\1\23\2\21"+
   "\4\46\2\21\1\20\2\46\1\21\11\46\1\21\14\46"+
   "\2\21\1\47\3\21\1\50\1\21\1\16\2\21\1\23"+
   "\1\21\1\51\4\50\1\21\1\52\1\20\2\50\1\21"+
   "\11\50\1\21\4\50\1\53\1\50\1\54\5\50\1\55"+
   "\1\56\3\21\15\15\1\57\40\15\61\0\1\16\61\0"+
   "\1\60\43\0\1\61\1\62\2\0\1\63\7\0\4\63"+
   "\3\0\1\64\1\63\1\0\1\65\3\63\1\66\1\63"+
   "\1\67\2\63\1\70\14\63\6\0\2\22\1\0\2\22"+
   "\3\0\4\22\3\0\2\22\1\0\11\22\1\0\14\22"+
   "\14\0\1\71\64\0\1\72\40\0\2\26\1\0\2\26"+
   "\3\0\4\26\3\0\2\26\1\0\11\26\1\0\14\26"+
   "\5\0\5\27\1\73\55\27\1\74\50\27\1\0\2\31"+
   "\1\0\2\31\3\0\4\31\3\0\2\31\1\0\11\31"+
   "\1\0\14\31\5\0\17\40\1\0\31\40\1\0\13\40"+
   "\1\75\7\40\1\0\31\40\1\0\4\40\17\44\1\0"+
   "\32\44\1\0\12\44\1\76\7\44\1\0\32\44\1\0"+
   "\3\44\1\0\2\46\1\0\2\46\3\0\4\46\3\0"+
   "\2\46\1\0\11\46\1\0\14\46\23\0\1\77\40\0"+
   "\2\50\1\0\2\50\3\0\4\50\3\0\2\50\1\0"+
   "\11\50\1\0\14\50\5\0\15\100\1\101\33\100\1\102"+
   "\4\100\1\0\2\50\1\0\2\50\3\0\4\50\3\0"+
   "\2\50\1\0\11\50\1\0\10\50\1\103\3\50\6\0"+
   "\2\50\1\0\2\50\3\0\4\50\3\0\2\50\1\0"+
   "\11\50\1\0\3\50\1\104\10\50\5\0\51\105\1\106"+
   "\4\105\52\107\1\106\3\107\15\0\1\110\45\0\1\111"+
   "\2\0\1\112\1\0\1\113\44\0\2\63\1\0\2\63"+
   "\3\0\4\63\3\0\2\63\1\114\11\63\1\0\14\63"+
   "\6\0\2\63\1\0\2\63\3\0\4\63\3\0\1\63"+
   "\1\115\1\114\11\63\1\0\14\63\6\0\2\63\1\0"+
   "\2\63\3\0\4\63\3\0\2\63\1\114\1\63\1\116"+
   "\6\63\1\117\1\0\14\63\6\0\2\63\1\0\2\63"+
   "\3\0\4\63\3\0\2\63\1\114\5\63\1\120\3\63"+
   "\1\0\14\63\6\0\2\63\1\0\2\63\3\0\4\63"+
   "\3\0\2\63\1\114\7\63\1\121\1\63\1\0\14\63"+
   "\7\0\1\122\32\0\1\123\25\0\1\111\2\0\1\112"+
   "\45\0\5\27\1\124\66\27\1\125\37\27\5\40\1\126"+
   "\2\40\1\127\6\40\1\0\31\40\1\0\4\40\5\44"+
   "\1\130\2\44\1\131\6\44\1\0\32\44\1\0\3\44"+
   "\51\102\1\100\4\102\1\0\2\50\1\0\2\50\3\0"+
   "\4\50\3\0\2\50\1\0\11\50\1\0\11\50\1\132"+
   "\2\50\6\0\2\50\1\0\2\50\3\0\4\50\3\0"+
   "\2\50\1\0\11\50\1\0\6\50\1\133\5\50\23\0"+
   "\1\134\44\0\1\135\61\0\1\136\103\0\1\137\17\0"+
   "\2\63\1\0\2\63\3\0\4\63\3\0\2\63\1\140"+
   "\11\63\1\0\14\63\6\0\2\63\1\0\2\63\3\0"+
   "\4\63\3\0\2\63\1\114\2\63\1\141\6\63\1\0"+
   "\14\63\6\0\2\63\1\0\2\63\3\0\4\63\3\0"+
   "\2\63\1\114\1\63\1\115\7\63\1\0\14\63\6\0"+
   "\2\63\1\0\2\63\3\0\4\63\3\0\2\63\1\114"+
   "\2\63\1\64\6\63\1\0\14\63\6\0\2\63\1\0"+
   "\2\63\3\0\4\63\3\0\2\63\1\114\3\63\1\117"+
   "\5\63\1\0\14\63\7\0\1\122\17\0\1\140\35\0"+
   "\1\142\6\0\3\142\7\0\1\142\6\0\1\142\3\0"+
   "\1\142\3\0\1\142\3\0\1\142\7\0\16\27\1\0"+
   "\37\27\5\40\1\143\11\40\1\0\31\40\1\0\15\40"+
   "\1\144\5\40\1\0\31\40\1\0\4\40\5\44\1\145"+
   "\11\44\1\0\32\44\1\0\14\44\1\146\5\44\1\0"+
   "\32\44\1\0\3\44\1\0\2\50\1\0\2\50\3\0"+
   "\4\50\3\0\2\50\1\0\11\50\1\0\12\50\1\147"+
   "\1\50\6\0\2\50\1\0\2\50\3\0\3\50\1\150"+
   "\3\0\2\50\1\0\11\50\1\0\14\50\17\0\1\151"+
   "\54\0\1\152\45\0\2\63\1\0\2\63\3\0\4\63"+
   "\3\0\2\63\1\114\3\63\1\115\5\63\1\0\14\63"+
   "\7\0\1\142\6\0\3\142\6\0\1\140\1\142\6\0"+
   "\1\142\3\0\1\142\3\0\1\142\3\0\1\142\7\0"+
   "\12\40\1\153\4\40\1\0\31\40\1\0\4\40\12\44"+
   "\1\154\4\44\1\0\32\44\1\0\3\44\1\0\2\50"+
   "\1\0\2\50\3\0\4\50\3\0\2\50\1\0\11\50"+
   "\1\0\13\50\1\155\6\0\2\50\1\0\2\50\3\0"+
   "\4\50\3\0\2\50\1\0\11\50\1\0\5\50\1\156"+
   "\6\50\20\0\1\157\56\0\1\160\41\0\13\40\1\161"+
   "\3\40\1\0\31\40\1\0\4\40\13\44\1\162\3\44"+
   "\1\0\32\44\1\0\3\44\1\0\2\50\1\0\2\50"+
   "\3\0\1\163\3\50\3\0\2\50\1\0\11\50\1\0"+
   "\14\50\6\0\2\50\1\0\2\50\3\0\4\50\3\0"+
   "\2\50\1\0\11\50\1\0\7\50\1\164\4\50\21\0"+
   "\1\165\101\0\1\166\15\0\14\40\1\167\2\40\1\0"+
   "\31\40\1\0\4\40\14\44\1\170\2\44\1\0\32\44"+
   "\1\0\3\44\13\0\1\171\103\0\1\172\14\0\13\40"+
   "\1\173\3\40\1\0\31\40\1\0\4\40\13\44\1\174"+
   "\3\44\1\0\32\44\1\0\3\44\10\0\1\175\107\0"+
   "\1\176\13\0\10\40\1\177\6\40\1\0\31\40\1\0"+
   "\4\40\10\44\1\200\6\44\1\0\32\44\1\0\3\44";

 private static int [] zzUnpackTrans() {
   int [] result = new int[4370];
   int offset = 0;
   offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackTrans(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     value--;
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }


 /* error codes */
 private static final int ZZ_UNKNOWN_ERROR = 0;
 private static final int ZZ_NO_MATCH = 1;
 private static final int ZZ_PUSHBACK_2BIG = 2;
 private static final char[] EMPTY_BUFFER = new char[0];
 private static final int YYEOF = -1;

 /* error messages for the codes above */
 private static final String ZZ_ERROR_MSG[] = {
   "Unkown internal scanner error",
   "Error: could not match input",
   "Error: pushback value was too large"
 };

 /**
  * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
  */
 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

 private static final String ZZ_ATTRIBUTE_PACKED_0 =
   "\3\0\1\1\3\0\2\1\3\0\1\11\3\1\1\11"+
   "\2\1\1\11\3\1\1\0\1\1\1\11\2\1\3\11"+
   "\3\1\1\11\6\1\1\11\5\1\1\0\2\11\7\0"+
   "\1\11\2\0\2\1\1\11\1\0\1\11\1\0\2\1"+
   "\1\0\1\11\5\0\1\11\10\0\1\11\6\1\2\11"+
   "\2\0\1\11\2\0\6\1\2\0\4\1\2\0\4\1"+
   "\2\0\2\1\2\0\2\1\2\11\2\1";

 private static int [] zzUnpackAttribute() {
   int [] result = new int[128];
   int offset = 0;
   offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }

 /** the current state of the DFA */
 private int zzState;

 /** the current lexical state */
 private int zzLexicalState = YYINITIAL;

 /** this buffer contains the current text to be matched and is
     the source of the yytext() string */
 private char zzBuffer[] = EMPTY_BUFFER;

 /** the textposition at the last accepting state */
 private int zzMarkedPos;

 /** the textposition at the last state to be included in yytext */
 private int zzPushbackPos;

 /** the current text position in the buffer */
 private int zzCurrentPos;

 /** startRead marks the beginning of the yytext() string in the buffer */
 private int zzStartRead;

 /** endRead marks the last character in the buffer, that has been read
     from input */
 private int zzEndRead;

 /**
  * zzAtBOL == true <=> the scanner is currently at the beginning of a line
  */
 private boolean zzAtBOL = true;

 /** zzAtEOF == true <=> the scanner is at the EOF */
 private boolean zzAtEOF;

 /** denotes if the user-EOF-code has already been executed */
 private boolean zzEOFDone;

 /* user code: */
 private IElementType myTokenType;
 private int myPrevState = YYINITIAL;
 private int myState = YYINITIAL;

 public _XmlLexer(){
   this((java.io.Reader)null);
 }

 public final void start(char[] buffer){
   start(buffer, 0, buffer.length);
 }

 public final void start(char[] buffer, int startOffset, int endOffset){
   start(buffer, startOffset, endOffset, (short)YYINITIAL);
 }

 public final void start(char[] buffer, int startOffset, int endOffset, int initialState){
   zzBuffer = buffer;
   zzCurrentPos = zzMarkedPos = zzStartRead = startOffset;
   zzPushbackPos = 0;
   zzAtEOF  = false;
   zzEndRead = endOffset;
   myTokenType = null;
   yybegin(initialState & 15);
   myPrevState = (initialState >> 4) & 15;
   packState();
 }

 public final int getState(){
   return myState;
 }

 private void packState() {
   myState = ((myPrevState & 15) << 4) | (zzLexicalState & 15);
 }

 public final int getLastState() {
   return 11;
 }

 public final IElementType getTokenType(){
   locateToken();
   return myTokenType;
 }

 public final int getTokenStart(){
   locateToken();
   return zzStartRead - zzPushbackPos;
 }

 public final int getTokenEnd(){
   return getTokenStart() + yylength();
 }

 public final void advance(){
   locateToken();
   myTokenType = null;
   packState();
 }

 public final char[] getBuffer(){
   return zzBuffer;
 }

 public final int getBufferEnd(){
   return zzEndRead;
 }

 protected final void locateToken(){
   if (myTokenType != null) return;
   try{
   _locateToken();
   }
   catch(java.io.IOException ioe){}
 }

 public int getSmartUpdateShift() {
   return 10;
 }

 private int popState(){
   final int prev = myPrevState;
   myPrevState = YYINITIAL;
   return prev;
 }

 private void pushState(int state){
   myPrevState = state;
 }

 public Object clone() {
   try{
     return super.clone();
   }
   catch(CloneNotSupportedException e){
     return null;
   }
 }


 /**
  * Creates a new scanner
  * There is also a java.io.InputStream version of this constructor.
  *
  * @param   in  the java.io.Reader to read input from.
  */
 public _XmlLexer(java.io.Reader in) {
     myTokenType = null;
 }

 /**
  * Creates a new scanner.
  * There is also java.io.Reader version of this constructor.
  *
  * @param   in  the java.io.Inputstream to read input from.
  */
 public _XmlLexer(java.io.InputStream in) {
   this(new java.io.InputStreamReader(in));
 }

 /**
  * Unpacks the compressed character translation table.
  *
  * @param packed   the packed character translation table
  * @return         the unpacked character translation table
  */
 private static char [] zzUnpackCMap(String packed) {
   char [] map = new char[0x10000];
   int i = 0;  /* index in packed string  */
   int j = 0;  /* index in unpacked array */
   while (i < 140) {
     int  count = packed.charAt(i++);
     char value = packed.charAt(i++);
     do map[j++] = value; while (--count > 0);
   }
   return map;
 }


 /**
  * Refills the input buffer.
  *
  * @return      <code>false</code>, iff there was new input.
  *
  * @exception   java.io.IOException  if any I/O-Error occurs
  */
 private boolean zzRefill() throws java.io.IOException {
   return true;
 }


 /**
  * Closes the input stream.
  */
 public final void yyclose() throws java.io.IOException {
   zzAtEOF = true;            /* indicate end of file */
   zzEndRead = zzStartRead;  /* invalidate buffer    */
 }


 /**
  * Resets the scanner to read from a new input stream.
  * Does not close the old reader.
  *
  * All internal variables are reset, the old input stream
  * <b>cannot</b> be reused (internal buffer is discarded and lost).
  * Lexical state is set to <tt>ZZ_INITIAL</tt>.
  *
  * @param reader   the new input stream
  */
 public final void yyreset(java.io.Reader reader) {
   zzAtBOL  = true;
   zzAtEOF  = false;
   zzEndRead = zzStartRead = 0;
   zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
   zzLexicalState = YYINITIAL;
 }


 /**
  * Returns the current lexical state.
  */
 public final int yystate() {
   return zzLexicalState;
 }


 /**
  * Enters a new lexical state
  *
  * @param newState the new lexical state
  */
 public final void yybegin(int newState) {
   zzLexicalState = newState;
 }


 /**
  * Returns the text matched by the current regular expression.
  */
 public final String yytext() {
   return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
 }


 /**
  * Returns the character at position <tt>pos</tt> from the
  * matched text.
  *
  * It is equivalent to yytext().charAt(pos), but faster
  *
  * @param pos the position of the character to fetch.
  *            A value from 0 to yylength()-1.
  *
  * @return the character at position pos
  */
 public final char yycharat(int pos) {
   return zzBuffer[zzStartRead+pos];
 }


 /**
  * Returns the length of the matched text region.
  */
 public final int yylength() {
   return zzMarkedPos-zzStartRead;
 }


 /**
  * Reports an error that occured while scanning.
  *
  * In a wellformed scanner (no or only correct usage of
  * yypushback(int) and a match-all fallback rule) this method
  * will only be called with things that "Can't Possibly Happen".
  * If this method is called, something is seriously wrong
  * (e.g. a JFlex bug producing a faulty scanner etc.).
  *
  * Usual syntax/scanner level error handling should be done
  * in error fallback rules.
  *
  * @param   errorCode  the code of the errormessage to display
  */
 private void zzScanError(int errorCode) {
   String message;
   try {
     message = ZZ_ERROR_MSG[errorCode];
   }
   catch (ArrayIndexOutOfBoundsException e) {
     message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
   }

   throw new Error(message);
 }


 /**
  * Pushes the specified amount of characters back into the input stream.
  *
  * They will be read again by then next call of the scanning method
  *
  * @param number  the number of characters to be read again.
  *                This number must not be greater than yylength()!
  */
 public void yypushback(int number)  {
   if ( number > yylength() )
     zzScanError(ZZ_PUSHBACK_2BIG);

   zzMarkedPos -= number;
 }


 /**
  * Contains user EOF-code, which will be executed exactly once,
  * when the end of file is reached
  */
 private void zzDoEOF() {
   if (!zzEOFDone) {
     zzEOFDone = true;

   }
 }


 /**
  * Resumes scanning until the next regular expression is matched,
  * the end of input is encountered or an I/O-Error occurs.
  *
  * @exception   java.io.IOException  if any I/O-Error occurs
  */
 public void _locateToken() throws java.io.IOException {
   int zzInput;
   int zzAction;

   // cached fields:
   int zzCurrentPosL;
   int zzMarkedPosL;
   int zzEndReadL = zzEndRead;
   char [] zzBufferL = zzBuffer;
   char [] zzCMapL = ZZ_CMAP;

   int [] zzTransL = ZZ_TRANS;
   int [] zzRowMapL = ZZ_ROWMAP;
   int [] zzAttrL = ZZ_ATTRIBUTE;

   while (true) {
     zzMarkedPosL = zzMarkedPos;

     zzAction = -1;

     zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

     zzState = zzLexicalState;


     zzForAction: {
       while (true) {

         if (zzCurrentPosL < zzEndReadL)
           zzInput = zzBufferL[zzCurrentPosL++];
         else if (zzAtEOF) {
           zzInput = YYEOF;
           break zzForAction;
         }
         else {
           // store back cached positions
           zzCurrentPos  = zzCurrentPosL;
           zzMarkedPos   = zzMarkedPosL;
           boolean eof = zzRefill();
           // get translated positions and possibly new buffer
           zzCurrentPosL  = zzCurrentPos;
           zzMarkedPosL   = zzMarkedPos;
           zzBufferL      = zzBuffer;
           zzEndReadL     = zzEndRead;
           if (eof) {
             zzInput = YYEOF;
             break zzForAction;
           }
           else {
             zzInput = zzBufferL[zzCurrentPosL++];
           }
         }
         int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
         if (zzNext == -1) break zzForAction;
         zzState = zzNext;

         int zzAttributes = zzAttrL[zzState];
         if ( (zzAttributes & 1) == 1 ) {
           zzAction = zzState;
           zzMarkedPosL = zzCurrentPosL;
           if ( (zzAttributes & 8) == 8 ) break zzForAction;
         }

       }
     }

     // store back cached position
     zzMarkedPos = zzMarkedPosL;

     switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
       case 30:
         { myTokenType = XmlTokenType.XML_DOCTYPE_SYSTEM;  return;
         }
       case 33: break;
       case 24:
         { myTokenType = XmlTokenType.XML_ENTITY_REF_TOKEN; return;
         }
       case 34: break;
       case 21:
         { myTokenType = XmlTokenType.XML_EMPTY_ELEMENT_END; yybegin(YYINITIAL); return;
         }
       case 35: break;
       case 27:
         { myTokenType = XmlTokenType.XML_COMMENT_START; yybegin(COMMENT); return;
         }
       case 36: break;
       case 10:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR); return;
         }
       case 37: break;
       case 28:
         { myTokenType = XmlTokenType.XML_CHAR_ENTITY_REF; return;
         }
       case 38: break;
       case 26:
         { myTokenType = XmlTokenType.XML_CDATA_END; yybegin(YYINITIAL); return;
         }
       case 39: break;
       case 1:
         { myTokenType = XmlTokenType.XML_COMMENT_CHARACTERS; return;
         }
       case 40: break;
       case 29:
         { myTokenType = XmlTokenType.XML_DOCTYPE_PUBLIC;  return;
         }
       case 41: break;
       case 13:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER; yybegin(ATTR_VALUE_SQ); return;
         }
       case 42: break;
       case 12:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER; yybegin(ATTR_VALUE_DQ); return;
         }
       case 43: break;
       case 6:
         { if(yystate() == YYINITIAL){
       myTokenType = XmlTokenType.XML_BAD_CHARACTER;
       return;
     }
     else yybegin(popState()); yypushback(yylength());
         }
       case 44: break;
       case 32:
         { myTokenType = XmlTokenType.XML_DOCTYPE_START; yybegin(DOCTYPE); return;
         }
       case 45: break;
       case 23:
         { myTokenType = XmlTokenType.XML_MARKUP; return;
         }
       case 46: break;
       case 16:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR_LIST); pushState(PROCESSING_INSTRUCTION); return;
         }
       case 47: break;
       case 8:
         { myTokenType = XmlTokenType.XML_TAG_END; yybegin(YYINITIAL); return;
         }
       case 48: break;
       case 14:
         { myTokenType = XmlTokenType.XML_EQ; return;
         }
       case 49: break;
       case 31:
         { myTokenType = XmlTokenType.XML_CDATA_START; yybegin(CDATA); return;
         }
       case 50: break;
       case 5:
         { myTokenType = XmlTokenType.XML_START_TAG_START; yybegin(TAG); return;
         }
       case 51: break;
       case 18:
         { myTokenType = XmlTokenType.XML_DOCTYPE_END;  yybegin(YYINITIAL); return;
         }
       case 52: break;
       case 7:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR_LIST); pushState(TAG); return;
         }
       case 53: break;
       case 25:
         { myTokenType = XmlTokenType.XML_COMMENT_END; yybegin(YYINITIAL); return;
         }
       case 54: break;
       case 9:
         { myTokenType = XmlTokenType.XML_NAME; return;
         }
       case 55: break;
       case 19:
         { myTokenType = XmlTokenType.XML_PI_START; yybegin(PROCESSING_INSTRUCTION); return;
         }
       case 56: break;
       case 11:
         { yybegin(ATTR_LIST); yypushback(yylength());
         }
       case 57: break;
       case 2:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN; return;
         }
       case 58: break;
       case 4:
         { myTokenType = XmlTokenType.XML_WHITE_SPACE; return;
         }
       case 59: break;
       case 15:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER; yybegin(ATTR_LIST); return;
         }
       case 60: break;
       case 17:
         { myTokenType = XmlTokenType.XML_NAME;  return;
         }
       case 61: break;
       case 3:
         { myTokenType = XmlTokenType.XML_DATA_CHARACTERS; return;
         }
       case 62: break;
       case 22:
         { myTokenType = XmlTokenType.XML_PI_END; yybegin(YYINITIAL); return;
         }
       case 63: break;
       case 20:
         { myTokenType = XmlTokenType.XML_END_TAG_START; yybegin(END_TAG); return;
         }
       case 64: break;
       default:
         if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
           zzAtEOF = true;
           zzDoEOF();
           return;
         }
         else {
           zzScanError(ZZ_NO_MATCH);
         }
     }
   }
 }


 }
